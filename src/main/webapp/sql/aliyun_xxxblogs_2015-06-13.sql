# ************************************************************
# Sequel Pro SQL dump
# Version 3408
#
# http://www.sequelpro.com/
# http://code.google.com/p/sequel-pro/
#
# Host: 112.74.81.77 (MySQL 5.1.73)
# Database: xxxblogs
# Generation Time: 2015-06-13 04:34:12 +0000
# ************************************************************


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;


# Dump of table tb_article
# ------------------------------------------------------------

DROP TABLE IF EXISTS `tb_article`;

CREATE TABLE `tb_article` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `title` varchar(256) DEFAULT '' COMMENT '标题',
  `content` text COMMENT '正文内容',
  `pics` varchar(256) DEFAULT '' COMMENT '本地上传图片，ueditor路径',
  `creater` varchar(20) DEFAULT '' COMMENT '创建人',
  `createtime` datetime DEFAULT NULL COMMENT '创建时间',
  `lastmodifier` varchar(20) DEFAULT '' COMMENT '最后修改人',
  `lastmodifytime` datetime DEFAULT NULL COMMENT '最后修改时间',
  `xxxpics` varchar(256) DEFAULT '' COMMENT '最终的图片路径，urls，存放在文章中的路径',
  `xxxrealpathpics` varchar(256) DEFAULT '' COMMENT '在文章中的路径，服务器上的物理路径',
  `fromurl` varchar(256) DEFAULT NULL COMMENT '文章来源',
  `categoryname` varchar(40) DEFAULT NULL COMMENT '类别名称',
  `categoryid` int(11) DEFAULT NULL COMMENT '类别id',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `tb_article` WRITE;
/*!40000 ALTER TABLE `tb_article` DISABLE KEYS */;

INSERT INTO `tb_article` (`id`, `title`, `content`, `pics`, `creater`, `createtime`, `lastmodifier`, `lastmodifytime`, `xxxpics`, `xxxrealpathpics`, `fromurl`, `categoryname`, `categoryid`)
VALUES
	(1,'ssh常见错误一(result \'null\' not found)小结','<p><span style=\"color:#ff0000\">问题描述：</span></p> \n<p><span style=\"white-space:pre\"></span><span style=\"color:#ff0000\">如图所示：</span></p> \n<p><img src=\"http://img.blog.csdn.net/20140319124721953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHh4ODIzOTUyMzc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br> </p> \n<p><span style=\"white-space:pre\"></span><strong><span style=\"font-size:18px; color:#ff0000\">当我在第2页编辑学号为11的学生后，修改学生的信息，然后保存。处理过程如下：</span></strong></p> \n<p><img src=\"http://img.blog.csdn.net/20140319125007406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHh4ODIzOTUyMzc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br> </p> \n<p><span style=\"font-size:18px; color:#ff0000\">按修改后希望跳转回第2页。</span></p> \n<p><img src=\"http://img.blog.csdn.net/20140319125259531?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHh4ODIzOTUyMzc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br> </p> \n<p><span style=\"white-space:pre\"></span>以上便是我需要达到的效果：</p> \n<p><span style=\"white-space:pre\"></span>在实现过程中出现了一些错误，<span style=\"font-size:24px; color:#ff0000\">404 - result \'null\' not found，</span></p> \n<p><span style=\"white-space:pre\"></span>根据在网上所查的资料，发现时struts.xml配置文件里面有错误。</p> \n<p></p>\n<pre code_snippet_id=\"244961\" snippet_file_name=\"blog_20140319_1_1583463\" name=\"code\" class=\"html\"><span style=\"white-space:pre\">	</span>&lt;action name=\"student\" class=\"com.xxx.action.StudentAction\"&gt;\n	<span style=\"white-space:pre\">	</span>&lt;!-- 显示学生信息--&gt;\n	<span style=\"white-space:pre\">	</span>&lt;result name=\"show\"&gt;/show.jsp&lt;/result&gt;\n	<span style=\"white-space:pre\">	</span>&lt;!--准备修改学生信息--&gt;\n	<span style=\"white-space:pre\">	</span>&lt;result name=\"edit\"&gt;/update.jsp&lt;/result&gt;\n	<span style=\"white-space:pre\">	</span>&lt;!-- 修改学生信息--&gt;\n	<span style=\"white-space:pre\">	</span>&lt;result name=\"update\" <span style=\"color:#ff0000;\">type=\"redirectAction\"</span>&gt;\n	<span style=\"white-space:pre\">	</span>	&lt;param name=\"actionName\"&gt;student!show.action&lt;/param&gt;  \n        <span style=\"white-space:pre\">		</span>&lt;param name=\"currentPage\"&gt;${currentPage}&lt;/param&gt;\n	<span style=\"white-space:pre\">	</span>&lt;/result&gt;\n	<span style=\"white-space:pre\">	</span>&lt;result name=\"error\"&gt;/error.jsp&lt;/result&gt;\n&lt;/action&gt;</pre>上面的是修改正确的文件。\n<br> \n<br> \n<p></p> \n<p>type=\"redirectAction是配置的关键信息 ，若没有它变会出现<span style=\"color:rgb(255,0,0); font-size:24px\">404 - result \'null\' not found错误</span><br> </p> \n<p>下面是去掉type=\"redirectAction的显示结果。&nbsp;<img src=\"http://img.blog.csdn.net/20140319130324546?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHh4ODIzOTUyMzc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p> \n<p><br> </p> \n<p>具体内容，请下载</p> \n<p><span style=\"font-size:18px; color:#ff0000\">http://download.csdn.net/detail/xxx823952375/7065709</span><br> </p> \n<p><span style=\"font-size:18px; color:#ff0000\"><br> </span></p> \n<p><span style=\"font-size:18px; color:#ff0000\"><br> </span></p>',NULL,'xingxing','2014-03-19 16:28:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/21517563','ssh常见问题',2),
	(2,'服务器安装PHP扩展:curl问题解决办法(针对Wampserver2.4-x86)','<p><strong><span style=\"font-size:14px\">本人使用的是<span style=\"color:#ff0000\">Wampserver2.4-x86.exe</span>这个软件来搭建的php环境。因此解决办法仅适用于这种情况下的...................</span></strong></p> \n<p><strong><span style=\"font-size:14px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:14px\">在网上搜集了一些方案，来解决这个问题，发现诸多方案并不适合。</span></strong></p> \n<p><strong><span style=\"font-size:14px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:14px\">类似于下面的方案：</span></strong></p> \n<p><span style=\"font-size:24px; color:#ff0000; background-color:rgb(255,255,255)\">两种办法：<br> 1.如果在php安装路径的ext目录下已经有了php_curl.dll，那么在php.ini中找到extension=php_curl.dll并去掉注释,改成extension_dir=d:\\php\\ext(假设ext路径是d:\\php\\ext)；将php_curl.dll，libeay32.dll， ssleay32.dll， php5ts.dll和php.ini拷贝到system32下，重启apache。<br> 2.确保php的目录下面存在ssleay32.dll和libeay32.dll，在apache的httpd.conf的中添加下边两条：<br> LoadFile \"D:/webserver/php/ssleay32.dll\"&nbsp;<br> LoadFile \"D:/webserver/php/libeay32.dll\"<br> 然后重启一下apache。</span><br> </p> \n<p><br> </p> \n<p><br> </p> \n<p><strong><span style=\"font-size:14px\">这两种方法都不适合我所碰到的问题。以上两种方法都亲自测试过。。</span></strong></p> \n<p><strong><span style=\"font-size:14px\">所碰到的问题就是下图中的红色部分。。。</span></strong></p> \n<p><img src=\"http://img.blog.csdn.net/20140416105336937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHh4ODIzOTUyMzc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br> </p> \n<p><strong><span style=\"font-size:14px\">最后找到的解决办法竟然在wamp自身所带的工具上。太坑了吧。。。。。。。。。。。。。</span></strong></p> \n<p>&nbsp; &nbsp; &nbsp;<img src=\"http://img.blog.csdn.net/20140416105412687?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHh4ODIzOTUyMzc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\">&nbsp; &nbsp; &nbsp;&nbsp;</p> \n<p>选择php，会级联出红色箭头上的php extensions</p> \n<p>&nbsp; &nbsp;&nbsp;<img src=\"http://img.blog.csdn.net/20140416105501656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHh4ODIzOTUyMzc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p> \n<p>接着会出现一堆的扩展模块。。。</p> \n<p><img src=\"http://img.blog.csdn.net/20140416105531031?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHh4ODIzOTUyMzc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br> </p> \n<p><strong><span style=\"font-size:14px\">选中红圈中的php_curl即可。</span></strong></p> \n<p><strong><span style=\"font-size:14px\">接着会重启服务。再次安装项目，向导提示如下图。</span></strong></p> \n<p><img src=\"http://img.blog.csdn.net/20140416105617500?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHh4ODIzOTUyMzc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br> </p> \n<p><strong><span style=\"font-size:14px\">终于成功了。。实在是难得啊。。。。。。。。。。。。。</span></strong></p> \n<p><strong><span style=\"font-size:14px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:14px\">之前还碰到了其他的问题。最开始的时候采用的是appserv-win32-2.5.10.exe这个安装套件搭建的php环境，以前一直都是使用它作为php环境搭建的首选。</span></strong></p> \n<p><strong><span style=\"font-size:14px\">在做android端通过api取得它的授权时，一直出错。。。报的错误又是一堆编码。。。</span></strong></p> \n<p><strong><span style=\"font-size:14px\">最后进入php服务器端项目源代码，终于找到错误的原因了，你妹的，这不是逗我玩吗。。。。。。。。。</span></strong></p> \n<p><strong><span style=\"font-size:14px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:14px\"><span style=\"white-space:pre\"></span>if(!function_exists(\'mcrypt_module_open\')){<br> <span style=\"white-space:pre\"></span>$message[\'message\'] = \'服务器错误:缺少加密扩展mcrypt\';<br> <span style=\"white-space:pre\"></span>$message[\'code\'] &nbsp; &nbsp;= \'00000\';<br> <span style=\"white-space:pre\"></span>exit( json_encode( $message ) );<br> <span style=\"white-space:pre\"></span>}<br> </span></strong></p> \n<p><strong><span style=\"font-size:14px\">竟然是缺少加密扩展库。。服务器没有启用此项功能。。。。。。。。。。</span></strong></p> \n<p><strong><span style=\"font-size:14px\">更坑的是网上的一些教程，方案都对启用mcrypt库无效啊。。。。或许是appserv-win32-2.5.10.exe这个套件的原因吧。。。</span></strong></p> \n<p><strong><span style=\"font-size:14px\">真是各种坑，不得不吐槽，程序员太伤不起了。。。。。。。。。。。</span></strong></p> \n<p><strong><span style=\"font-size:14px\"><br> </span></strong></p> \n<p><br> </p> \n<p><br> </p>',NULL,'xingxing','2014-04-16 10:57:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/23825453','php',3),
	(3,'WAMP安装教程','<strong><span style=\"font-size:18px\">WAMP安装好后，mysql教程密码是为空的，那么要如何修改呢？其实很简单，通过几条指令就行了，下面我就一步步来操作。<br> <br> <br> 　　首先，通过WAMP打开mysql控制台。<br> <br> <br> 　　提示输入密码，因为现在是空，所以直接按回车。<br> <br> <br> 　　然后输入“use mysql”，意思是使用mysql这个数据库教程，提示“Database changed”就行。<br> <br> <br> 　　然后输入要修改的密码的sql语句“update user set password=PASSWORD(\'hooray\') where user=\'root\';”，注意，sql语句结尾的分号不能少，提示什么什么OK就行了。<br> <br> <br> 　　最后输入“flush privileges;”，不输入这个的话，修改密码的操作不会生效的。<br> <br> <br> 　　然后输入“quit”退出。<br> <br> <br> 　　另外，很多人说通过php教程myadmin直接修改mysql表里的密码就行，原理上应该是没错，但是我发现修改后mysql整个库都不见了，害的我重装了WAMP，最终还是通过命令行去修改的。<br> <br> <br> <br> <br> 原文出自【比特网】，转载请保留原文链接：http://soft.chinabyte.com/database/466/12132466.shtml</span></strong>',NULL,'xingxing','2014-04-15 21:11:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/23787489','php',3),
	(4,'我的2013---程序员的奋斗历程','<p>&nbsp;&nbsp; 写这篇文章，算是对自己这一年进行一个总结吧，不然会觉得不自在的。</p> \n<p>&nbsp;&nbsp;&nbsp;年初的时候，那时候我还只能算是一个大二的学生，在学校呆了一年半了，但我一直都知道要奋斗，努力，利用好一点一滴的时间来学习，提升自己。正月初6,7开始就呆在家里，练习编程，从学校回到家里的时候带了两本书，和我的笔记本，在这里还是介绍一下书的名字，是李兴华的&lt;&lt;java开发实战经典&gt;&gt;和&lt;&lt;javaweb开发实战经典基础篇&gt;&gt;，这不算是打广告，这两本书都还不错。对我个人自学编程起着很大的作用。在家里一边看视频，一边用editplus敲java程序，用命令行体验最基本的编译，运行过程。在家里学习李兴华的书的时候，已经算是我第三遍学习java了，之前的一些书的内容不全，不够详尽，写起程序来，不好理解，也不能有很好的侧重点，不利于快速入门。特别是我学习jsp，servlet的时候，身边没有好的书，程序出现问题了真是不好解决，也是由于前面的基础不够扎实，在买了javaweb开发实战经典基础篇后感觉到了，很有用，讲的都有针对性。最后才买的java开发实战经典，重温一遍，打牢基础。这算是简单介绍我大二上的学习过程吧。在家里的那段时间很短，只有一个月左右的时间，对于我当初的目标任务而言，感觉时间还是有点紧张的，不够用。我当初的任务是重新复习一遍java基础知识，然后再把大二上学习的jsp，servlet回顾一下，体会mvc分层思想。所以个人觉得任务量还是不少的。不过正月6,7号的时候java基础已经算是基本复习了一遍了，自然还是有侧重点，主要是以面向对象，io，集合框架，jdbc为主，其他的也都大致回顾了一下，如java的其他常用类库,SimpleDateFormat,StringBuffer等一些常用的东西，还有枚举类型，反射，注解，java6的一些新特性。之后的几天就是开始复习jsp,还有jdom,dom4j等一些常用的第三方jar包的使用，jsp的常用内置对象，servlet，filter,不断练习李兴华书中的一些比较有针对性的小案例，如一个简单的用户注册例子，还有session的一些使用地方，filter的使用环境，都算是很好的东西。然后就是体会web开发中的分层思想mvc，jsp做页面展示，servlet负责控制跳转，javaben处理一些简单的业务操作。这就是年初的学习经历了。</p> \n<p>&nbsp;&nbsp; 之后返回学校了，开始新一年的学习，对于学校安排的课程我真是很不满意，有数据结构c++版，计算机组成，工程经济学，软件工程，软件工程导论，很多都还是打酱油的课程，除了计算机组成的老师讲的还好外，其他的都只能算是一般般，我还是按照我自己的学习任务进行着，当初计划大二下和暑假学完三大框架的，一直都想通过做点实际的东西，来锻炼自己，但是一直感觉自己还有太多的东西不会，只能赶着时间，先学完这些东西，再来做实际的东西，现在看来，这完全是不好的，不过对于那时候的我来说，也一直是以打好基础为主，对于struts2这个框架，如果不能够很好的知道他是用来干嘛的，该怎么用，它的大致处理流程，我是不会加快进度学习下一个框架的，还是得一步一步的来，平常白天就正常上课，没课的时候赶紧完成老师的任务，晚上的时间基本上就用来练习编程，，学习的过程中碰到了太多的问题，烦恼，让我很苦恼，比如说，在搭建struts2环境的过程中，有几次本来已经配置好了，也能正常访问，但是等我下一次打开电脑重新部署访问，就会出现错误，404，弄的我都很莫名奇妙的，只好在重头搭建环境，对于有的问题，通过对于还是可以解决的，也能够知道问题所在，但是想这种邪门的问题，我只能呵呵一下，复制一下项目，重头改一遍，慢慢就好了。学了一段时间对struts2也算是有所体会了，知道它是将请求和响应分离，达到分层处理。不过那个时候的认识还是不深，没有做过什么有实际意义的项目，倒是做过一个企业门户网站，不过业务简单，界面也弄的一般，只能算是拿来练手，处理起来一点都不正规，使用框架就发现一个问题，用框架开发，效率真的是很慢，当然很大一部分原因是由于我还不太熟练。之后陆陆续续的学习了hibernate，开始学习的时候觉得很爽，这个框架真的很好很强大，我再也不用写繁琐的jdbc操作代码了。不用每次都要打开一个connection，创建一个statement,然后来执行查询，或者是插入更新操作，不用要自己手动来取数据，rs.getstring(\'\')，关闭连接等一系列繁琐的事。这个框架真的很爽。他通过反射机制，还有一些其他的操作帮助我们处理这些重复的任务。基础掌握好了，对这个框架就了解的比较清楚了。当然了对于他的关联关系，这个地方还真是个烦恼的事。估计还是由于缺乏真实的项目经验吧，对于怎么处理好，怎么映射还需要不断的学习。之后就是spring了，感觉spring做的比较好的就是ioc，和aop，一般情况下我就是使用ioc处理类之间的管理，用aop处理事务。对于spring的理解，就是觉得它在减轻开发者的任务量，竟可能的让其他框架无缝整合到一起。这只是本人的观点，本人的水准有限。大二下半年就做了这些事情，学习上也没有耽误，还参加了程序员考试，最后也还拿到了证书。</p> \n<p>之后就是暑假了，暑假在学校呆了一个月吧，练习编程，当初设想的是利用暑假做几个简单点的项目，来熟悉三大框架的整合使用情况，最后并没有达到理想的目标，暑假的那段时间是在是太热了，就只坚持了一个月，就回家了。在学校里，跟自己的一个好朋友，每天带上电脑自习，一天就7,8个小时的学习时间吧，来练习，积累实际经验，晚上回来就去跑步，锻炼一下身体，之后就打打dota，一起开心一下，在学校的时间里，一共练习了两个小项目，收获并不大，在此期间，又从新回顾了所学的知识，东西是在是太多了，一不小心就忘的差不多了。整体感觉来说，还算是不错的。之后就回家了，在家里把java的swing那块给重温了一遍，之前学习的时候没有侧重学习，还学习了一下php的开发，学了一周吧，算是简单上手了，发现自己这人是在是太浮躁了，什么都学，不好。还是决定安心弄java。</p> \n<p>暑假之后，便是大三了啊，想想就感到压力山大，得继续努力啊，开学第一周做了简单的计算器，然后就将这个程序打包,用exe4j和Inno Setup 5将这个jar包弄成可以安装的exe程序，虽然程序不复杂，但是感觉将其打包成可以安装的还是觉得有点厉害的样子。接下来的时间主要是准备软件设计师考试，还有我在学校申请的一个创新训练项目，在此期间，学到了不少东西，虽然东西目前都还做的不让我满意，但是我学到了不少开发中的经验，对于数据库的设计真的很重要，本人数据库被我重新修改了2,3次，还有hibernate的使用细节真是多，对于如何用好它，我还需要努力研究，总之，在这个阶段，收获良多，也体会到设计好了，其他的编码真的不是太大的问题，当然我学长跟我说的是架构好了，其他的都不难，本人目前还没有体会到。</p> \n<p>以上就是本人这一年来的奋斗过程，在这一年里学到了很多，也越来越不甘只做一个程序员，我想要走的更远。学海无涯，希望能与志同道合的人相互交流共同进步吧，对于明年，目前是希望能够找个实习单位，体验一下，实际工作中是如何开发，做项目的。积累一下经验吧，学习上，在看看linux，andriod。希望明年能做的更好。</p>',NULL,'xingxing','2013-12-29 14:35:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/17653095','感悟',5),
	(5,'时间飞逝——大三感悟','<p><span style=\"white-space:pre\"></span>时间过的很快，一晃我都从大一的新生变成的将要离开学校的程序员，想想就不得不感慨啊，自从选择了计算机这个破专业，每天对着的都是电脑，本来就内向的性格弄的更内向了，记得还是从大二开始，逛逛csdn的，平常碰到问题，一百度，答案大多都来自于csdn，cnblog,iteye，不过那时候还不知道cnblog,iteye是神马东东，说来真是惭愧。在网上也算是见识到了不少强人，知道了我还很渺小，人啊不能坐井观天，需要多逛逛出名点儿的论坛，增加自己的见识，平常逛论坛，都是潜水般的存在，既不灌水，也不骗经验，对那些没太大兴趣，到了现在，觉得自己主要的问题就是性格上的，也想通过一些途径，来改变一下，这样才能较好的适应社会的需求，而且最近也深受一些想法的影响，我应该主动起来，所以我写下了在csdn上的第一篇文章，以前有过想写文章的想法，不过一直都没有落实，出于各种原因吧，当然并不是说本人懒哦，由于本人是程序员，对于文字表达的能力还有待加强，希望看我文章的道友们不要介意，我还需要努力。</p> \n<p><span style=\"white-space:pre\"></span>从这篇文章开始，算是给自己定个小目标吧，我不希望自己大学四年都没有实质性的东西留下，除了一些残破的记忆，印象外，所以写写文章吧，一来算是当作对学过的东西的复习，二来，想通过这种方式跟同道中人一同交流，共同进步吧。</p> \n<p><span style=\"white-space:pre\"></span>本人现在也算不上高手，有很多不足，还希望能多跟大家学习，探讨。</p>',NULL,'xingxing','2013-12-27 18:57:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/17616879','感悟',5),
	(6,'建站体会','<p><span style=\"color:rgb(51,51,51); font-family:微软雅黑; font-size:14px; line-height:22px\">这两天一时心血来潮，就上网学习了一下，如何建站吧，今天在淘宝上买了个6块钱的空间，还送了个3级域名，拿来练手，一直都没有亲自测试过是怎么部署项目到外网上，然后访问，今天终于体会到了，6块钱也不多，算是学到了不少东西，现在给出链接，欢迎大家访问，不过内容不多哦，大家见谅。。网址。。</span><a target=\"_blank\" href=\"http://blogxxx.hk5.qianduzj.net/?p=12\" class=\" c_tx\" style=\"color:rgb(69,105,141); text-decoration:initial; margin:0px; padding:0px; font-family:微软雅黑; font-size:14px; line-height:22px\">http://blogxxx.hk5.qianduzj.net/?p=12</a></p> \n<h2><span style=\"font-weight:normal\">本人弄的比较简单，直接买的空间附带一个3级域名，所以就不用考虑dns绑定什么乱七八糟的事了，然后就是用空间的账号，登录空间后台，进行其他的操作，用ftp工具把wordpress这个开源软件上传到空间中，本人用的是8uftp工具，上传的时候是传的压缩包，之后在空间上进行解压缩，不过我在这出现了问题，花了好长时间才解决，在这里告诫大家出现了问题，最好还是问卖家吧，他们应该很清楚。弄完后就可以在线安装wordpress程序了。一路弄下来，还是挺有成就感的。</span></h2>',NULL,'xingxing','2013-12-27 20:55:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/17619051','杂项',6),
	(7,'android tv 实现全屏画竖线','<p><strong><span style=\"font-size:18px\">自定义view</span></strong></p> \n<p><strong><span style=\"font-size:18px\">采用canvas双缓冲的方式，可以减少绘制的时间，提升性能。</span></strong></p> \n<p><strong><span style=\"font-size:18px\">StaggeredView.java</span></strong></p> \n<p><strong><span style=\"font-size:18px\">源代码如下：</span></strong></p> \n<p></p>\n<pre name=\"code\" class=\"java\">package com.xxx.demo;\n\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.view.View;\nimport android.view.WindowManager;\npublic class StaggeredView extends View {\n    int width;\n    int height;\n    Paint p;\n    Bitmap bitmap = null;\n    Canvas x = null;\n\n    public StaggeredView(Context context) {\n        super(context);\n        WindowManager wm = (WindowManager) getContext().getSystemService(\n                Context.WINDOW_SERVICE);\n        width = wm.getDefaultDisplay().getWidth();\n        height = wm.getDefaultDisplay().getHeight();\n        p = new Paint();\n    }\n\n    private void initMyCanvas() {\n        p.setColor(Color.WHITE);// 设置绿色\n        bitmap = Bitmap.createBitmap(20, 20, Bitmap.Config.ARGB_8888);\n        // Create canvas.\n        x = new Canvas();\n        x.setBitmap(bitmap);\n        p.setStyle(Paint.Style.STROKE);\n        p.setAntiAlias(true);\n        for (int i = 0; i &lt;=20; i++) {\n            changeColor(i, p);\n            x.drawLine(i, 0, i, 20, p);// 画线\n        }\n    }\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        canvas.drawColor(Color.WHITE);\n        // 创建画笔\n        long startTime=System.currentTimeMillis();\n        initMyCanvas();\n        int bitWidth = bitmap.getWidth();\n        int bitHeight = bitmap.getHeight();\n        for (int i = 0; i &lt; height; i += bitHeight) {\n            for (int j = 0; j &lt; width; j += bitWidth) {\n//                changeColor(i,j,p);\n//                canvas.drawPoint(i, j, p);\n                canvas.drawBitmap(bitmap, j, i, p);\n            }\n        }\n        System.out.println(\"时间===\"+(System.currentTimeMillis()-startTime));\n    }\n    /**\n     * 改变画笔的颜色\n     *\n     * @param i\n     * @param p\n     */\n    private void changeColor(int i, Paint p) {\n        switch (i % 2) {\n            case 0:\n                p.setColor(Color.WHITE);\n                break;\n            case 1:\n                p.setColor(Color.BLACK);\n                break;\n        }\n    }\n}\n</pre>\n<p></p> \n<p><span style=\"font-size:18px\"><strong>首先先画出一个小的矩形区域，创建一个canvas画在BitMap上，之后使用系统的canavas复用前面的BitMap,可以提高处理的效率。</strong></span></p> \n<p><br> </p> MainActivity.java \n<p></p>\n<pre name=\"code\" class=\"java\">public class MainActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(new StaggeredView(this));\n    }\n}</pre>\n<strong><span style=\"font-size:18px\">打印的结果如下：<br> &nbsp;I/System.out: 时间===91</span></strong>\n<p></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\">方法二：</span></strong></p> \n<p><strong><span style=\"font-size:18px\">StaggeredView2.java</span></strong></p> \n<p><strong><span style=\"font-size:18px\">采用默认的方式，就是一个循环，画width个竖线。效率还是很低下的。。</span></strong></p> \n<p></p>\n<pre name=\"code\" class=\"java\">public class StaggeredView2 extends View {\n    int width;\n    int height;\n    Paint p;\n    Bitmap bitmap = null;\n    Canvas x = null;\n\n    public StaggeredView2(Context context) {\n        super(context);\n        WindowManager wm = (WindowManager) getContext().getSystemService(\n                Context.WINDOW_SERVICE);\n        width = wm.getDefaultDisplay().getWidth();\n        height = wm.getDefaultDisplay().getHeight();\n        p = new Paint();\n        initMyCanvas();\n    }\n\n    private void initMyCanvas() {\n        p.setColor(Color.WHITE);// 设置绿色\n        bitmap = Bitmap.createBitmap(20, 20, Bitmap.Config.ARGB_8888);\n        // Create canvas.\n        x = new Canvas();\n        x.setBitmap(bitmap);\n        p.setStyle(Paint.Style.STROKE);\n        p.setAntiAlias(true);\n        for (int i = 0; i &lt;= 30; i++) {\n            changeColor(i, p);\n            x.drawLine(i, 0, i, 30, p);// 画线\n        }\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        canvas.drawColor(Color.WHITE);\n        // 创建画笔\n        long startTime=System.currentTimeMillis();\n        for (int i = 0; i &lt; width; i++) {\n            changeColor(i, p);\n            canvas.drawLine(i,0, i, height - 1, p);\n        }\n        System.out.println(\"时间===\"+(System.currentTimeMillis()-startTime));\n    }\n\n    /**\n     * 改变画笔的颜色\n     *\n     * @param i\n     * @param p\n     */\n    private void changeColor(int i, Paint p) {\n        switch (i % 2) {\n            case 0:\n                p.setColor(Color.WHITE);\n                break;\n            case 1:\n                p.setColor(Color.BLACK);\n                break;\n        }\n    }\n}\n</pre>\n<strong><span style=\"font-size:18px\">结果为：</span></strong>\n<p></p> \n<p><strong><span style=\"font-size:18px\">I/System.out: 时间===277</span></strong></p> \n<p><strong><span style=\"font-size:18px\">相对前面的方式而言，效率是很低下的。。。</span></strong></p> \n<p><br> <br> </p> \n<p><br> <br> </p>',NULL,'xingxing','2014-08-10 18:24:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/38471883','android',7),
	(8,'android tv 实现颜色条滚动效果(第二种方式)','<p><span style=\"font-size:18px\"><strong>方法二显得比较笨重，算是蠢方法吧。。</strong></span></p> \n<p><strong><span style=\"font-size:18px\">最开始没有办法的情况下采用的一种方式。</span></strong></p> \n<p><strong><span style=\"font-size:18px\">采用的是</span></strong></p> \n<p><strong><span style=\"font-size:18px\">ColorView2 extends SurfaceView implements SurfaceHolder.Callback, Runnable方式<br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\">代码如下：</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><strong><span style=\"font-size:18px\">ColorView2.java</span></strong><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\"><strong><span style=\"font-size:18px\"></span></strong></span></strong></p>\n<pre code_snippet_id=\"447182\" snippet_file_name=\"blog_20140810_1_6564439\" name=\"code\" class=\"java\">/**\n * 色彩效果view1\n */\npublic class ColorView2 extends SurfaceView implements SurfaceHolder.Callback, Runnable {\n    int width;\n    int height;\n    Paint p;\n    int i = 0;\n    SurfaceHolder mSurfaceHolder = null;\n    int all = 256 * 5;\n    float strokeWidth = 0;\n    int exteraLength = 1;\n\n    public ColorView2(Context context) {\n        super(context);\n        WindowManager wm = (WindowManager) getContext().getSystemService(\n                Context.WINDOW_SERVICE);\n        width = wm.getDefaultDisplay().getWidth();\n        height = wm.getDefaultDisplay().getHeight();\n        System.out.println(\"width==\" + width);\n        System.out.println(\"height==\" + height);\n        p = new Paint();\n        if (all &gt;= width) {\n        } else {\n            exteraLength = (int) Math.ceil(1.0 * all / (width - all));\n        }\n        mSurfaceHolder = this.getHolder();\n        mSurfaceHolder.addCallback(this);\n        this.setFocusable(true);\n        this.setKeepScreenOn(true);\n        i = 0;\n    }\n\n    public ColorView2(Context context, AttributeSet attributeSet) {\n        super(context, attributeSet);\n        WindowManager wm = (WindowManager) getContext().getSystemService(\n                Context.WINDOW_SERVICE);\n        width = wm.getDefaultDisplay().getWidth();\n        height = wm.getDefaultDisplay().getHeight();\n        System.out.println(\"width==\" + width);\n        System.out.println(\"height==\" + height);\n        p = new Paint();\n        if (all &gt;= width) {\n        } else {\n            exteraLength = (int) Math.ceil(1.0 * all / (width - all));\n        }\n        mSurfaceHolder = this.getHolder();\n        mSurfaceHolder.addCallback(this);\n        this.setFocusable(true);\n        this.setKeepScreenOn(true);\n        i = 0;\n    }\n\n    //动态画图\n    void complexdraw(int current) {\n        Canvas canvas = mSurfaceHolder\n                .lockCanvas(new Rect(current, 0, current + exteraLength, height));// 关键:获取画布    new Rect(current, 0, current+exteraLength,height)\n        Log.i(\"Canvas:X:\", \"complexdraw\");\n        if (mSurfaceHolder == null || canvas == null) {\n            return;\n        }\n        //处理不同的分辨率，造成画图的差异性\n        if (exteraLength != 1) {\n            if (i % exteraLength == exteraLength - 1) {\n                System.out.println(\"exteraLength==\" + exteraLength);\n                System.out.println(\"current==\" + current);\n                canvas.drawLine(current + current / exteraLength, 0, current + current / exteraLength, height, p);\n                canvas.drawLine(current + current / exteraLength + 1, 0, current + current / exteraLength + 1, height, p);\n            } else {\n                System.out.println(\"exteraLength==1---------&gt;\" + exteraLength);\n                System.out.println(\"current==\" + current);\n                canvas.drawLine(current + current / exteraLength, 0, current + current / exteraLength, height, p);\n            }\n        } else {\n            canvas.drawLine(current, 0, current, height, p);\n        }\n        mSurfaceHolder.unlockCanvasAndPost(canvas);\n    }\n\n    @Override\n    public void surfaceCreated(SurfaceHolder surfaceHolder) {\n        new Thread(this).start();\n    }\n\n    @Override\n    public void surfaceChanged(SurfaceHolder surfaceHolder, int i, int i2, int i3) {\n\n    }\n\n    @Override\n    public void surfaceDestroyed(SurfaceHolder surfaceHolder) {\n        i = all;//屏幕宽度的最大值\n    }\n\n    @Override\n    public void run() {\n// 创建画笔\n//		红（R：255 G：0 B：0）\n//		橙（R：255 G：156 B：0）\n//		黄（R：255 G：255 B：0）\n//		绿（R：0 G：255 B：0）\n//		青（R： G：255 B：255）\n//		蓝（R：0 G：0 B：255）\n//		紫（R：255 G： B：255）\n        System.out.println(\"canvas\");\n        int all = 256 * 5;\n        float strokeWidth = (float) (width * 1.0 / all);\n        System.out.println(\"strokeWidth==\" + strokeWidth);\n        Log.i(\"Canvas:X:\", \"complexdraw\");\n        while (i &lt; all) {\n            if (i &lt;= 255) {\n                p.setColor(Color.rgb(255, i, 0));\n            } else if (i &gt;= 256 &amp;&amp; i &lt;= 511) {\n                p.setColor(Color.rgb(511 - i, 255, 0));\n            } else if (i &gt;= 512 &amp;&amp; i &lt;= 767) {\n                p.setColor(Color.rgb(0, 255, i - 512));\n            } else if (i &gt;= 768 &amp;&amp; i &lt;= 1023) {\n                p.setColor(Color.rgb(0, 1023 - i, 255));\n            } else if (i &gt;= 1024 &amp;&amp; i &lt;= 1279) {\n                p.setColor(Color.rgb(i - 1024, 0, 255));\n            }\n            complexdraw(i);\n            i++;\n        }\n    }\n}</pre>\n<br> MainActvity.java\n<p></p> \n<p><strong><span style=\"font-size:18px\"><strong><span style=\"font-size:18px\"></span></strong></span></strong></p>\n<pre code_snippet_id=\"447182\" snippet_file_name=\"blog_20140810_2_3118876\" name=\"code\" class=\"java\">public class MainActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(R.layout.activity_color2);\n    }\n}</pre>\n<p></p> \n<p><strong><span style=\"font-size:18px\"><strong><span style=\"font-size:18px\">activity_color2.xml</span></strong></span></strong></p> \n<p><strong><span style=\"font-size:18px\"><strong><span style=\"font-size:18px\"></span></strong></span></strong></p>\n<pre code_snippet_id=\"447182\" snippet_file_name=\"blog_20140810_3_8800477\" name=\"code\" class=\"html\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n\n&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n              android:orientation=\"vertical\"\n              android:layout_width=\"fill_parent\"\n              android:layout_height=\"fill_parent\"&gt;\n    &lt;com.xxx.demo.ColorView2\n            android:id=\"@+id/colorView\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"fill_parent\"\n            /&gt;\n&lt;/LinearLayout&gt;</pre>\n<br> \n<br> \n<p></p> \n<p><br> </p>',NULL,'xingxing','2014-08-10 17:20:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/38471437','android',7),
	(9,'android tv 实现颜色条滚动效果','<p><span style=\"font-size:18px\"><strong>直接贴代码：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>ColorView.java</strong></span></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>\n<pre name=\"code\" class=\"java\">package com.xxx.demo;\n\nimport android.content.Context;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.View;\nimport android.view.WindowManager;\n/**\n * 色彩效果view1\n */\npublic class ColorView extends View {\n    int width;\n    int height;\n    Paint p;\n    int i = 0;\n    int all = 256 * 5;//颜色值变化\n    int exteraLength = 1;\n    Context context = null;\n    int j = 0;\n    int mLength = 0;//每次重绘时j的增量值\n\n    public ColorView(Context context) {\n        super(context);\n        this.context = context;\n        WindowManager wm = (WindowManager) getContext().getSystemService(\n                Context.WINDOW_SERVICE);\n        width = wm.getDefaultDisplay().getWidth();\n        height = wm.getDefaultDisplay().getHeight();\n        //判断是否是标准的高度\n        System.out.println(\"width==\" + width);\n        System.out.println(\"height==\" + height);\n        p = new Paint();\n        if (all &gt;= width) {\n            mLength = 80;\n        } else {\n            mLength = 30;\n            exteraLength = (int) Math.ceil(1.0 * all / (width - all));\n        }\n        this.setFocusable(true);\n        this.setKeepScreenOn(true);\n        i = 0;\n    }\n    public ColorView(Context context, AttributeSet attributeSet) {\n        super(context, attributeSet);\n        this.context = context;\n        WindowManager wm = (WindowManager) getContext().getSystemService(\n                Context.WINDOW_SERVICE);\n        width = wm.getDefaultDisplay().getWidth();\n        height = wm.getDefaultDisplay().getHeight();\n        System.out.println(\"width==\" + width);\n        System.out.println(\"height==\" + height);\n        p = new Paint();\n        p.setAntiAlias(true);\n        p.setStyle(Paint.Style.FILL);\n        if (all &gt;= width) {\n            mLength = 80;\n        } else {\n            mLength = 30;\n            exteraLength = (int) Math.ceil(1.0 * all / (width - all));\n        }\n        this.setFocusable(true);\n        this.setKeepScreenOn(true);\n        i = 0;\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        if (j &gt; all) {\n            //结束的情况。还是需要绘制的，不然界面会变黑\n            myDraw(canvas);\n            System.out.println(\"end\");\n            return;\n        }\n        myDraw(canvas);\n        j+=mLength;//改变j的值\n        invalidate();//onDraw后，重新绘制view,主观上产生动画效果\n    }\n\n\n    public void myDraw(Canvas canvas) {\n// 创建画笔\n//		红（R：255 G：0 B：0）\n//		橙（R：255 G：156 B：0）\n//		黄（R：255 G：255 B：0）\n//		绿（R：0 G：255 B：0）\n//		青（R： G：255 B：255）\n//		蓝（R：0 G：0 B：255）\n//		紫（R：255 G： B：255）\n        System.out.println(\"canvas\");\n        Log.i(\"Canvas:X:\", \"complexdraw\");\n        i = 0;\n        while (i &lt;= j) {\n            if (i &lt;= 255) {\n                p.setColor(Color.rgb(255, i, 0));\n            } else if (i &gt;= 256 &amp;&amp; i &lt;= 511) {\n                p.setColor(Color.rgb(511 - i, 255, 0));\n            } else if (i &gt;= 512 &amp;&amp; i &lt;= 767) {\n                p.setColor(Color.rgb(0, 255, i - 512));\n            } else if (i &gt;= 768 &amp;&amp; i &lt;= 1023) {\n                p.setColor(Color.rgb(0, 1023 - i, 255));\n            } else if (i &gt;= 1024 &amp;&amp; i &lt;= 1279) {\n                p.setColor(Color.rgb(i - 1024, 0, 255));\n            }\n            //处理不同的分辨率，造成画图的差异性，均分颜色值，屏幕宽度1280，颜色值的范围也是1280刚刚好，如果是小米电视的，屏幕宽度为1920,多出来的，需要均分，下面便是处理方式\n            if (exteraLength != 1) {\n                if (i % exteraLength == exteraLength - 1) {\n                    System.out.println(\"exteraLength==\" + exteraLength);\n                    System.out.println(\"current==\" + i);\n                    canvas.drawLine(i + i / exteraLength, 0, i + i / exteraLength, height, p);//画线\n                    canvas.drawLine(i + i / exteraLength + 1, 0, i + i / exteraLength + 1, height, p);\n                } else {\n                    System.out.println(\"exteraLength==1---------&gt;\" + exteraLength);\n                    System.out.println(\"current==\" + i);\n                    canvas.drawLine(i + i / exteraLength, 0, i + i / exteraLength, height, p);\n                }\n            } else {\n                canvas.drawLine(i, 0, i, height, p);\n            }\n            i++;\n        }\n    }\n}</pre>\n<br> MainActivity.java\n<p></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>\n<pre name=\"code\" class=\"java\">public class MainActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(R.layout.activity_color);\n    }\n}</pre>\n<br> activity_color.xml\n<p></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>\n<pre name=\"code\" class=\"html\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n\n&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n              android:orientation=\"vertical\"\n              android:layout_width=\"fill_parent\"\n              android:layout_height=\"fill_parent\"&gt;\n    &lt;com.xxx.demo.ColorView\n            android:id=\"@+id/colorView\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"fill_parent\"\n            /&gt;\n&lt;/LinearLayout&gt;</pre>\n<br> 在自定义view中的onDraw（）方法中，调用invalidate（）方法，可以实现类似于小球移动的效果。。\n<p></p>',NULL,'xingxing','2014-08-10 17:04:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/38471303','android',7),
	(10,'android studio 报编码 GBK 的不可映射字符问题','<p><strong><span style=\"font-size:18px\">解决办法：在build.gradle文件中添加：</span></strong></p> \n<p><strong><span style=\"font-size:18px\">buildscript {<br> &nbsp; &nbsp; repositories {<br> &nbsp; &nbsp; &nbsp; &nbsp; maven { url \'http://repo1.maven.org/maven2\' }<br> &nbsp; &nbsp; }<br> &nbsp; &nbsp; dependencies {<br> &nbsp; &nbsp; &nbsp; &nbsp; classpath \'com.android.tools.build:gradle:0.4\'<br> &nbsp; &nbsp; }<br> }<br> apply plugin: \'android\'<br> <br> <br> dependencies {<br> &nbsp; &nbsp; compile files(\'libs/android-support-v4.jar\')<br> &nbsp; &nbsp; compile files(\'libs/umeng-analytics-v5.2.4.jar\')<br> }<br> <br> <br> android {<br> &nbsp; &nbsp; compileSdkVersion 17<br> &nbsp; &nbsp; buildToolsVersion \"17.0.0\"<br> <br> <br> &nbsp; &nbsp; defaultConfig {<br> &nbsp; &nbsp; &nbsp; &nbsp; minSdkVersion 7<br> &nbsp; &nbsp; &nbsp; &nbsp; targetSdkVersion 16<br> &nbsp; &nbsp; }<br> &nbsp; &nbsp; signingConfigs {<br> &nbsp; &nbsp; &nbsp; &nbsp; myConfig {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //...<br> &nbsp; &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; }<br> &nbsp; &nbsp; buildTypes {<br> &nbsp; &nbsp; &nbsp; &nbsp; release {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; signingConfig signingConfigs.myConfig<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; runProguard true<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proguardFile \'proguard-project.txt\'<br> &nbsp; &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; }<br> }<br> <span style=\"color:#ff0000\">tasks.withType(Compile) {<br> &nbsp; &nbsp; options.encoding = \"UTF-8\"<br> }</span><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\">加上红色部分的代码就可以解决编码问题</span></strong></p> \n<p><br> </p> \n<p><br> </p>',NULL,'xingxing','2014-07-24 14:05:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/38083631','android',7),
	(11,'自定义view中在指定的矩形区域中放入一张图片','<p><strong><span style=\"font-size:18px\">如何在自定义view中，在指定的矩形区域中放入一张图片，让其刚好填充这个矩形区域，办法只能是对图片进行放大或者是缩小。</span></strong></p> \n<p><strong><span style=\"font-size:18px\"></span></strong></p>\n<pre name=\"code\" class=\"java\">Bitmap bitmap = BitmapFactory.decodeResource(getContext().getResources(), R.drawable.wenzi);//根据原来///的资源，得到bitmap\n        int bmpWidth = bitmap.getWidth();\n        int bmpHeight = bitmap.getHeight();\n        //矩形区域的大小，为正方形\n        int sideLength = height / 4;//矩形区域的大小，项目中使用的是正方形\n         /* 设置图片缩小比例 */\n        double scale = 0;\n//        //图片小于矩形区域,需要放大\n//        if(bmpWidth&lt;=sideLength){\n//        }else{\n//            //图片大于矩形区域，需要缩小\n//        }\n        /* 计算出缩小后的长宽 */\n        /* 产生Resize后的Bitmap对象 */\n        Matrix matrix = new Matrix();\n//       计算缩放率，新尺寸除原始尺寸\n        float scaleWidth = ((float) sideLength) / bmpWidth;\n        float scaleHeight = ((float) sideLength) / bmpHeight;\n        matrix.postScale(scaleWidth, scaleHeight);//设置缩放率，\n        Bitmap resizeBmp = Bitmap.createBitmap(bitmap, 0, 0, bmpWidth, bmpHeight,\n                matrix, true);//根据原图片和缩放大小，生成一张新的图片,这样图片的大小刚好与矩形区域是一致的</pre>\n<br> \n<br> \n<p></p>',NULL,'xingxing','2014-07-23 10:18:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/38059275','android',7),
	(12,'android canvas.drawBitmap的理解','<p><strong><span style=\"font-size:18px\">public void drawBitmap(android.graphics.Bitmap bitmap, float left, float top, android.graphics.Paint paint)</span></strong></p> \n<p><strong><span style=\"font-size:18px\">这个方法left,top指的是bitmap放置的左上方的坐标。是相对于屏幕整体来说的坐标位置。</span></strong></p> \n<p><span style=\"font-size:18px\"><strong>//以下部分转自<a target=\"_blank\" href=\"http://blog.csdn.net/zgf1991/article/details/7315281\">http://blog.csdn.net/zgf1991/article/details/7315281</a></strong></span></p> \n<p><strong><span style=\"font-size:18px\">public static void drawImage(Canvas canvas, Bitmap blt, int x, int y, int w, int h, int bx, int by) &nbsp;<br> &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //x,y表示绘画的起点， &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; Rect src = new Rect();// 图片 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; Rect dst = new Rect();// 屏幕 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; //src 这个是表示绘画图片的大小 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; src.left = bx; &nbsp; //0,0 &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; src.top = by; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; src.right = bx + w;// mBitDestTop.getWidth();,这个是桌面图的宽度， &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; src.bottom = by + h;//mBitDestTop.getHeight()/2;// 这个是桌面图的高度的一半 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; // 下面的 dst 是表示 绘画这个图片的位置 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; dst.left = x; &nbsp; //miDTX,//这个是可以改变的，也就是绘图的起点X位置 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; dst.top = y; &nbsp; &nbsp;//mBitQQ.getHeight();//这个是QQ图片的高度。 也就相当于 桌面图片绘画起点的Y坐标 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; dst.right = x + w; &nbsp;//miDTX + mBitDestTop.getWidth();// 表示需绘画的图片的右上角 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; dst.bottom = y + h; // mBitQQ.getHeight() + mBitDestTop.getHeight();//表示需绘画的图片的右下角 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; canvas.drawBitmap(blt, src, dst, null);//这个方法 &nbsp;第一个参数是图片，第二个参数是 绘画该图片需显示多少。也就是说你想绘画该图片的某一些地方，而不是全部图片，第三个参数表示该图片绘画的位置 &nbsp;<br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"font-size:18px\"><strong>&nbsp;canvas.drawBitmap(blt, src, dst, null);</strong></span><br> </span></strong></p> \n<p><span style=\"font-weight:bold\"><span style=\"font-size:18px\"><span style=\"font-size:18px\"><strong>一般情况下来说，src这个矩形区域可以设置为(0,0,bmp.getWidth(),bmp.getHeight());一般就这样设置就可以了，当初在项目中设置的src,dst都是完全一样的，导致四个<span style=\"font-size:18px\"><strong>drawBitmap只显示了一个，根据上文的理解，就明白了。</strong></span></strong></span></span></span></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p>',NULL,'xingxing','2014-07-23 10:03:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/38058659','android',7),
	(13,'Android命令生成编译出build.xml文件','<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> <br> </p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> 今天把安装的<strong>android开发环境打开。</strong>弄了测试项目，但没发现build.xml。找了下资料。弄了下，过程如下：</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> <img alt=\"\" src=\"http://www.pms.cc/pic/201308/52071daa4fzpsfhdf5plja2e7fatp2mkakhh.png\" style=\"border:0px; max-width:100%\"><br> <br> 输入:&nbsp;<strong>android.bat list target</strong>&nbsp; 来查询我们现有的版本list有哪些.<br> <img alt=\"\" src=\"http://www.pms.cc/pic/201308/52071db322gt5eyl65cfpazpyhsjn5a33840.png\" style=\"border:0px; max-width:100%\"><br> <br> <br> 记住这个ID号码,下的代码面会用到.<br> <span class=\"edui-filter-decoration-none\">输入:&nbsp;<strong>android update project -n ButtonDemo -t 1 -p E:workspacendroidButtonDemo</strong><br> </span><br> <strong>-n&nbsp;</strong>对应的是项目名称<br> <strong>-t&nbsp;</strong>就是我们之前查询的SDK版本对应的ID,大家根据自己的项目版本做出选择即可,我这个是android-8 所以用ID 1 .<br> <strong>-p</strong>就是生成的路径<br> 成功后显示:<br> <img alt=\"\" src=\"http://www.pms.cc/pic/201308/52071db80ecv0bh3trzklsmotxzrj0ywedhk.png\" style=\"border:0px; max-width:100%\"><br> 好了以下是生成的build.xml代码段:<br> &nbsp;</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;<br> &lt;project name=\"ZpTest\" default=\"help\"&gt;</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp; &lt;!-- The local.properties file is created and updated by the \'android\' tool.<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; It contains the path to the SDK. It should *NOT* be checked into<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Version Control Systems. --&gt;<br> &nbsp;&nbsp;&nbsp; &lt;property file=\"local.properties\" /&gt;</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp; &lt;!-- The ant.properties file can be created by you. It is only edited by the<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \'android\' tool to add properties to it.<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This is the place to change some Ant specific build properties.<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Here are some properties you may want to change/update:来源 www.pms.cc</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; source.dir<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The name of the source directory. Default is \'src\'.<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out.dir<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The name of the output directory. Default is \'bin\'.</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For other overridable properties, look at the beginning of the rules<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; files in the SDK, at tools/ant/build.xml</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Properties related to the SDK location or the project target should<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; be updated using the \'android\' tool with the \'update\' action.</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This file is an integral part of the build system for your<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; application and should be checked into Version Control Systems.</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --&gt;<br> &nbsp;&nbsp;&nbsp; &lt;property file=\"ant.properties\" /&gt;</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp; &lt;!-- if sdk.dir was not set from one of the property file, then<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get it from the ANDROID_HOME env var.<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This must be done before we load project.properties since<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the proguard config can use sdk.dir --&gt;<br> &nbsp;&nbsp;&nbsp; &lt;property environment=\"env\" /&gt;<br> &nbsp;&nbsp;&nbsp; &lt;condition property=\"sdk.dir\" value=\"${env.ANDROID_HOME}\"&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;isset property=\"env.ANDROID_HOME\" /&gt;<br> &nbsp;&nbsp;&nbsp; &lt;/condition&gt;</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp; &lt;!-- The project.properties file is created and updated by the \'android\'<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tool, as well as ADT.</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This contains project specific properties such as project target, and library<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dependencies. Lower level build properties are stored in ant.properties<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (or in .classpath for Eclipse projects).</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This file is an integral part of the build system for your<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; application and should be checked into Version Control Systems. --&gt;<br> &nbsp;&nbsp;&nbsp; &lt;loadproperties srcFile=\"project.properties\" /&gt;</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp; &lt;!-- quick check on sdk.dir --&gt;<br> &nbsp;&nbsp;&nbsp; &lt;fail<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; message=\"sdk.dir is missing. Make sure to generate local.properties using \'android update project\' or to inject it through the ANDROID_HOME environment variable.\"<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unless=\"sdk.dir\"<br> &nbsp;&nbsp;&nbsp; /&gt;</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp; &lt;!--<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Import per project custom build rules if present at the root of the project.<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This is the place to put custom intermediary targets such as:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -pre-build<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -pre-compile<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -post-compile (This is typically used for code obfuscation.<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Compiled code location: ${out.classes.absolute.dir}来源 www.pms.cc<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If this is not done in place, override ${out.dex.input.absolute.dir})<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -post-package<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -post-build<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -pre-clean<br> &nbsp;&nbsp;&nbsp; --&gt;<br> &nbsp;&nbsp;&nbsp; &lt;import file=\"custom_rules.xml\" optional=\"true\" /&gt;</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp; &lt;!-- Import the actual build file.</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; To customize existing targets, there are two options:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Customize only one target:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - copy/paste the target into this file, *before* the<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;import&gt; task.<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - customize it to your needs.<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Customize the whole content of build.xml<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - copy/paste the content of the rules files (minus the top node)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; into this file, replacing the &lt;import&gt; task.<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - customize to your needs.</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ***********************<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ****** IMPORTANT ******<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ***********************<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; In all cases you must update the value of version-tag below to read \'custom\' instead of an integer,<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in order to avoid having your file be overridden by tools such as \"android update project\"<br> &nbsp;&nbsp;&nbsp; --&gt;<br> &nbsp;&nbsp;&nbsp; &lt;!-- version-tag: 1 --&gt;<br> &nbsp;&nbsp;&nbsp; &lt;import file=\"${sdk.dir}/tools/ant/build.xml\" /&gt;</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &lt;/project&gt;</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> 本文转载自：<a target=\"_blank\" href=\"http://www.pms.cc/android/dev/201308/Android_build_xml.html\">http://www.pms.cc/android/dev/201308/Android_build_xml.html</a></p>',NULL,'xingxing','2014-03-28 08:52:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/22372957','android',7),
	(14,'算法——基础篇——二分查找','<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp;二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表，且插入删除困难。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。</span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\">&nbsp; &nbsp; 首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</span></strong></span></p> \n<p><strong><span style=\"font-size:18px\">由于此算法理解起来简单，就不多说什么了。。</span></strong></p> \n<p><strong><span style=\"font-size:18px\">递归实现：</span></strong></p> \n<p><strong><span style=\"font-size:18px\"></span></strong></p>\n<pre code_snippet_id=\"359052\" snippet_file_name=\"blog_20140522_1_1903692\" name=\"code\" class=\"java\">package hello.ant;\n\npublic class AlogBinarySearch2 {\n	public static void main(String[] args) {\n		int array[]={1,2,3,5,6,8,9};\n		int pos=binarySearch(array,0,array.length-1,8);\n		System.out.println(pos);\n	}\n	static int binarySearch(int[] array,int begin,int end, int x) {\n		int mid=0;\n		if(begin&gt;end){\n			return -1;\n		}else {\n			mid=(begin+end)/2;\n			System.out.println(\"mid==\"+mid);\n			if(x==array[mid]){\n				return mid;\n			}else if(x&lt;array[mid]) {\n				end=mid-1;\n			}else {\n				begin=mid+1;\n			}\n			return binarySearch(array, begin, end, x);\n		}\n	}\n	\n}</pre>\n<br> 结果：\n<p></p> \n<p><strong><span style=\"font-size:18px\">mid==3<br> mid==5<br> 5<br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\">非递归实现：</span></strong></p> \n<p><strong><span style=\"font-size:18px\"></span></strong></p>\n<pre code_snippet_id=\"359052\" snippet_file_name=\"blog_20140522_2_2525356\" name=\"code\" class=\"java\">package hello.ant;\n\npublic class AlogBinarySearch {\n	public static void main(String[] args) {\n		int array[]={1,2,3,5,6,8,9};\n		int pos=binarySearch(array,7);\n		System.out.println(pos);\n	}\n	static int binarySearch(int[] array, int x) {\n		int begin=0,end=array.length-1;\n		int mid=0;\n		while(begin&lt;=end){\n			mid=(begin+end)/2;\n			System.out.println(\"mid==\"+mid);\n			if(x==array[mid]){\n				return mid;\n			}else if(x&lt;array[mid]) {\n				end=mid-1;\n			}else {\n				begin=mid+1;\n			}\n		}\n		System.out.println(mid);\n		return -1;\n	}\n	\n}</pre>\n<br> mid==3\n<br> mid==5\n<br> mid==4\n<br> 4\n<br> -1\n<br> \n<p></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p>',NULL,'xingxing','2014-05-22 21:37:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26622407','算法',8),
	(15,'算法——基础篇——快速排序','<p><strong><span style=\"font-size:18px\">快速排序是一个经常使用的算法，由于每次用的时候，都感觉没有理解清楚，特写一篇文章记录一下。</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"font-family:微软雅黑,黑体,Verdana; font-size:24px; line-height:24px\">算法介绍</span><br> </span></strong></p> \n<p><br> </p> \n<p><strong><span style=\"font-size:18px\">快速排序有点类似有冒泡排序，冒泡排序从相邻的两个元素比较，小的在左边，大的在右边，这个算法很容易理解。而快速排序它相当于是在一头一尾两边分别排序比较，比较的对象是当前元素值，和一个选定的key值，主题的思想就是通过跟key值比较，把大于key的值放在右边，小于的放在左边这样就完成了一次排序，接着在对key值左边的序列进行同样的操作，右边也是，最后便能将所有的元素给排好序，由于它每次排序，都会分成左右两部分，左边和右边的相对于key值来说是排好序的，接着只需要对左右两边分别递归一次排序的过程就可以了，它的效率较冒泡排序还是要高很多的，O(nlgn)...</span></strong><br> </p> \n<p><span style=\"font-size:18px\"><strong>详细处理过程：（来自百度百科）</strong></span></p> \n<p><strong><span style=\"font-size:18px\">设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。<br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\">一趟快速排序的算法是：<br> 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；<br> 2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；<br> 3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]赋给A[i]；<br> 4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]赋给A[j]；<br> 5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。<br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\">代码：</span></strong></p> \n<p><strong><span style=\"font-size:18px\"></span></strong></p>\n<pre code_snippet_id=\"356319\" snippet_file_name=\"blog_20140521_1_6501335\" name=\"code\" class=\"java\">package hello.ant;\n\npublic class AlogQuickSort {\n	public static void main(String[] args) {\n		int array[]={4,5,1,2,0,11,3,6};\n//		int array[]={4,5,1,2,0,6};\n		sort(array,0,array.length-1);\n		for(int i=0;i&lt;array.length;i++){\n			System.out.print(array[i]+\" \");\n		}\n	}\n	static void sort(int[] array, int low, int heigh) {\n		int i=low,j=heigh;\n		if(i&gt;j){\n			return;\n		}\n		int key=array[i];\n		while(i&lt;j){\n			while(i&lt;j&amp;&amp;array[j]&gt;=key){\n				j--;\n			}\n			array[i]=array[j];\n			while(i&lt;j&amp;&amp;array[i]&lt;=key){\n				i++;\n			}\n			array[j]=array[i];\n		}\n		array[i]=key;\n		sort(array, low, i-1);\n		sort(array, j+1, heigh);\n	}\n}\n</pre>\n<p></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p> 结果：\n<br> 0 1 2 3 4 5 6 11&nbsp;\n<br> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p>',NULL,'xingxing','2014-05-21 13:06:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26463663','算法',8),
	(16,'算法——动态规划篇——最长公共子序列','<p><strong><span style=\"color:rgb(51,51,51); font-family:微软雅黑,黑体,Verdana; font-size:24px; line-height:24px; text-indent:28px\">问题描述</span><br style=\"color:rgb(51,51,51); font-family:微软雅黑,黑体,Verdana; font-size:24px; line-height:24px; text-indent:28px\"> <br> </strong></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp;最长公共子序列，英文缩写为LCS（Longest Common Subsequence）。其定义是，一个序列 S ，如果分别是两个或多个已知序列的子序列，且是所有符合此条件序列中最长的，则 S 称为已知序列的最长公共子序列。 &nbsp;</span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\">&nbsp; &nbsp; 解决最长公共子序列，一种常用的办法，就是穷举法，组合出所有的情况，但是这样对于长序列的情况来说，是非常不实际。。</span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\">假设现在有两个序列，x[]={\'A\',\'B\',\'C\',\'B\',\'D\',\'A\',\'B\'};y[]={\'B\',\'D\',\'C\',\'A\',\'B\',\'A\'};<br> </span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\">如果采用穷举的方式，会是以下情况</span></strong></span></p> \n<p><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:#333333\">x:</span><span style=\"color:#ff0000\">A</span><span style=\"color:#333333\">,</span><span style=\"color:#6633ff; background-color:rgb(0,204,204)\">B</span><span style=\"color:#333333\">,C,B,D,A,B</span></span></span></span></strong></span></p> \n<p><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:#333333\">y:B,D,C,</span><span style=\"color:#ff0000\">A</span><span style=\"color:#333333\">,<span style=\"background-color:rgb(0,204,204)\">B</span>,A</span></span></span><br> </span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\">A与B比较，一直到A与Y中出现的第一个A遇到事停止（红色部分），然后再从X序列中的B与Y中B开始比较，（绿色部分），接着这样下去，直观上看，执行这一次遍历，就是n*n的代价，要是把所有的可能都遍历一下，代价太大了。。</span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><br> </span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\">只有采用其他的方法了，</span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\">动态规划：</span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\">观察到序列求解过程中，有一定的相似度，比如说，如果我们的序列是X:A,B,C;Y:B,D,C;由于Xc=Yc,所有要往前面的两个元素看，也就是比较X:A,B;Y:B,D，由于Xb!=Yd,那么我们需要判断X:A；Y:B,D的最大序列，以及X:A,B；YB的最大序列，取两者中最大的一个，保留下来，作为<span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-size:18px\">X:A,B;Y:B,D的最大序列值。</span></span></span></span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-size:18px\">分析问题的时候一直要先从整体上来把握，体会他的整体局部的相关性，而不是孤立出来，只是单纯的从元素本身来判断，那样就不好明白问题的规律。。。</span></span></span></span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-size:18px\">最后还是翻看了算法导论，才明白这一点，没有把握住，问题的本质。。</span></span></span></span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-size:18px\">最长子序列的规律：</span></span></span></span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-size:18px\">c[i][j]={</span></span></span></span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>0 &nbsp;,i=0||j=0</span></span></span></span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>c[i-1][j-1]+1 &nbsp;,i,j&gt;0&amp;&amp;xi=yj</span></span></span></span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp; max(c[i-1][j],c[i][j-1]),i,j&gt;0&amp;&amp;xi!=yj</span></span></span></span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-size:18px\">}</span></span></span></span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><br> </span></span></span></span></span></strong></span></p> \n<p><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px; color:#ff0000\"><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\">分析清楚问题真的很重要。。。。把握问题的本质。。。</span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><br> </span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\">代码如下：</span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"></span></span></span></span></span></strong></span></p>\n<pre code_snippet_id=\"356051\" snippet_file_name=\"blog_20140521_1_9059982\" name=\"code\" class=\"java\">package hello.ant;\n//最长公共子序列\npublic class AlogLCS {\n	public static void main(String[] args) {\n		char x[]={\'A\',\'B\',\'C\',\'B\',\'D\',\'A\',\'B\'};\n		char y[]={\'B\',\'D\',\'C\',\'A\',\'B\',\'A\'};\n		\n		int c[][]=new int[x.length+1][y.length+1];\n		//////////////    ^|^               ~~               ~~~\n		/////////////      |               ~ -------            ~~~\n		//////////////     |                ~~                      ~~\n		//////////////     用0表示向上       1向左                           		2表示斜向左上\n		int flag[][]=new int[x.length+1][y.length+1];//用来控制打印的方向\n		\n		//初始化\n		for(int i=0;i&lt;y.length+1;i++){\n			c[0][i]=0;\n		}\n		for(int i=0;i&lt;x.length+1;i++){\n			c[i][0]=0;\n		}\n		for(int i=1;i&lt;x.length+1;i++){\n			for(int j=1;j&lt;y.length+1;j++){\n				if(x[i-1]==y[j-1]){\n					c[i][j]=c[i-1][j-1]+1;\n					flag[i][j]=2;\n				}else {\n					if(c[i-1][j]&gt;=c[i][j-1]){\n						c[i][j]=c[i-1][j];\n						flag[i][j]=0;\n					}else {\n						c[i][j]=c[i][j-1];\n						flag[i][j]=1;\n					}\n				}\n			}\n		}\n		StringBuilder result=new StringBuilder();\n		display(x,flag,x.length,y.length,result);\n		System.out.println(\"\\n*********\");\n		System.out.println(result.reverse().toString());\n	}\n\n	static void display(char[] x, int[][] flag, int i, int j,StringBuilder result) {\n		if(i==0||j==0){\n			return;\n		}\n		if(flag[i][j]==2){\n			System.out.print(x[i-1]+\"  \");\n			result.append(x[i-1]);\n			display(x, flag, i-1, j-1,result);\n		}else if(flag[i][j]==1){\n			display(x, flag, i, j-1,result);\n		}else if(flag[i][j]==0){\n			display(x, flag, i-1, j,result);\n		}\n	}\n}\n</pre>\n<br> 结果如下：\n<p></p> \n<p><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:#333333\">A &nbsp;B &nbsp;C &nbsp;B &nbsp;</span><br> <span style=\"color:#333333\">*********</span><br> <span style=\"color:#ff0000\">BCBA</span><br> </span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><br> </span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\">红色部分才是真正的最长子序列。。。</span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><br> </span></span></span></span></span></strong></span></p>',NULL,'xingxing','2014-05-21 10:29:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26448519','算法',8),
	(17,'算法——动态规划篇——斐波那契数列','<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\">斐波那契数列，又称黄金分割数列，指的是这样一个数列：0、1、1、2、3、5、8、13、21、……在数学上，斐波纳契数列以如下被以递归的方法定义：F0=0，F1=1，Fn=F(n-1)+F(n-2)（n&gt;=2，n∈N*）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从1960年代起出版了《斐波纳契数列》季刊，专门刊载这方面的研究成果。</span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\">以上内容来自百度百科。。</span></strong></span></p> \n<p><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><strong style=\"color:rgb(51,51,51)\">今天主要是想用动态规划的思想求解</strong><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><strong style=\"color:rgb(51,51,51)\">斐波那契数列，用来观察动态规划带来的优势，</strong><span style=\"color:#ff0000\">空间换时间，不重复求解</span></span></span></span></span></p> \n<p><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong>方法一采用的是常规的递归方式求解，会发现，在递归的过程中会有太多的重复性操作，比如说f5=f4+f3=(f3+f2)+(f2+f1)=((f2+f1)+(f1+f0))+((f1+f0+f1)),越到后面，基本上求解的都是重复性的解，采用动态规划，可以避免这一不足，同时还将已往的解保留了下来，提高了程序的效率。</strong></span></span></span></p> \n<p><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong>代码：</strong></span></span></span></p> \n<p><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong></strong></span></span></span></p>\n<pre code_snippet_id=\"354275\" snippet_file_name=\"blog_20140520_1_6800456\" name=\"code\" class=\"java\">package hello.ant;\n//斐波那契数列应该是:0,1,1,2,3,5,8,13,21,34,55,89,144,233,...\n//规律是:f[0]=0,f[1]=1,f[i]=f[i-1]+f[i-2],i&gt;1\n\npublic class AlogFibonacci2 {\n	public static void main(String[] args) {\n		int n=40;\n		long startTime=System.currentTimeMillis();\n		System.out.println(fibonacci(n));\n		System.out.println(\"\\ntime:\"+(System.currentTimeMillis()-startTime));\n	}\n	static int fibonacci(int i){\n		if(i==0){\n			return 0;\n		}else if(i==1){\n			return 1;\n		}else {\n			return fibonacci(i-1)+fibonacci(i-2);\n		}\n	}\n}\n</pre>\n<br> 结果如下：\n<p></p> \n<p><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong>102334155<br> <br> <br> time:1199<br> </strong></span></span></span></p> \n<p><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong>时间花的也比较多。</strong></span></span></span></p> \n<p><strong style=\"line-height:24px; font-family:arial,宋体,sans-serif; font-size:18px; text-indent:28px\">动态规划方式：</strong></p> \n<p><strong style=\"line-height:24px; font-family:arial,宋体,sans-serif; font-size:18px; text-indent:28px\">代码：</strong></p> \n<p><strong style=\"line-height:24px; font-family:arial,宋体,sans-serif; font-size:18px; text-indent:28px\"></strong></p>\n<pre code_snippet_id=\"354275\" snippet_file_name=\"blog_20140520_2_7422120\" name=\"code\" class=\"java\">package hello.ant;\n//斐波那契数列应该是:0,1,1,2,3,5,8,13,21,34,55,89,144,233,...\n//规律是:f[0]=0,f[1]=1,f[i]=f[i-1]+f[i-2],i&gt;1\n\npublic class AlogFibonacci {\n	public static void main(String[] args) {\n		int n=40;\n		long array[]=new long [n+1];\n		array[0]=0;\n		array[1]=1;\n		long startTime=System.currentTimeMillis();\n		for(int i=2;i&lt;n+1;i++){\n			array[i]=array[i-1]+array[i-2];\n		}\n		for(int i=1;i&lt;n+1;i++){\n			System.out.print(array[i]+\"  \");\n		}\n		System.out.println(\"\\ntime:\"+(System.currentTimeMillis()-startTime));\n	}\n}\n</pre>\n<br> 结果如下：\n<p></p> \n<p style=\"text-indent:28px\"><span style=\"font-family:arial,宋体,sans-serif; font-size:18px\"><span style=\"line-height:24px\"><strong>1 &nbsp;1 &nbsp;2 &nbsp;3 &nbsp;5 &nbsp;8 &nbsp;13 &nbsp;21 &nbsp;34 &nbsp;55 &nbsp;89 &nbsp;144 &nbsp;233 &nbsp;377 &nbsp;610 &nbsp;987 &nbsp;1597 &nbsp;2584 &nbsp;4181 &nbsp;6765 &nbsp;10946 &nbsp;17711 &nbsp;28657 &nbsp;46368 &nbsp;75025 &nbsp;121393 &nbsp;196418 &nbsp;317811 &nbsp;514229 &nbsp;832040 &nbsp;1346269 &nbsp;2178309 &nbsp;3524578 &nbsp;5702887 &nbsp;9227465 &nbsp;14930352 &nbsp;24157817 &nbsp;39088169 &nbsp;63245986 &nbsp;102334155 &nbsp;<br> time:1<br> </strong></span></span></p> \n<p style=\"text-indent:28px\"><span style=\"font-family:arial,宋体,sans-serif; font-size:18px\"><span style=\"line-height:24px\"><strong>两者相比较，差距还是很大的啊。。</strong></span></span></p> \n<p style=\"text-indent:28px\"><span style=\"font-family:arial,宋体,sans-serif; font-size:18px\"><span style=\"line-height:24px\"><strong>动态规划<span style=\"color:rgb(255,0,0); font-family:arial,宋体,sans-serif; font-size:18px; line-height:24px; text-indent:28px\">空间换时间，不重复求解，</span><span style=\"font-family:arial,宋体,sans-serif; font-size:18px; line-height:24px; text-indent:28px\">这一特性表现的很突出。。。</span></strong></span></span></p>',NULL,'xingxing','2014-05-20 09:53:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26341385','算法',8),
	(18,'算法——一天一道算法题篇——找只出现一次的两个数','<h2 style=\"font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; line-height:1.1; color:rgb(51,51,51); margin-top:20px; margin-bottom:10px; font-size:30px\"> 找只出现一次的两个数</h2> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"> </p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; line-height:20px\"> <strong><span style=\"font-size:18px\">题目:</span></strong></p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; line-height:20px\"> <strong><span style=\"font-size:18px\">一个整型数组里除了两个数字只出现一次之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</span></strong></p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; line-height:20px\"> <strong><span style=\"font-size:18px\"><br> </span></strong></p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; line-height:20px\"> <strong><span style=\"font-size:18px\">举例说明：</span></strong></p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"> <strong>现在有一个数组：{1,3,4,2,4,3};</strong></p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"> <strong>假设数组元素的规模不是很大，想要找到只出现一次的元素，可以定义一个辅助数组,flag[100];里面存放的是数组元素出现的次数，flag数组的下标表示的是<span style=\"color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\">数组：{1,3,4,2,4,3}里的元素。</span></strong></p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"> <strong><span style=\"color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\">代码如下：</span></strong></p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"> <strong><span style=\"color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"></span></strong></p>\n<pre code_snippet_id=\"353375\" snippet_file_name=\"blog_20140519_1_3080076\" name=\"code\" class=\"java\">package hello.ant;\n\npublic class AlogArrayFind2 {\n	public static void main(String[] args) {\n		int array[]={1,3,4,2,4,3};\n		int flag[]=new int[100];\n		for(int i=0;i&lt;array.length;i++){\n			flag[array[i]]++;\n		}\n		for(int i=0;i&lt;flag.length;i++){\n			if(flag[i]==1){\n				System.out.print(i+\"  \");\n			}\n		}\n	}\n}\n</pre>\n<br> 如果数组元素比较大的话，比如说，{1000,2,2,1000,33,45,}这种方式肯定不好，采用了官方给的提示，利用java中set，用来存放不重复的元素，来解决元素之间相差太大带来的问题：\n<p></p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"> <strong><span style=\"color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\">代码如下：</span></strong></p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"> <strong><span style=\"color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"></span></strong></p>\n<pre code_snippet_id=\"353375\" snippet_file_name=\"blog_20140519_2_6209995\" name=\"code\" class=\"java\">package hello.ant;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n//从数组中查找出个数为1的两个数，\npublic class AlogArrayFind {\n	public static void main(String[] args) {\n		int array[]={1000,2,2,1000,33,45};\n		Set&lt;Integer&gt; set=new HashSet&lt;Integer&gt;();\n		for(int i=0;i&lt;array.length;i++){\n			int x=set.size();\n			set.add(array[i]);\n			if(x==set.size()){\n//				System.out.println(array[i]);\n				set.remove(array[i]);\n			}\n		}\n		System.out.println(set);\n	}\n}\n</pre>\n<br> 结果如下：[33, 45]\n<p></p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"> <strong><span style=\"color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\">最好的一种方法如下：</span></strong></p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"> <strong><span style=\"color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"></span></strong></p> \n<pre class=\"prettyprint prettyprinted\" style=\"font-family:Menlo,Monaco,Consolas,\'Courier New\',monospace; font-size:13px; white-space:pre-wrap; padding:2px; margin-top:0px; margin-bottom:10px; line-height:1.428571429; color:rgb(51,51,51); word-break:break-all; word-wrap:break-word; background-color:rgb(245,245,245); border:1px solid rgb(136,136,136)\"><p style=\"margin-top:0px; margin-bottom:10px\"><span class=\"pun\" style=\"color:rgb(102,102,0)\">异或运算：任何一个数字异或它自己都等于</span><span class=\"lit\" style=\"color:rgb(0,102,102)\">0</span><span class=\"pun\" style=\"color:rgb(102,102,0)\">。</span></p><span class=\"pln\" style=\"color:rgb(0,0,0)\">\n\n</span><p style=\"margin-top:0px; margin-bottom:10px\"><span class=\"pln\" style=\"color:rgb(0,0,0)\">A</span><span class=\"pun\" style=\"color:rgb(102,102,0)\">.我们将数组中所有的数字异或，所得的结果相当于只出现一次的两个数的异或结果。</span><br style=\"\"><span class=\"pln\" style=\"color:rgb(0,0,0)\"> B</span><span class=\"pun\" style=\"color:rgb(102,102,0)\">.接着我们考虑，如果能够将原数组分为两个子数组，而且两个只出现一次的数分别在不同的子数组中。那么再分别对子数组异或，就可以得到这两个数。</span></p><span class=\"pln\" style=\"color:rgb(0,0,0)\">\n\n</span><p style=\"margin-top:0px; margin-bottom:10px\"><span class=\"pun\" style=\"color:rgb(102,102,0)\">现在我们考虑</span><span class=\"pln\" style=\"color:rgb(0,0,0)\">A</span><span class=\"pun\" style=\"color:rgb(102,102,0)\">中的结果，由于出现一次的两个数不同，所以它们异或的结果的二进制表示中至少有一位为</span><span class=\"lit\" style=\"color:rgb(0,102,102)\">1</span><span class=\"pun\" style=\"color:rgb(102,102,0)\">。在结果中找出第一个为</span><span class=\"lit\" style=\"color:rgb(0,102,102)\">1</span><span class=\"pun\" style=\"color:rgb(102,102,0)\">的位置,记为</span><span class=\"pln\" style=\"color:rgb(0,0,0)\">n</span><span class=\"pun\" style=\"color:rgb(102,102,0)\">，就可以区分这两个数，因为这两个数的二进制第</span><span class=\"pln\" style=\"color:rgb(0,0,0)\">n</span><span class=\"pun\" style=\"color:rgb(102,102,0)\">位肯定不同。</span><br style=\"\"><span class=\"pln\" style=\"color:rgb(0,0,0)\"> </span><span class=\"pun\" style=\"color:rgb(102,102,0)\">然后将原数组中的数，按照二进制第</span><span class=\"pln\" style=\"color:rgb(0,0,0)\">n</span><span class=\"pun\" style=\"color:rgb(102,102,0)\">位是否为</span><span class=\"lit\" style=\"color:rgb(0,102,102)\">1</span><span class=\"pun\" style=\"color:rgb(102,102,0)\">可以划分为两个子数组，这样，问题就解决了。</span></p></pre> 代码大部分是借鉴官方的，还是贴出来吧，对于位运算部分，不得不说，是挺巧妙的。 \n<p></p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"> <strong><span style=\"color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"></span></strong></p>\n<pre code_snippet_id=\"353375\" snippet_file_name=\"blog_20140519_3_8368802\" name=\"code\" class=\"java\">package hello.ant;\n/**\n * @author gejing E-mail:gjblmdlm@sina.com\n * @version 创建时间：2014年5月13日 下午8:50:07 类说明 寻找数组中只出现一次的两个数，其他的都出现了两次\n */\npublic class Code010 {\n	public static void main(String[] args) {\n		int data[] = { 1,3,1,12,2,2};\n		findAppearOnce(data);\n	}\n\n	/**\n	 * 找出数组中只出现一次的两个数\n	 * \n	 * @param data\n	 */\n	private static void findAppearOnce(int[] data) {\n		int result = 0;\n		int num1 = 0, num2 = 0;\n		System.out.println(isFirst1(1, 1));\n		// 求出所有数组元素的异或结果\n		for (int i = 0; i &lt; data.length; i++) {\n			result = data[i] ^ result;\n		}\n		// 求出结果二进制第一位为1的索引\n		String binaryResult = Integer.toBinaryString(result);\n		int first1 = binaryResult.indexOf(\"1\");\n		System.out.println(first1);\n		// 按照该索引将数组分为两个子数组\n		for (int i = 0; i &lt; data.length; i++) {\n			if (isFirst1(data[i], first1 + 1)) {// 由于数组索引和需要移的位差一位\n				num1 = data[i] ^ num1;\n			} else {\n				num2 = data[i] ^ num2;\n			}\n		}\n		System.out.println(num1 + \"   \" + num2);\n\n	}\n\n	/**\n	 * 判断第index位是否为1\n	 * \n	 * @param i\n	 * @param index\n	 * @return\n	 */\n	private static boolean isFirst1(int i, int index) {\n		if (((i &gt;&gt; index) &amp; 1) == 1) {\n			return true;\n		} else {\n			return false;\n		}\n	}\n\n}\n</pre>\n<br> 不过我也存在一个疑惑，Integer.toBinaryString(result).indexOf(\"1\")，大部分情况下都为0，而每次i&gt;&gt;index个单位，怎么还能满足要求，由于时间问题，暂时研究到这，记录下来，下次再看。。。\n<p></p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"> <br> </p>',NULL,'xingxing','2014-05-19 17:19:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26256319','算法',8),
	(19,'算法——递归篇——树叶下落问题','<strong><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp;</span></strong> \n<h2 class=\"title content-title\" style=\"margin:0px 0px 10px; padding:0px; font-size:20px; font-family:tahoma,helvetica,\'microsoft yahei\',arial\"> <span style=\"color:#ff0000\">UVa 699<strong><span style=\"font-size:18px\">The Falling Leaves&nbsp;</span></strong></span></h2> \n<strong><span style=\"font-size:18px\">Each year, fall in the North Central region is accompanied by the brilliant colors of the leaves on the trees, followed quickly by the falling leaves accumulating under the trees. If the same thing happened to binary trees, how large would the piles of leaves become?</span></strong>\n<br> \n<br> \n<br> \n<p><strong><span style=\"font-size:18px\">We assume each node in a binary tree \"drops\" a number of leaves equal to the integer value stored in that node. We also assume that these leaves drop vertically to the ground (thankfully, there\'s no wind to blow them around). Finally, we assume that the nodes are positioned horizontally in such a manner that the left and right children of a node are exactly one unit to the left and one unit to the right, respectively, of their parent. Consider the following tree:</span></strong></p> \n<p><strong><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src=\"http://uva.onlinejudge.org/external/6/p699.gif\" alt=\"699&nbsp;<wbr>-&nbsp;<wbr>The&nbsp;<wbr>Falling&nbsp;<wbr>Leaves\" title=\"699&nbsp;<wbr>-&nbsp;<wbr>The&nbsp;<wbr>Falling&nbsp;<wbr>Leaves\" style=\"margin:0px; padding:0px; border:0px; list-style:none; color:rgb(50,62,50); font-family:simsun; font-size:14px; background-color:rgb(220,236,204)\"></span></strong></p> \n<strong><span style=\"font-size:18px\">&nbsp;<br> <br> <br> The nodes containing 5 and 6 have the same horizontal position (with different vertical positions, of course). The node containing 7 is one unit to the left of those containing 5 and 6, and the node containing 3 is one unit to their right. When the \"leaves\" drop from these nodes, three piles are created: the leftmost one contains 7 leaves (from the leftmost node), the next contains 11 (from the nodes containing 5 and 6), and the rightmost pile contains 3. (While it is true that only leaf nodes in a tree would logically have leaves, we ignore that in this problem.)<br> &nbsp;<br> Input&nbsp;<br> The input contains multiple test cases, each describing a single tree. A tree is specified by giving the value in the root node, followed by the description of the left subtree, and then the description of the right subtree. If a subtree is empty, the value -1 is supplied. Thus the tree shown above is specified as 5 7 -1 6 -1 -1 3 -1 -1. Each actual tree node contains a positive, non-zero value. The last test case is followed by a single -1 (which would otherwise represent an empty tree).<br> &nbsp;<br> Output&nbsp;<br> For each test case, display the case number (they are numbered sequentially, starting with 1) on a line by itself. On the next line display the number of \"leaves\" in each pile, from left to right, with a single space separating each value. This display must start in column 1, and will not exceed the width of an 80-character line. Follow the output for each case by a blank line. This format is illustrated in the examples below.<br> &nbsp;<br> Sample Input&nbsp;<br> &nbsp;<br> </span></strong> \n<p><strong><span style=\"font-size:18px\">&nbsp;5 7 -1 6 -1 -1 3 -1 -1</span></strong></p> \n<p><strong><span style=\"font-size:18px\">&nbsp;8 2 9 -1 -1 6 5 -1 -1 12 -1 -1 3 7 -1 -1 -1 -1</span></strong></p> \n<strong><span style=\"font-size:18px\">&nbsp;<br> Sample Output&nbsp;<br> </span></strong> \n<p><strong><span style=\"font-size:18px\">Case 1: 7 11 3&nbsp;</span></strong></p> \n<p><strong><span style=\"font-size:18px\">Case 2: 9 7 21 15</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\">题目的意思是让我们从左到右输出树叶下落的数量</span></strong></p> \n<p><span style=\"font-size:18px\"><strong>举例说明一下：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong><strong><span style=\"font-size:18px\"><span style=\"color:#ff0000\">&nbsp;8 2 9 -1 -1 6 5 -1 -1 12 -1 -1 3 7 -1 -1 -1 -1</span></span></strong><br> </strong></span></p> \n<p><strong><span style=\"font-size:18px\">二叉树结构为：</span></strong></p> \n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img src=\"http://img.blog.csdn.net/20140518163734781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHh4ODIzOTUyMzc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\">&nbsp; &nbsp;&nbsp;<img src=\"http://img.blog.csdn.net/20140518164002875?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHh4ODIzOTUyMzc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>如上图所示，右边的图是修改后的，从垂直方向上看，依次是，9,2+5,8+6+7,3+12，这种结构就是我们想要的答案。</span></strong></p> \n<p><strong><span style=\"font-size:18px\">其实一开始想到的是怎么建立二叉树，然后在进行一系列复杂的处理，说实话，这个题真没有想到有这么巧妙的技巧，直接采用先序遍历的方式，先对头结点做处理.考虑到题目中的意思数组长度最长为80，一开始，我们从下标为40的执行，array[40]=8,然后递归执行左子树，接着是右子树。整体思路是这样，执行左子树的时候，传入的下标-1,判断当前左子树的头结点的值，然后继续递归调用其左右子树。。。</span></strong></p> \n<p><strong><span style=\"font-size:18px\">代码如下：</span></strong></p> \n<p></p>\n<pre code_snippet_id=\"351668\" snippet_file_name=\"blog_20140518_1_2001147\" name=\"code\" class=\"java\">package hello.ant;\n\nimport java.util.Scanner;\n\npublic class AlogLeaves {\n	static Scanner scanner=new Scanner(System.in);\n	public static void main(String[] args) {\n		int array[]=new int[80];\n		findLeaves(array,40);\n		displayArray(array);\n	}\n\n	static void displayArray(int[] array) {\n		for(int i=0;i&lt;array.length;i++){\n			if(array[i]!=0){\n				System.out.print(array[i]+\"  \");\n			}\n		}\n		System.out.println();\n	}\n\n	static void findLeaves(int[] array, int index) {\n		int x=scanner.nextInt();\n		if(x!=-1){\n			array[index]+=x;\n			findLeaves(array, index-1);\n			findLeaves(array, index+1);\n		}\n	}\n}\n</pre>\n<br> \n<strong><span style=\"font-size:18px\">结果：</span></strong>\n<p></p> \n<p><strong><span style=\"font-size:18px\">8 2 9 -1 -1 6 5 -1 -1 12 -1 -1 3 7 -1 -1 -1<br> 9 &nbsp;7 &nbsp;21 &nbsp;15 &nbsp;</span></strong><br> </p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\">5 7 -1 6 -1 -1 3 -1 -1<br> 7 &nbsp;11 &nbsp;3 &nbsp;<br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\">本文参考了这篇文章，<a target=\"_blank\" href=\"http://blog.csdn.net/frankiller/article/details/7765929\">http://blog.csdn.net/frankiller/article/details/7765929</a></span></strong></p> \n<p><strong><span style=\"font-size:18px\">深深体会到，这种技巧真不好把握。。。</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p>',NULL,'xingxing','2014-05-18 17:03:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26155209','算法',8),
	(20,'算法——排列组合篇02','<p><strong><span style=\"font-size:18px\">&nbsp; &nbsp;问题：</span></strong></p> \n<p><strong><span style=\"font-size:18px\">&nbsp; &nbsp;输入两个整数n和m,从数列1,2,3，……n中随意取几个数，使其和等于m。要求将所有的可能组合列出来</span></strong></p> \n<p><strong><span style=\"font-size:18px\">&nbsp; &nbsp;</span></strong></p> \n<p><strong><span style=\"font-size:18px\">&nbsp; &nbsp;考虑一下，该怎么解决。</span></strong></p> \n<p><strong><span style=\"font-size:18px\">&nbsp; &nbsp;举例说明：</span></strong></p> \n<p><strong><span style=\"font-size:18px\">&nbsp; &nbsp;当m=5，n=4时，所有的组合为14,23</span></strong></p> \n<p><strong><span style=\"font-size:18px\">&nbsp; &nbsp;当m=6,n=5时，所有的组合为15,24,123</span></strong></p> \n<p><span style=\"font-size:18px\"><strong>&nbsp; &nbsp; 方法一：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>&nbsp; &nbsp;遍历整个数列，从1开始，一直到n，在遍历的过程中，递归调用本方法，传入当前元素的值并+sum（初始值为0），当sum的值刚好等于m时，就打印遍历的结果。然后返回上次递归过程，继续处理下一步的执行。</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>整体的结构就是一个for(){}循环，再循环的内部，传入参数，继续调用本方法。直到条件满足，便打印。。</strong></span></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>\n<pre code_snippet_id=\"350708\" snippet_file_name=\"blog_20140517_1_9291195\" name=\"code\" class=\"java\">package hello.ant;\n//递归回溯\npublic class Alog_PL_ZH3 {\n	static int m=10,n=10;\n	public static void main(String[] args) {\n		int result[]=new int[n];\n		long startTime=System.currentTimeMillis();\n		findResult(result, 0, 0, 0);\n		long endTime=System.currentTimeMillis();\n		\n		System.out.println(\"****\"+(endTime-startTime)/1000.0);\n	}\n	static void findResult(int result[],int begin,int index,int sum){\n		if(sum&gt;m){\n			return ;\n		}else if(sum==m){\n			for(int i=0;i&lt;index;i++){\n				System.out.print(result[i]);\n			}\n			System.out.println();\n		}else {\n			for(int i=begin;i&lt;n;i++){\n				result[index]=i+1;//i+1表示数列对应的元素值\n				findResult( result, i+1, index+1, sum+i+1);\n			}\n		}\n	}\n}\n</pre>\n<br> 方法二：（参考了他人的思路）\n<p></p> \n<p><span style=\"font-size:18px\"><strong>背包的思想：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>f(m,n)的组合情况，包含n的情况，</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>若将n放入背包中，那么背包的组成就为f(m-n,n-1)+n，这里的n-1,代表着元素的下标，相等于前面背包问题里面所说的物品数量，如果不将n放入背包，背包的组成就为f(m,n-1)，用这种模拟的意思，来解释这种方法是什么思路。。。</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>代码如下：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>\n<pre code_snippet_id=\"350708\" snippet_file_name=\"blog_20140517_2_239695\" name=\"code\" class=\"java\">package hello.ant;\n\nimport java.util.Stack;\n\npublic class Alog_PL_ZH4 {\n	static Stack&lt;Integer&gt; stack=new Stack&lt;Integer&gt;();\n	public static void main(String[] args) {\n		int m=10,n=10;\n		findResult(m,n);\n	}\n\n	static void findResult(int m,int n) {\n		if(m&lt;1||n&lt;1){\n			return;\n		}\n		if(m==n){\n			printStack();\n			System.out.println(n);\n		}\n		stack.add(n);\n		findResult(m-n, n-1);\n		stack.pop();\n		findResult(m, n-1);\n	}\n	static void printStack(){\n		for(Integer x:stack){\n			System.out.print(x+\"  \");\n		}\n	}\n}\n</pre>\n<br> 结果：\n<p></p> \n<p><span style=\"font-size:18px\"><strong>10<br> 9 &nbsp;1<br> 8 &nbsp;2<br> 7 &nbsp;3<br> 7 &nbsp;2 &nbsp;1<br> 6 &nbsp;4<br> 6 &nbsp;3 &nbsp;1<br> 5 &nbsp;4 &nbsp;1<br> 5 &nbsp;3 &nbsp;2<br> 4 &nbsp;3 &nbsp;2 &nbsp;1<br> </strong></span></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>',NULL,'xingxing','2014-05-17 20:59:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26093761','算法',8),
	(21,'算法——动态规划篇——采药问题','<strong><span style=\"font-size:18px\">采药<br> &nbsp; &nbsp; 辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”<br> &nbsp; &nbsp; 如果你是辰辰，你能完成这个任务吗？<br> &nbsp; &nbsp; 输入：第一行有两个整数T（1 &lt;=<br> &nbsp; &nbsp;T &lt;= 1000）和M（1 &lt;=<br> &nbsp; &nbsp;M &lt;= 100），用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行 &nbsp; &nbsp; &nbsp;每行包括两个在1到100之间（包括1和100）的整数，分别表示采摘某株草药的时间和这株草药的价值。<br> &nbsp; &nbsp;输出：只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。<br> &nbsp; &nbsp;如：输入：<br> &nbsp; 70 3<br> &nbsp; 71 100<br> &nbsp; 69 1<br> &nbsp; 1 2<br> &nbsp; 输出：<br> </span></strong> \n<p><strong><span style=\"font-size:18px\">&nbsp; 3</span></strong></p> \n<p><strong><span style=\"font-size:18px\">和上一篇的01背包问题的解决办法一样。</span></strong></p> \n<p><strong><span style=\"font-size:18px\">定义一个数组，array[][],用来存放随时间变化，草药的价值的变化;</span></strong></p> \n<p><strong><span style=\"font-size:18px\">time[]记录不同草药要花的时间，value[]记录不同草药的价值。t为总时间，count为草药的数量</span></strong></p> \n<p><strong><span style=\"font-size:18px\">首先考虑第一株草药，它的花费时间为71，对于这株草药，我们需要循环遍历数组array,根据j的值与71比较，来确定array[1][j]的值，这个很前面是同样的。。</span></strong></p> \n<p><strong><span style=\"font-size:18px\">如果j&gt;71，表示可以采药，此时需要再将array[0][j]的值和array[0][j-71]+第一株草药的价值，取其中大的作为array[0][j]的结果。</span></strong></p> \n<p><strong><span style=\"font-size:18px\">如果j&lt;71，那么array[1][j]=array[0][j];</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p> \n<p><span style=\"font-size:18px\"><strong>代码如下：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>\n<pre code_snippet_id=\"350306\" snippet_file_name=\"blog_20140517_1_2503765\" name=\"code\" class=\"java\">package hello.ant;\n\nimport java.util.Scanner;\n\npublic class AlogCaiYao2 {\n	public static void main(String[] args) {\n		int t=70, count=3;\n		int time[]=null;\n		int value[]=null;\n		int i;\n		Scanner scanner=new Scanner(System.in);\n		t=scanner.nextInt();\n		count=scanner.nextInt();\n		\n		\n		time=new int[count];\n		value=new int[count];\n		for(i=0;i&lt;time.length;i++){\n			time[i]=scanner.nextInt();\n			value[i]=scanner.nextInt();\n//			System.out.println(time[i]+\"  \"+value[i]);\n		}\n		int array[][]=new int[count+1][t+1];\n		\n		//初始化\n		for(i=0;i&lt;t+1;i++){\n			array[0][i]=0;\n		}\n		for(i=0;i&lt;count+1;i++){\n			array[i][0]=0;\n		}\n		for(i=1;i&lt;count+1;i++){\n			for(int j=1;j&lt;t+1;j++){\n				if(j&gt;=time[i-1]){\n					array[i][j]=max(array[i-1][j],array[i-1][j-time[i-1]]+value[i-1]);\n				}else {\n					array[i][j]=array[i-1][j];\n				}\n				System.out.print(array[i][j]+\"  \");\n			}\n			System.out.println();\n		}\n		\n	}\n	static int max(int i, int j) {\n		if(i&gt;=j){\n			return i;\n		}\n		return j;\n	}\n}\n</pre>\n<br> \n<br> \n<p></p> \n<p><strong><span style=\"font-size:18px\">结果</span></strong></p> \n<p><strong><span style=\"font-size:18px\">70 3<br> 71 100<br> 69 1<br> 1 2<br> 0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;<br> 0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;1 &nbsp;1 &nbsp;<br> 2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;3 &nbsp;<br> </span></strong></p>',NULL,'xingxing','2014-05-17 15:56:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26075131','算法',8),
	(22,'算法——动态规划篇——01背包问题','<p><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; line-height:24px\"><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>问题描述：给定n种物品和一背包，物品i的重量是wi，其价值是pi，背包的容量是M，问如何选择装入背包中的物品总价值最大？</span></strong></span></p> \n<p><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; line-height:24px\"><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>比如说，现在有一个背包，容量上限是10，可以放物品的个数为3，即m=10,n=3;</span></strong></span></p> \n<p><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; line-height:24px\"><strong><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp; 物品的容量和价值分别为：</span></strong></span></p> \n<p><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; line-height:24px\"><strong><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp; 3，4</span></strong></span></p> \n<p><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; line-height:24px\"><strong><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp; 4, &nbsp; &nbsp;5</span></strong></span></p> \n<p><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; line-height:24px\"><strong><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp; 5，6</span></strong></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong>&nbsp; &nbsp; &nbsp; &nbsp; 考虑怎么做，可以从这三件物品中选出价值最大的东西来进行组合呢。</strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong>&nbsp; &nbsp; &nbsp; 直观上可以看出，就是后两种组合到一起，问题的关键是如何让计算机知道，来分析这个过程</strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong>&nbsp; &nbsp; &nbsp; 动态规划的思想：空间换时间</strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong><br> </strong></span></span> </p>\n<table border=\"1\" width=\"500\" height=\"400\" cellspacing=\"1\" cellpadding=\"1\"> \n <tbody> \n  <tr> \n   <td>0</td> \n   <td>1</td> \n   <td>2</td> \n   <td>3</td> \n   <td>4</td> \n   <td>5</td> \n   <td>6</td> \n   <td>7</td> \n   <td>8</td> \n   <td>9</td> \n   <td>10</td> \n  </tr> \n  <tr> \n   <td>0</td> \n   <td>0</td> \n   <td>0</td> \n   <td>0</td> \n   <td>0</td> \n   <td>0</td> \n   <td>0</td> \n   <td>0</td> \n   <td>0</td> \n   <td>0</td> \n   <td>0</td> \n  </tr> \n  <tr> \n   <td>0</td> \n   <td>0</td> \n   <td>0</td> \n   <td>4</td> \n   <td>4</td> \n   <td>4</td> \n   <td>4</td> \n   <td>4</td> \n   <td>4</td> \n   <td>4</td> \n   <td>4</td> \n  </tr> \n  <tr> \n   <td>0</td> \n   <td>0</td> \n   <td>0</td> \n   <td>4</td> \n   <td>5</td> \n   <td>5</td> \n   <td>5</td> \n   <td>9</td> \n   <td>9</td> \n   <td>9</td> \n   <td>9</td> \n  </tr> \n  <tr> \n   <td>0</td> \n   <td>0</td> \n   <td>0</td> \n   <td>4</td> \n   <td>5</td> \n   <td>6</td> \n   <td>6</td> \n   <td>9</td> \n   <td>10</td> \n   <td>11</td> \n   <td>11</td> \n  </tr> \n </tbody> \n</table> 观察上面的表\n<p></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong>这也是一个二维数组total[4][11];</strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong>扩大了数组的范围，用来填充下标为0的情况。。</strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong><br> </strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong>分析：</strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong>我们考虑从三个物品中任选一个物品开始讨论，假设按顺序放，开始情况为total[1][1];表示在容量为1的情况下放1个物品，怎么放呢，由于第一物品的容量为3&gt;1，无法放进去，所以total[1][1]的值应该沿着在容量为1放0个物品的情况下的值过来，即<span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\">total[1][1]=total[0][1]=0；</span></strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\">同理<span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\">total[1][2]=0，</span></span></strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong>那么total[1][3]呢，total[1][3]的容量为3，第一个物品对应的容量也刚好为3，所以理论上是可以将物品1放到背包里面，但是，还需要考虑的是，万一total[0][3]的价值比物品1的价值大呢，（这个地方，<span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\">total[0][3]=0，只是用来说明有这种情况</span>），</strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong>我们换一种情况来说明；</strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\">total[3][6]，物品3的容量为5，小于6，可以将物品3放入到背包中，该不该放入呢，我们需要知道total[2][6]的值，为5。如果将物品3放入的话，那么容量只剩下6-5=1的容量了，原来是要放入2件物品的，即是total[2][1],有前面的表知道它为0。总的来说就是要判断total[2][6],跟total[2][1]+物品3的价值，他们两者中的大的一个，作为<span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\">total[3][6]的值。</span></span><br> </strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\"><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\">大致的思路就是这样的，具体还需要自己体会。。。</span></span></strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\"><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\">代码如下：</span></span></strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\"><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\"></span></span></strong></span></span></p> \n<pre code_snippet_id=\"350222\" snippet_file_name=\"blog_20140517_1_532582\" name=\"code\" class=\"java\">package hello.ant;\n\npublic class AlogBeiBao {\n	//动态规划\n	public static void main(String[] args) {\n		int m=10,count=3;\n		int capacity[]={3,4,5};\n		int value[]={4,5,6};\n		int total[][]=new int[count+1][m+1];\n		int i;\n		//初始化\n		for(i=0;i&lt;m+1;i++){\n			total[0][i]=0;\n		}\n		for(i=0;i&lt;count+1;i++){\n			total[i][0]=0;\n		}\n		for(i=1;i&lt;count+1;i++){\n			for(int j=1;j&lt;m+1;j++){\n				if(j&gt;=capacity[i-1]){\n					total[i][j]=max(total[i-1][j],total[i-1][j-capacity[i-1]]+value[i-1]);\n				}else {\n					total[i][j]=total[i-1][j];\n				}\n				System.out.print(total[i][j]+\"  \");\n			}\n			System.out.println();\n		}\n	}\n	static int max(int i, int j) {\n		if(i&gt;=j){\n			return i;\n		}\n		return j;\n	}\n}\n</pre>\n<br> 结果如下，去掉了下标为0的记录： \n<p></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\"><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\">0 &nbsp;0 &nbsp;4 &nbsp;4 &nbsp;4 &nbsp;4 &nbsp;4 &nbsp;4 &nbsp;4 &nbsp;4 &nbsp;<br> 0 &nbsp;0 &nbsp;4 &nbsp;5 &nbsp;5 &nbsp;5 &nbsp;9 &nbsp;9 &nbsp;9 &nbsp;9 &nbsp;<br> 0 &nbsp;0 &nbsp;4 &nbsp;5 &nbsp;6 &nbsp;6 &nbsp;9 &nbsp;10 &nbsp;11 &nbsp;11 &nbsp;<br> </span></span></strong></span></span></p> \n<p><br> </p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong>动态规划的思想就是将每一步计算的值保留下来，留作以后使用，空间换时间，还需要不断的去体会。</strong></span></span></p>',NULL,'xingxing','2014-05-17 15:06:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26068949','算法',8),
	(23,'算法——基础篇——FJ的字符串','<strong><span style=\"font-size:18px\">A1057. FJ的字符串（</span></strong> \n<h1 class=\"mb-5\" style=\"margin:0px 0px 5px; padding:0px; font-size:16px; line-height:26px; font-family:\'Microsoft YaHei\',SimHei,arial; word-break:break-all; color:rgb(51,51,51)\"> <span class=\"ask-title \" style=\"display:inline-block; width:595px; overflow:hidden\">http://www.tsinsen.com/A1057</span></h1> ）\n<br> 问题描述　　FJ在沙盘上写了这样一些字符串：\n<br> 　　A1 = “A”\n<br> 　　A2 = “ABA”\n<br> 　　A3 = “ABACABA”\n<br> 　　A4 = “ABACABADABACABA”\n<br> 　　… …\n<br> 　　你能找出其中的规律并写所有的数列AN吗？\n<br> 输入格式　　仅有一个数：N ≤ 26。\n<br> 输出格式　　请输出相应的字符串AN，以一个换行符结束。输出中不得含有多余的空格或换行、回车符。\n<br> 样例输入3\n<br> \n<p><strong><span style=\"font-size:18px\">样例输出ABACABA</span></strong></p> \n<p><span style=\"font-size:18px\"><strong>思路：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>观察规律，对于A2的结果来说，可以看到，A2的结果由三部分组成，A1+B+A1,可以接着往下猜测，A3也可能满足此规律，A3=A2+C+A2，的确也满足这种规律，由此可以推测出如下公式</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>&nbsp; &nbsp; &nbsp;f(A)=A;</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>&nbsp; &nbsp; &nbsp;f(B)=f(A)+B+f(A);</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>&nbsp; &nbsp; &nbsp;f(C)=f(B)+C+f(B);</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>&nbsp; &nbsp; f(D)=f(C)+D+f(C);</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>就是一个递归调用的过程。</strong></span></p> \n<p><span style=\"font-size:18px\"><strong><br> </strong></span></p> \n<p><span style=\"font-size:18px\"><strong>代码如下：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>\n<pre code_snippet_id=\"350068\" snippet_file_name=\"blog_20140517_1_5941584\" name=\"code\" class=\"java\">package hello.ant;\n\nimport java.util.Scanner;\n\npublic class AlogFJ2 {\n	static char[] str={\n		\'A\',\'B\',\'C\',\'D\',\'E\',\n		\'F\',\'G\',\'H\',\'I\',\'J\',\n		\'K\',\'L\',\'M\',\'N\',\'O\',\n		\'P\',\'Q\',\'R\',\'S\',\'T\',\n		\'U\',\'V\',\'W\',\'X\',\'Y\',\n		\'Z\'};\n	public static void main(String[] args) {\n		Scanner scanner=new Scanner(System.in);\n		int n=0;\n		n=scanner.nextInt();\n		String str=findFJ(n-1);\n		System.out.println(str);\n	}\n	static String findFJ(int n) {\n		if(n==0){\n			return \"\"+str[n];\n		}else {\n			return findFJ(n-1)+str[n]+findFJ(n-1);\n		}\n	}\n}\n</pre>输入\n<br> 3\n<br> ABACABA\n<br> \n<p></p> \n<p><span style=\"font-size:18px\"><strong>多观察规律，这种题是可以做出来的。。</strong></span></p> \n<p><span style=\"font-size:18px\"><strong><br> </strong></span></p>',NULL,'xingxing','2014-05-17 12:43:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26061807','算法',8),
	(24,'算法——基础篇——字母图形','<strong><span style=\"font-size:18px\">&nbsp; 问题描述<br> &nbsp; 利用字母可以组成一些美丽的图形，下面给出了一个例子：<br> &nbsp; ABCDEFG<br> &nbsp; BABCDEF<br> &nbsp; CBABCDE<br> &nbsp; DCBABCD<br> &nbsp; EDCBABC<br> &nbsp; 这是一个5行7列的图形，请找出这个图形的规律，并输出一个n行m列的图形。<br> &nbsp; 输入格式<br> &nbsp; 输入一行，包含两个整数n和m，分别表示你要输出的图形的行数的列数。<br> &nbsp; 输出格式<br> &nbsp; 输出n行，每个m个字符，为你的图形。<br> &nbsp; 样例输入<br> &nbsp; 5 7<br> &nbsp; 样例输出<br> &nbsp; ABCDEFG<br> &nbsp; BABCDEF<br> &nbsp; CBABCDE<br> &nbsp; DCBABCD<br> </span></strong> \n<p><strong><span style=\"font-size:18px\">&nbsp; EDCBABC</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p> \n<p><span style=\"font-size:18px\"><strong>思路：观察二维数组的结构，用下标i表示行，j表示列：</strong></span></p> \n<p><span style=\"font-size:18px; color:#ff0000\"><strong>对于字母A满足规律i-j=0，例如array[0][0]=A,<span style=\"font-size:18px\">array[1][1]=A,<span style=\"font-size:18px\">array[2][3]=A,</span></span></strong></span></p> \n<p><span style=\"font-size:18px\"><strong><span style=\"color:#ff0000\"><span style=\"white-space:pre\"></span>字母B满足规律i-j=1或-1,</span><span style=\"font-size:18px\"><span style=\"color:#ff0000\">例如array[1][0]=B,array[2][1]=B,array[0][1]=B,<span style=\"font-size:18px\">array[1][2]=B</span></span></span></strong></span></p> \n<p><span style=\"font-size:18px\"><strong>同理，其他的都是这样的规律：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong><br> </strong></span></p> \n<p><span style=\"font-size:18px\"><strong>代码如下：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>\n<pre code_snippet_id=\"350010\" snippet_file_name=\"blog_20140517_1_5335300\" name=\"code\" class=\"java\">package hello.ant;\n\nimport java.util.Scanner;\n\npublic class AlogTuXing {\n	static char[] str={\'A\',\'B\',\'C\',\'D\',\'E\',\n						\'F\',\'G\',\'H\',\'I\',\'J\',\n						\'K\',\'L\',\'M\',\'N\',\'O\',\n						\'P\',\'Q\',\'R\',\'S\',\'T\',\n						\'U\',\'V\',\'W\',\'X\',\'Y\',\n						\'Z\'};\n	public static void main(String[] args) {\n		int n=5,m=7;//5行7列\n		Scanner scanner=new Scanner(System.in);\n		n=scanner.nextInt();\n		m=scanner.nextInt();\n		char array[][]=new char[n][m];\n		for(int i=0;i&lt;n;i++){\n			for(int j=0;j&lt;m;j++){\n				int x=i-j;\n				if(x&lt;0){\n					x=-1*x;\n				}\n				array[i][j]=str[x];\n			}\n		}\n		displayArray(array);\n	}\n	static void displayArray(char array[][]){\n		for(int i=0;i&lt;array.length;i++){\n			for(int j=0;j&lt;array[i].length;j++){\n				System.out.print(array[i][j]);\n			}\n			System.out.println();\n		}\n	}\n}\n</pre>\n<br> 本题在把握了规律之后，就没有什么难度了。\n<p></p> \n<p><span style=\"font-size:18px\"><strong>题目来源于<a target=\"_blank\" href=\"http://blog.csdn.net/hymanxq/article/details/26019039\">http://blog.csdn.net/hymanxq/article/details/26019039</a></strong></span></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p>',NULL,'xingxing','2014-05-17 11:40:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26058639','算法',8),
	(25,'算法——蓝桥杯篇——乘积最大','<div class=\"pdsec\" style=\"color:rgb(51,51,51); line-height:26px; margin:16px 0px 8px; padding:0px; font-family:微软雅黑,黑体,宋体; font-size:16px\">\n  问题描述\n</div> \n<div class=\"pdcont\" style=\"color:rgb(51,51,51); font-size:14px; margin:0px 0px 0px 16px; padding:0px; font-family:宋体,\'Times New Roman\'; line-height:22px\">\n  　　今年是国际数学联盟确定的“2000——世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰90周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友XZ也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：\n <br style=\"margin:0px; padding:0px\"> \n <br style=\"margin:0px; padding:0px\"> 　　设有一个长度为N的数字串，要求选手使用K个乘号将它分成K+1个部分，找出一种分法，使得这K+1个部分的乘积能够为最大。\n <br style=\"margin:0px; padding:0px\"> \n <br style=\"margin:0px; padding:0px\"> 　　同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：\n <br style=\"margin:0px; padding:0px\"> \n <br style=\"margin:0px; padding:0px\"> 　　有一个数字串：312， 当N=3，K=1时会有以下两种分法：\n <br style=\"margin:0px; padding:0px\"> \n <br style=\"margin:0px; padding:0px\"> 　　3*12=36\n <br style=\"margin:0px; padding:0px\"> 　　31*2=62\n <br style=\"margin:0px; padding:0px\"> \n <br style=\"margin:0px; padding:0px\"> 　　这时，符合题目要求的结果是：31*2=62\n <br style=\"margin:0px; padding:0px\"> \n <br style=\"margin:0px; padding:0px\"> 　　现在，请你帮助你的好朋友XZ设计一个程序，求得正确的答案。\n</div> \n<div class=\"pdsec\" style=\"color:rgb(51,51,51); line-height:26px; margin:16px 0px 8px; padding:0px; font-family:微软雅黑,黑体,宋体; font-size:16px\">\n  输入格式\n</div> \n<div class=\"pdcont\" style=\"color:rgb(51,51,51); font-size:14px; margin:0px 0px 0px 16px; padding:0px; font-family:宋体,\'Times New Roman\'; line-height:22px\">\n  　　程序的输入共有两行：\n <br style=\"margin:0px; padding:0px\"> 　　第一行共有2个自然数N，K（6≤N≤40，1≤K≤6）\n <br style=\"margin:0px; padding:0px\"> 　　第二行是一个长度为N的数字串。\n</div> \n<div class=\"pdsec\" style=\"color:rgb(51,51,51); line-height:26px; margin:16px 0px 8px; padding:0px; font-family:微软雅黑,黑体,宋体; font-size:16px\">\n  输出格式\n</div> \n<div class=\"pdcont\" style=\"color:rgb(51,51,51); font-size:14px; margin:0px 0px 0px 16px; padding:0px; font-family:宋体,\'Times New Roman\'; line-height:22px\">\n  　　输出所求得的最大乘积（一个自然数）。\n</div> \n<div class=\"pdsec\" style=\"color:rgb(51,51,51); line-height:26px; margin:16px 0px 8px; padding:0px; font-family:微软雅黑,黑体,宋体; font-size:16px\">\n  样例输入\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  4 2\n <br style=\"margin:0px; padding:0px; font-family:宋体,\'Times New Roman\'\"> 1231\n</div> \n<div class=\"pdsec\" style=\"color:rgb(51,51,51); line-height:26px; margin:16px 0px 8px; padding:0px; font-family:微软雅黑,黑体,宋体; font-size:16px\">\n  样例输出\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  62\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\"> \n <br> \n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  思路：\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  假设现在有数据array[]=(1,2,3,4),N=4,K=2;\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  乘法相乘的表达式为：\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  1*2*34\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  1*23*4\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  12*3*4\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  一共这三种情况，具体是怎么分析的呢，如下\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  假设我首先选定了下标为0的元素1，即意味着我的表达式结构变成了1*(2,3,4),然后要考虑的就是对表达式的右边部分做处理，（2,3,4）\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  现在要求的就是（2,3,4）的相乘的结果，我们继续选取下标为1的元素，即元素2,表达式就变成了2*(3,4)。到这里应该可以观察出来，这是一个递归的过程了，由于我们最开始的K值为2,递归两次后就可以了，只需要返回（3,4）的值就可以了。\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  整体上来说，，思路就是这样的。\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\"> \n <br> \n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  现在假设数组为array[]={1,2,3,4,5};N=5,K=2\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  还是从下标为0的元素1开始遍历，即1*（2,3,4,5）；然后处理（2,3,4,5），对于这个过程是从下标为1开始的，2*（3,4,5）\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  到这里，已经两次了，需要计算出（3,4,5）的值，并返回结果，做处理。之后便是返回到上一个的处理中，从\n <span style=\"color:rgb(51,51,51); font-family:\'Courier New\',Courier,monospace; font-size:14px; line-height:26px\">下标为2开始进行，即1*（2,3,4,5）的接下来一步过程从2*（3,4,5）变成了23*（4,5）在进行计算，返回结果，并与先前的一个结果比较，保留最大的。</span>\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\"> \n <span style=\"color:rgb(51,51,51); font-family:\'Courier New\',Courier,monospace; font-size:14px; line-height:26px\"><br> </span>\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\"> \n <span style=\"color:rgb(51,51,51); font-family:\'Courier New\',Courier,monospace; font-size:14px; line-height:26px\">整体思路就是这样的。</span>\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\"> \n <span style=\"color:rgb(51,51,51); font-family:\'Courier New\',Courier,monospace; font-size:14px; line-height:26px\">以下便是代码：</span>\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\"> \n <span style=\"color:rgb(51,51,51); font-family:\'Courier New\',Courier,monospace; font-size:14px; line-height:26px\"></span>\n <pre code_snippet_id=\"349944\" snippet_file_name=\"blog_20140517_1_4262955\" name=\"code\" class=\"java\">package hello.ant;\n\npublic class AlogKM {\n	static int N=4;\n	static int K=2;\n	public static void main(String[] args) {\n		int array[]={1,2,3,1};\n		System.out.println(getResult(array, 0, K));\n	}\n	static int getResult(int array[],int begin,int k){\n		if(k==0){\n			return getIntFromArray(array, begin, array.length-1);\n		}else{\n			int result=0;\n			for(int i=begin;i&lt;array.length;i++){\n				int x=getIntFromArray(array, begin, i)*getResult(array, i+1, k-1);\n				if(x&gt;result){\n					result=x;\n				}\n//				if(k==K){\n//					System.out.println(result);\n//				}\n			}\n			return result;\n		}\n	}\n	static int getIntFromArray(int array[],int begin,int i){\n		int sum=0;\n		while(begin&lt;=i){\n			sum=sum*10+array[begin];\n			begin++;\n		}\n		return sum;\n	}\n}\n</pre>\n <br> 加上输入操作的代码为（完整的）：\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\"> \n <span style=\"color:rgb(51,51,51); font-family:\'Courier New\',Courier,monospace; font-size:14px; line-height:26px\"></span>\n <pre code_snippet_id=\"349944\" snippet_file_name=\"blog_20140517_2_2212832\" name=\"code\" class=\"java\">package hello.ant;\n\nimport java.util.Scanner;\n\npublic class AlogKM2 {\n	static int N=4;\n	static int K=2;\n	public static void main(String[] args) {\n		Scanner scanner=new Scanner(System.in);\n		N=scanner.nextInt();\n		K=scanner.nextInt();\n		String str=scanner.next();\n		System.out.println(N);\n		System.out.println(K);\n		System.out.println(str);\n//		int array[]={1,2,3,1};\n		int array[]=strToArray(str);\n		System.out.println(getResult(array, 0, K));\n	}\n	static int[] strToArray(String str){\n		int array[]=new int[N];\n		for(int i=0;i&lt;str.length();i++){\n			array[i]=str.charAt(i)-48;\n//			System.out.println(array[i]);\n		}\n		return array;\n	}\n	static int getResult(int array[],int begin,int k){\n		if(k==0){\n			return getIntFromArray(array, begin, array.length-1);\n		}else{\n			int result=0;\n			for(int i=begin;i&lt;array.length;i++){\n				int x=getIntFromArray(array, begin, i)*getResult(array, i+1, k-1);\n				if(x&gt;result){\n					result=x;\n				}\n//				if(k==K){\n//					System.out.println(result);\n//				}\n			}\n			return result;\n		}\n	}\n	//取出数组指定位置上的元素，比如getIntFromArray(array,0,1)即将数组的前两个元素组合为一个数\n	static int getIntFromArray(int array[],int begin,int i){\n		int sum=0;\n		while(begin&lt;=i){\n			sum=sum*10+array[begin];\n			begin++;\n		}\n		return sum;\n	}\n}\n</pre>\n <br> \n <br> \n</div>',NULL,'xingxing','2014-05-17 10:54:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26052655','算法',8),
	(26,'算法——排列组合篇01','<p><span style=\"font-size:18px\"><strong>现在有一个数组1,2,3,4,5，要求从数组中选取3个元素对其进行排列组合。</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>基本思路就是，先组合，先从数组中选取出所有的组合情况，然后对这每一种组合进行排列。</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>代码如下：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>\n<pre code_snippet_id=\"349847\" snippet_file_name=\"blog_20140517_1_6273323\" name=\"code\" class=\"java\">package hello.ant;\n\npublic class Alog_PL_ZH {\n	public static void main(String[] args) {\n		int array[]={1,2,3,4,5};\n		//先组合，在排列\n		int n=3;\n		int result[]=new int[n];\n		ZH(array,result,0,0,n);\n//		PL(array, 0);\n	}\n\n	static void ZH(int[] array,int result[],int begin,int index,int length) {\n		if(length==0){\n//			for(int i=0;i&lt;result.length;i++){\n//				System.out.print(result[i]);\n//			}\n			System.out.println();\n			PL(result, 0);\n		}else{\n			for(int i=begin;i&lt;array.length;i++){\n				result[index]=array[i];\n				ZH(array,result,i+1,index+1,length-1);\n			}\n		}\n	}\n	static void PL(int result[],int index){\n		if(result.length==index){\n			for(int i=0;i&lt;result.length;i++){\n				System.out.print(result[i]);\n			}\n			System.out.println();\n		}else{\n			for(int i=index;i&lt;result.length;i++){\n				swap(result,i,index);\n				PL(result,index+1);\n				swap(result,i,index);\n			}\n		}\n	}\n\n	static void swap(int[] result, int i, int index) {\n		int temp=result[i];\n		result[i]=result[index];\n		result[index]=temp;\n	}\n}\n</pre>留下一个疑问，如果要求出所有的情况，比如说，组合情况还有1,2,3,4,5,12,13,14,15.......123,124,125....1234,1235......12345\n<p></p> \n<p><span style=\"font-size:18px\"><strong>这种情况下该怎么处理，难道就是简单的在上面的基础上，加上for循环，让result数组的长度从1变到5吗，这样的话，算法的执行效率不高吧。</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>程序代码如下：（暂时没有考虑执行效率）</strong></span></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>\n<pre code_snippet_id=\"349847\" snippet_file_name=\"blog_20140517_2_1224577\" name=\"code\" class=\"java\">package hello.ant;\n\npublic class Alog_PL_ZH2 {\n	public static void main(String[] args) {\n		first();\n//		PL(array, 0);\n	}\n	static void first(){\n		int array[]={1,2,3,4,5};\n		//先组合，在排列\n		int n=3;\n		int result[]=null;\n		for(int i=0;i&lt;array.length;i++){\n			result=new int[i+1];//每次循环都改变result的长度，即意味着第一次是组合的是长度为1的，\n//			这样就可以打印所有情况下的排列组合了。\n			ZH(array,result,0,0,result.length);\n		}\n		\n	}\n	static void ZH(int[] array,int result[],int begin,int index,int length) {\n		if(length==0){\n//			for(int i=0;i&lt;result.length;i++){\n//				System.out.print(result[i]);\n//			}\n			System.out.println();\n			PL(result, 0);\n		}else{\n			for(int i=begin;i&lt;array.length;i++){\n				result[index]=array[i];\n				ZH(array,result,i+1,index+1,length-1);\n			}\n		}\n	}\n	static void PL(int result[],int index){\n		if(result.length==index){\n			for(int i=0;i&lt;result.length;i++){\n				System.out.print(result[i]);\n			}\n			System.out.println();\n		}else{\n			for(int i=index;i&lt;result.length;i++){\n				swap(result,i,index);\n				PL(result,index+1);\n				swap(result,i,index);\n			}\n		}\n	}\n\n	static void swap(int[] result, int i, int index) {\n		int temp=result[i];\n		result[i]=result[index];\n		result[index]=temp;\n	}\n}\n</pre>\n<br> 本文参考了这篇文章\n<a target=\"_blank\" href=\"http://blog.csdn.net/zmazon/article/details/8315418\">http://blog.csdn.net/zmazon/article/details/8315418</a>\n<br> \n<br> \n<p></p>',NULL,'xingxing','2014-05-17 08:50:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26043299','算法',8),
	(27,'算法——组合篇01','<p><strong><span style=\"font-size:18px\">现在有一个数组array[]={1,2,3,4};要求从4个数中取出两个，不重复，组合公式C4^2=6种，即12,13,14,23,24,34.根据这个过程我们可以考虑按从小到大的顺序遍历数组，然后递归执行。</span></strong></p> \n<p><strong><span style=\"font-size:18px\">具体代码如下：</span></strong></p> \n<p><strong><span style=\"font-size:18px\">方法一：</span></strong></p> \n<p><strong><span style=\"font-size:18px\"></span></strong></p>\n<pre code_snippet_id=\"349838\" snippet_file_name=\"blog_20140517_1_8382543\" name=\"code\" class=\"java\">package hello.ant;\n\npublic class AlogZH{\n	\n	public static void main(String[] args) {\n		int array[]={1,2,3,4};\n		int n=2;\n		int result[]=new int[n];\n		ZH(array, result, 0,0,n);\n	}\n	static void ZH(int array[],int result[],int index,int begin,int length){\n		if(length==0){\n			for(int i=0;i&lt;result.length;i++){\n				System.out.print(result[i]);\n			}\n			System.out.println();\n		}else{\n			for(int i=begin;i&lt;array.length;i++){\n				result[index]=array[i];\n				ZH(array, result, index+1,i+1, length-1);\n			}\n		}\n	}\n	\n}</pre>方法二：\n<p></p> \n<p><strong><span style=\"font-size:18px\"></span></strong></p>\n<pre code_snippet_id=\"349838\" snippet_file_name=\"blog_20140517_2_1872317\" name=\"code\" class=\"java\">package hello.ant;\n\npublic class AlogZH2 {\n	static int n=2;\n	static int result[]=new int[n];\n	static int array[]={1,2,3,4,5};\n	static boolean flag[]=new boolean[array.length];\n	public static void main(String[] args) {\n		ZH(0, 0);\n		\n	}\n	static void ZH(int index,int begin){\n		if(index==n){\n			for(int i=0;i&lt;result.length;i++){\n				System.out.print(result[i]);\n			}\n			System.out.println();\n		}else{\n			for(int i=begin;i&lt;array.length;i++){\n				if(flag[i]){\n					continue;\n				}\n				flag[i]=true;\n				result[index]=array[i];\n				ZH(index+1,i+1);\n				flag[i]=false;\n			}\n		}\n	}\n}\n</pre>\n<br> 对于这类问题的分析，感觉就是从宏观上把握它的处理过程，先是一个for循环遍历从下标为0一直到最后一个元素，在循环内部在递归代用本方法，传递参数的时候注意，让它从当前下标+1进行。不断递归，就可以实现题目要求的结果，整体上把握这个过程，就不会错，具体细节，需要多调试，观察。\n<p></p> \n<p><strong><span style=\"font-size:18px\">参考了<a target=\"_blank\" href=\"http://blog.csdn.net/hymanxq/article/details/24490419\">http://blog.csdn.net/hymanxq/article/details/24490419</a>这篇文章的内容。。<br> <br> </span></strong></p> \n<p><br> </p>',NULL,'xingxing','2014-05-17 08:30:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26042359','算法',8),
	(28,'算法——排列篇01','<p><strong><span style=\"font-size:18px\">排列问题:</span></strong></p> \n<p>&nbsp; &nbsp; 将数组a[]={1,2,3}的全排列打印出来，不重复数组中的元素。</p> \n<p>&nbsp; &nbsp; 方法一：</p> \n<p></p> \n<pre code_snippet_id=\"347438\" snippet_file_name=\"blog_20140515_1_1354846\" name=\"code\" class=\"java\">package hello.ant;\n\npublic class AlogPL {\n	static void getAll(int array[],int index){\n		if(index==array.length){\n			for(int i=0;i&lt;array.length;i++){\n				System.out.print(array[i]+\" \");\n			}\n			System.out.println();\n		}else {\n			for(int i=index;i&lt;3;i++){\n				swap(array, i, index);\n				getAll(array, index+1);\n				swap(array, i, index);\n			}\n		}\n	}\n	static void swap(int a[],int i,int index){\n		int temp=a[i];\n		a[i]=a[index];\n		a[index]=temp;\n	}\n	public static void main(String[] args) {\n		int array[]={1,2,3};\n		getAll(array, 0);\n	}\n}\n</pre>\n<br> 方法二： \n<p></p> \n<p></p> \n<pre code_snippet_id=\"347438\" snippet_file_name=\"blog_20140515_2_7495361\" name=\"code\" class=\"java\">package hello.ant;\n\npublic class AlogPL4 {\n	public static void main(String[] args) {\n		int array[]={1,2,3};\n		boolean flag[]=new boolean[array.length];\n		int result[]=new int[array.length];\n		PL(array, result, flag, 0);\n	}\n	static void PL(int array[],int result[],boolean flag[],int index){\n		if(index==result.length){\n			for(int i=0;i&lt;result.length;i++){\n				System.out.print(result[i]);\n			}\n			System.out.println();\n		}else {\n			for(int i=0;i&lt;array.length;i++){\n				if(flag[i]){\n					continue;\n				}\n				result[index]=array[i];\n				flag[i]=true;\n				PL(array, result, flag, index+1);\n				flag[i]=false;\n			}\n		}\n	}\n}\n</pre>重复数组中的元素： \n<p></p> \n<p><br> </p> \n<pre code_snippet_id=\"347438\" snippet_file_name=\"blog_20140515_3_4540166\" name=\"code\" class=\"java\">package hello.ant;\n\npublic class AlogPL2 {\n	\n	static void getAll(int array[],int b[],int index){\n		if(index==b.length){\n			for(int i=0;i&lt;b.length;i++){\n				System.out.print(b[i]+\" \");\n			}\n			System.out.println();\n		}else {\n			for(int i=0;i&lt;2;i++){\n				b[index]=array[i];\n				getAll(array, b,index+1);\n			}\n		}\n	}\n	static void swap(int a[],int i,int index){\n		int temp=a[i];\n		a[i]=a[index];\n		a[index]=temp;\n	}\n	public static void main(String[] args) {\n		int array[]={1,2};\n		int b[]=new int[array.length];\n		getAll(array, b,0);\n	}\n}</pre> \n<p></p> \n<p><br> </p> \n<p>不重复元素，采用非递归的方式实现（按字典顺序）。</p> \n<p></p> \n<pre code_snippet_id=\"347438\" snippet_file_name=\"blog_20140515_4_157294\" name=\"code\" class=\"java\">package hello.ant;\n\nimport java.util.Arrays;\n\npublic class AlogPL3 {\n	//字典排列方式\n	public static void main(String[] args) {\n		int array[]={1,2,3,4};\n		Arrays.sort(array);\n		printArray(array);\n		while(true){\n			//从后往前找最先出现的逆序数对，取最小的值的下标\n			int i=array.length-2;\n			for(;i&gt;=0;i--){\n				if(array[i]&lt;array[i+1]){\n					break;\n				}\n				if(i==0){//此时数组已经是最大的数列了\n					printArray(array);\n					return;\n				}\n			}\n			//从后往前找最先出现的比下标为i的元素值大的元素的下标j;\n			int j=array.length-1;\n			for(;j&gt;=0;j--){\n				if(array[j]&gt;array[i]){\n					break;\n				}\n			}\n			swap(array,i,j);//交换,i,j\n			reverse(array,i+1,array.length-1);\n			printArray(array);\n		}\n		\n		\n	}\n	//翻转\n	static void reverse(int[] array, int i, int j) {\n		// TODO Auto-generated method stub\n//		if(i&gt;=j){\n//			return;\n//		}\n		while(i&lt;j){\n			swap(array, i++, j--);\n		}\n	}\n	static void swap(int[] array, int i, int j) {\n		int temp=array[i];\n		array[i]=array[j];\n		array[j]=temp;\n	}\n	//打印数组\n	static void printArray(int array[]){\n		for(int i=0;i&lt;array.length;i++){\n			System.out.print(array[i]);\n		}\n		System.out.println();\n	}\n}\n</pre>\n<br> 算法还是挺漫长的，不过也很有意思，写这篇文章，记录一下成长的历程。 \n<p></p> \n<p>本人参考过一下两篇博客。</p> \n<p><a target=\"_blank\" href=\"http://blog.csdn.net/hymanxq/article/details/24418135\">http://blog.csdn.net/hymanxq/article/details/24418135</a><br> </p> \n<a target=\"_blank\" href=\"http://blog.csdn.net/zmazon/article/details/8351611\">http://blog.csdn.net/zmazon/article/details/8351611</a> \n<p><br> </p> \n<p>看懂后均有自己实现，感觉算法的细节思路，有很多的技巧，真是博大精深。。我辈还需努力。。。</p>',NULL,'xingxing','2014-05-15 17:14:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/25900073','算法',8),
	(29,'html解析器——jericho-html-3.3解析table','<p><span style=\"font-size:18px\">原文部分内容来源于网上其他博客，不过由于时间长了，忘记参考的是谁的了，在此说声抱歉。。</span></p> \n<p><span style=\"font-size:18px\">先贴出一段html页面：</span></p> \n<p></p>\n<pre code_snippet_id=\"393127\" snippet_file_name=\"blog_20140615_1_2519809\" name=\"code\" class=\"html\">&lt;html&gt;\n&lt;head&gt;\n&lt;meta http-equiv=\"content-type\" content=\"text/html;charset=GBK\"&gt;\n&lt;title&gt;HTML Parser&lt;/title&gt;\n&lt;meta name=\"generator\" content=\"Namo WebEditor\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;table width=620 border=0 cellpadding=1 cellspacing=0 bgcolor=#0066cc&gt;\n	&lt;tr&gt;\n		&lt;td width=100%&gt;\n		&lt;table width=100% border=0 cellpadding=4 cellspacing=0 bgcolor=#D3E5FB&gt;\n			&lt;tr bgcolor=#D3E5FB&gt;\n				&lt;td width=20%&gt;&lt;font size=\"2\" face=\"Arial,Verdana\"&gt;&lt;b&gt;想学习\n				Name&lt;/b&gt;&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=13%&gt;&lt;font size=\"2\" face=\"Arial,Verdana\"&gt;&lt;b&gt;Result&lt;/b&gt;&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=8%&gt;&lt;font size=\"2\" face=\"Arial,Verdana\"&gt;&lt;b&gt;Time&lt;/b&gt;&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=59%&gt;&lt;font size=\"2\" face=\"Arial,Verdana\"&gt;&lt;b&gt;Synopsis&lt;/b&gt;&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n			&lt;/tr&gt;\n			&lt;tr bgcolor=#eeeeee&gt;\n				&lt;td width=20%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;&lt;b&gt;9&lt;/b&gt;\n				想学习&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=13%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;&lt;font\n					color=#ff0033&gt;+FAIL&lt;/font&gt; &lt;a\n					href=\"v4_wireless_802.1x_full/cdrouter_dhcp_20.txt\"&gt;想学习&lt;/a&gt;&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=8%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;12:31&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=59%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;想学习&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n			&lt;/tr&gt;\n			&lt;tr bgcolor=#ffffff&gt;\n				&lt;td width=20%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;&lt;b&gt;1&lt;/b&gt;\n				cdrouter_basic_1&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=13%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;Pass &lt;a\n					href=\"v4_wireless_802.1x_full/cdrouter_basic_1.txt\"&gt;想学习&lt;/a&gt;&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=8%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;00:00&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=59%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;想学习&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n			&lt;/tr&gt;\n		&lt;/table&gt;\n		&lt;/td&gt;\n	&lt;/tr&gt;\n&lt;/table&gt;\n&lt;/body&gt;\n&lt;/html&gt;</pre>\n<br> \n<span style=\"font-size:18px\">对于这个页面来说我想取出所有的td里面的文字内容，该怎么办呢，如果用正则表达式，我还真是难以写出正确的，来解析出我所要的结果。</span>\n<p></p> \n<p><span style=\"font-size:18px\">在网上搜索了一下jericho-html-3.3这个插件，用来解析table，的确很方便。</span></p> \n<p><span style=\"font-size:18px\">代码如下：</span></p> \n<p><span style=\"font-size:18px\"></span></p>\n<pre code_snippet_id=\"393127\" snippet_file_name=\"blog_20140615_2_1200816\" name=\"code\" class=\"java\">package com.xxx.hbuassys.test;\n\nimport java.net.URL;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport net.htmlparser.jericho.Element;\nimport net.htmlparser.jericho.HTMLElementName;\nimport net.htmlparser.jericho.Segment;\nimport net.htmlparser.jericho.Source;\n \npublic class HtmlParser\n{\n    public static void main(String[] args) throws Exception\n    {\n        String sourceUrlString=\"test.html\";\n        \n        if(sourceUrlString.indexOf(\':\') == -1)\n            sourceUrlString =\"file:\"+sourceUrlString;\n        Source source=new Source(new URL(sourceUrlString));\n        List Elements_TABLE=source.getAllElements(HTMLElementName.TABLE);\n        Elements_TABLE.remove(0);//由于table相互嵌套，我们需要的是第二个，所以删掉第一个\n        Iterator it_TABLE = Elements_TABLE.iterator();\n        while(it_TABLE.hasNext())\n        {\n            Element Element_TABLE = (Element)it_TABLE.next();\n//        	System.out.println(\"**\"+Element_TABLE.toString()+\"\\n**\");\n            Segment getContent_TABLE = (Segment)Element_TABLE.getContent();\n            List Elements_TR = getContent_TABLE.getAllElements(HTMLElementName.TR);\n            Iterator it_TR = Elements_TR.iterator();\n            while(it_TR.hasNext())\n            {\n                Element Element_TR = (Element)it_TR.next();\n                Segment getContent_TR = (Segment)Element_TR.getContent();\n                List Elements_FONT = getContent_TR.getAllElements(HTMLElementName.FONT);\n                Iterator it_FONT = Elements_FONT.iterator();\n                int i = 1;\n                while(it_FONT.hasNext())\n                {\n                    Element Element_FONT = (Element)it_FONT.next();\n                    Segment getContent_FONT = (Segment)Element_FONT.getContent();\n                    String a1 = getContent_FONT.toString();\n                    System.out.println(i + \" = \" + Element_FONT.getContent().getTextExtractor().toString());\n                    i++;\n                }\n                System.out.println();\n            }\n        }\n    }\n}\n</pre>结果：\n<p></p> \n<p><span style=\"font-size:18px\">1 = 想学习 Name<br> 2 = Result<br> 3 = Time<br> 4 = Synopsis<br> <br> <br> 1 = 9 想学习<br> 2 = +FAIL 想学习<br> 3 = +FAIL<br> 4 = 12:31<br> 5 = 想学习<br> <br> <br> 1 = 1 cdrouter_basic_1<br> 2 = Pass 想学习<br> 3 = 00:00<br> 4 = 想学习<br> <br> <br> 大致的思路就是，先取出所有的table标签，然后对需要的table进行解析，取出里面的tr,在从tr里面取出td这样就可以得到我们需要的内容了。</span></p> \n<p><span style=\"font-size:18px\">如果只说到这，那么就跟网上其他人讲的没有什么区别了。</span></p> \n<p><span style=\"font-size:18px\">因为项目的需要，使用此插件发现了一个问题：</span></p> \n<p><span style=\"font-size:18px\">如果html页面的编码是UTF-8的格式，那么解析出来的内容就会是乱码，如果直接对这些乱码编码，采用new String(str.getBytes(),\"GBK\");等之类的操作都不能解决问题，本人亲自测试过。</span></p> \n<p><span style=\"font-size:18px\">例如html页面变为：</span></p> \n<p><span style=\"font-size:18px\"></span></p>\n<pre code_snippet_id=\"393127\" snippet_file_name=\"blog_20140615_3_1309500\" name=\"code\" class=\"html\">&lt;html&gt;\n&lt;head&gt;\n&lt;meta http-equiv=\"content-type\" content=\"text/html;charset=UTF-8\"&gt;\n&lt;title&gt;HTML Parser&lt;/title&gt;\n&lt;meta name=\"generator\" content=\"Namo WebEditor\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;table width=620 border=0 cellpadding=1 cellspacing=0 bgcolor=#0066cc&gt;\n	&lt;tr&gt;\n		&lt;td width=100%&gt;\n		&lt;table width=100% border=0 cellpadding=4 cellspacing=0 bgcolor=#D3E5FB&gt;\n			&lt;tr bgcolor=#D3E5FB&gt;\n				&lt;td width=20%&gt;&lt;font size=\"2\" face=\"Arial,Verdana\"&gt;&lt;b&gt;想学习\n				Name&lt;/b&gt;&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=13%&gt;&lt;font size=\"2\" face=\"Arial,Verdana\"&gt;&lt;b&gt;Result&lt;/b&gt;&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=8%&gt;&lt;font size=\"2\" face=\"Arial,Verdana\"&gt;&lt;b&gt;Time&lt;/b&gt;&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=59%&gt;&lt;font size=\"2\" face=\"Arial,Verdana\"&gt;&lt;b&gt;Synopsis&lt;/b&gt;&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n			&lt;/tr&gt;\n			&lt;tr bgcolor=#eeeeee&gt;\n				&lt;td width=20%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;&lt;b&gt;9&lt;/b&gt;\n				想学习&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=13%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;&lt;font\n					color=#ff0033&gt;+FAIL&lt;/font&gt; &lt;a\n					href=\"v4_wireless_802.1x_full/cdrouter_dhcp_20.txt\"&gt;想学习&lt;/a&gt;&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=8%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;12:31&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=59%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;想学习&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n			&lt;/tr&gt;\n			&lt;tr bgcolor=#ffffff&gt;\n				&lt;td width=20%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;&lt;b&gt;1&lt;/b&gt;\n				cdrouter_basic_1&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=13%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;Pass &lt;a\n					href=\"v4_wireless_802.1x_full/cdrouter_basic_1.txt\"&gt;想学习&lt;/a&gt;&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=8%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;00:00&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=59%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;想学习&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n			&lt;/tr&gt;\n		&lt;/table&gt;\n		&lt;/td&gt;\n	&lt;/tr&gt;\n&lt;/table&gt;\n&lt;/body&gt;\n&lt;/html&gt;</pre>\n<br> 得到的结果是：\n<p></p> \n<p><span style=\"font-size:18px\">1 = ???? Name<br> 2 = Result<br> 3 = Time<br> 4 = Synopsis<br> <br> <br> 1 = 9 ????<br> 2 = +FAIL ????<br> 3 = +FAIL<br> 4 = 12:31<br> 5 = ????<br> <br> <br> 1 = 1 cdrouter_basic_1<br> 2 = Pass ????<br> 3 = 00:00<br> 4 = ????<br> <br> <br> </span></p> \n<p><span style=\"font-size:18px\">采用的方法是：改变&lt;meta http-equiv=\"content-type\" content=\"text/html;charset=UTF-8\"&gt;变为：<span style=\"font-size:18px\">&lt;meta http-equiv=\"content-type\" content=\"text/html;charset=GBK\"&gt;</span></span></p> \n<p><span style=\"font-size:18px\">详细情况，参考代码如下：</span></p> \n<p><span style=\"font-size:18px\"></span></p>\n<pre code_snippet_id=\"393127\" snippet_file_name=\"blog_20140615_4_6642437\" name=\"code\" class=\"java\">package com.xxx.hbuassys.test;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileReader;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport net.htmlparser.jericho.Element;\nimport net.htmlparser.jericho.HTMLElementName;\nimport net.htmlparser.jericho.Segment;\nimport net.htmlparser.jericho.Source;\n \npublic class HtmlParser\n{\n    public static void main(String[] args) throws Exception\n    {\n    	BufferedReader reader=new BufferedReader(new InputStreamReader(new FileInputStream(new File(\"test.html\"))));\n//    	BufferedReader reader=new BufferedReader(new FileReader(new File(\"test.html\")));\n    	StringBuilder sbf=new StringBuilder();\n    	String str=null;\n    	while((str=reader.readLine())!=null){\n    		sbf.append(str).append(\"\\n\");\n    	}\n    	//解决中文乱码的方法\n    	String html=sbf.toString().replace(\"&lt;meta http-equiv=\\\"content-type\\\" content=\\\"text/html;charset=UTF-8\\\"&gt;\", \"&lt;meta http-equiv=\\\"content-type\\\" content=\\\"text/html;charset=GBK\\\"&gt;\");\n//    	System.out.println(html);\n        Source source=new Source(html);\n        List Elements_TABLE=source.getAllElements(HTMLElementName.TABLE);\n        Elements_TABLE.remove(0);//由于table相互嵌套，我们需要的是第二个，所以删掉第一个\n        Iterator it_TABLE = Elements_TABLE.iterator();\n        while(it_TABLE.hasNext())\n        {\n            Element Element_TABLE = (Element)it_TABLE.next();\n//        	System.out.println(\"**\"+Element_TABLE.toString()+\"\\n**\");\n            Segment getContent_TABLE = (Segment)Element_TABLE.getContent();\n            List Elements_TR = getContent_TABLE.getAllElements(HTMLElementName.TR);\n            Iterator it_TR = Elements_TR.iterator();\n            while(it_TR.hasNext())\n            {\n                Element Element_TR = (Element)it_TR.next();\n                Segment getContent_TR = (Segment)Element_TR.getContent();\n                List Elements_FONT = getContent_TR.getAllElements(HTMLElementName.FONT);\n                Iterator it_FONT = Elements_FONT.iterator();\n                int i = 1;\n                while(it_FONT.hasNext())\n                {\n                    Element Element_FONT = (Element)it_FONT.next();\n                    Segment getContent_FONT = (Segment)Element_FONT.getContent();\n                    String a1 = getContent_FONT.toString();\n                    System.out.println(i + \" = \" + Element_FONT.getContent().getTextExtractor().toString());\n                    i++;\n                }\n                System.out.println();\n            }\n        }\n    }\n}\n</pre>\n<br> 结果如下：\n<p></p> \n<p><span style=\"font-size:18px\">1 = 想学习 Name<br> 2 = Result<br> 3 = Time<br> 4 = Synopsis<br> <br> <br> 1 = 9 想学习<br> 2 = +FAIL 想学习<br> 3 = +FAIL<br> 4 = 12:31<br> 5 = 想学习<br> <br> <br> 1 = 1 cdrouter_basic_1<br> 2 = Pass 想学习<br> 3 = 00:00<br> 4 = 想学习<br> <br> <br> </span></p> \n<p><span style=\"font-size:18px\"><br> </span></p> \n<p><br> </p>',NULL,'xingxing','2014-06-15 10:16:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/30969607','java插件',9),
	(30,'android tv 实现全屏画竖线','<p><strong><span style=\"font-size:18px\">自定义view</span></strong></p> \n<p><strong><span style=\"font-size:18px\">采用canvas双缓冲的方式，可以减少绘制的时间，提升性能。</span></strong></p> \n<p><strong><span style=\"font-size:18px\">StaggeredView.java</span></strong></p> \n<p><strong><span style=\"font-size:18px\">源代码如下：</span></strong></p> \n<p></p>\n<pre name=\"code\" class=\"java\">package com.xxx.demo;\n\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.view.View;\nimport android.view.WindowManager;\npublic class StaggeredView extends View {\n    int width;\n    int height;\n    Paint p;\n    Bitmap bitmap = null;\n    Canvas x = null;\n\n    public StaggeredView(Context context) {\n        super(context);\n        WindowManager wm = (WindowManager) getContext().getSystemService(\n                Context.WINDOW_SERVICE);\n        width = wm.getDefaultDisplay().getWidth();\n        height = wm.getDefaultDisplay().getHeight();\n        p = new Paint();\n    }\n\n    private void initMyCanvas() {\n        p.setColor(Color.WHITE);// 设置绿色\n        bitmap = Bitmap.createBitmap(20, 20, Bitmap.Config.ARGB_8888);\n        // Create canvas.\n        x = new Canvas();\n        x.setBitmap(bitmap);\n        p.setStyle(Paint.Style.STROKE);\n        p.setAntiAlias(true);\n        for (int i = 0; i &lt;=20; i++) {\n            changeColor(i, p);\n            x.drawLine(i, 0, i, 20, p);// 画线\n        }\n    }\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        canvas.drawColor(Color.WHITE);\n        // 创建画笔\n        long startTime=System.currentTimeMillis();\n        initMyCanvas();\n        int bitWidth = bitmap.getWidth();\n        int bitHeight = bitmap.getHeight();\n        for (int i = 0; i &lt; height; i += bitHeight) {\n            for (int j = 0; j &lt; width; j += bitWidth) {\n//                changeColor(i,j,p);\n//                canvas.drawPoint(i, j, p);\n                canvas.drawBitmap(bitmap, j, i, p);\n            }\n        }\n        System.out.println(\"时间===\"+(System.currentTimeMillis()-startTime));\n    }\n    /**\n     * 改变画笔的颜色\n     *\n     * @param i\n     * @param p\n     */\n    private void changeColor(int i, Paint p) {\n        switch (i % 2) {\n            case 0:\n                p.setColor(Color.WHITE);\n                break;\n            case 1:\n                p.setColor(Color.BLACK);\n                break;\n        }\n    }\n}\n</pre>\n<p></p> \n<p><span style=\"font-size:18px\"><strong>首先先画出一个小的矩形区域，创建一个canvas画在BitMap上，之后使用系统的canavas复用前面的BitMap,可以提高处理的效率。</strong></span></p> \n<p><br> </p> MainActivity.java \n<p></p>\n<pre name=\"code\" class=\"java\">public class MainActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(new StaggeredView(this));\n    }\n}</pre>\n<strong><span style=\"font-size:18px\">打印的结果如下：<br> &nbsp;I/System.out: 时间===91</span></strong>\n<p></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\">方法二：</span></strong></p> \n<p><strong><span style=\"font-size:18px\">StaggeredView2.java</span></strong></p> \n<p><strong><span style=\"font-size:18px\">采用默认的方式，就是一个循环，画width个竖线。效率还是很低下的。。</span></strong></p> \n<p></p>\n<pre name=\"code\" class=\"java\">public class StaggeredView2 extends View {\n    int width;\n    int height;\n    Paint p;\n    Bitmap bitmap = null;\n    Canvas x = null;\n\n    public StaggeredView2(Context context) {\n        super(context);\n        WindowManager wm = (WindowManager) getContext().getSystemService(\n                Context.WINDOW_SERVICE);\n        width = wm.getDefaultDisplay().getWidth();\n        height = wm.getDefaultDisplay().getHeight();\n        p = new Paint();\n        initMyCanvas();\n    }\n\n    private void initMyCanvas() {\n        p.setColor(Color.WHITE);// 设置绿色\n        bitmap = Bitmap.createBitmap(20, 20, Bitmap.Config.ARGB_8888);\n        // Create canvas.\n        x = new Canvas();\n        x.setBitmap(bitmap);\n        p.setStyle(Paint.Style.STROKE);\n        p.setAntiAlias(true);\n        for (int i = 0; i &lt;= 30; i++) {\n            changeColor(i, p);\n            x.drawLine(i, 0, i, 30, p);// 画线\n        }\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        canvas.drawColor(Color.WHITE);\n        // 创建画笔\n        long startTime=System.currentTimeMillis();\n        for (int i = 0; i &lt; width; i++) {\n            changeColor(i, p);\n            canvas.drawLine(i,0, i, height - 1, p);\n        }\n        System.out.println(\"时间===\"+(System.currentTimeMillis()-startTime));\n    }\n\n    /**\n     * 改变画笔的颜色\n     *\n     * @param i\n     * @param p\n     */\n    private void changeColor(int i, Paint p) {\n        switch (i % 2) {\n            case 0:\n                p.setColor(Color.WHITE);\n                break;\n            case 1:\n                p.setColor(Color.BLACK);\n                break;\n        }\n    }\n}\n</pre>\n<strong><span style=\"font-size:18px\">结果为：</span></strong>\n<p></p> \n<p><strong><span style=\"font-size:18px\">I/System.out: 时间===277</span></strong></p> \n<p><strong><span style=\"font-size:18px\">相对前面的方式而言，效率是很低下的。。。</span></strong></p> \n<p><br> <br> </p> \n<p><br> <br> </p>',NULL,'xingxing','2014-08-10 18:24:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/38471883','android tv',10),
	(31,'android tv 实现颜色条滚动效果(第二种方式)','<p><span style=\"font-size:18px\"><strong>方法二显得比较笨重，算是蠢方法吧。。</strong></span></p> \n<p><strong><span style=\"font-size:18px\">最开始没有办法的情况下采用的一种方式。</span></strong></p> \n<p><strong><span style=\"font-size:18px\">采用的是</span></strong></p> \n<p><strong><span style=\"font-size:18px\">ColorView2 extends SurfaceView implements SurfaceHolder.Callback, Runnable方式<br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\">代码如下：</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><strong><span style=\"font-size:18px\">ColorView2.java</span></strong><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\"><strong><span style=\"font-size:18px\"></span></strong></span></strong></p>\n<pre code_snippet_id=\"447182\" snippet_file_name=\"blog_20140810_1_6564439\" name=\"code\" class=\"java\">/**\n * 色彩效果view1\n */\npublic class ColorView2 extends SurfaceView implements SurfaceHolder.Callback, Runnable {\n    int width;\n    int height;\n    Paint p;\n    int i = 0;\n    SurfaceHolder mSurfaceHolder = null;\n    int all = 256 * 5;\n    float strokeWidth = 0;\n    int exteraLength = 1;\n\n    public ColorView2(Context context) {\n        super(context);\n        WindowManager wm = (WindowManager) getContext().getSystemService(\n                Context.WINDOW_SERVICE);\n        width = wm.getDefaultDisplay().getWidth();\n        height = wm.getDefaultDisplay().getHeight();\n        System.out.println(\"width==\" + width);\n        System.out.println(\"height==\" + height);\n        p = new Paint();\n        if (all &gt;= width) {\n        } else {\n            exteraLength = (int) Math.ceil(1.0 * all / (width - all));\n        }\n        mSurfaceHolder = this.getHolder();\n        mSurfaceHolder.addCallback(this);\n        this.setFocusable(true);\n        this.setKeepScreenOn(true);\n        i = 0;\n    }\n\n    public ColorView2(Context context, AttributeSet attributeSet) {\n        super(context, attributeSet);\n        WindowManager wm = (WindowManager) getContext().getSystemService(\n                Context.WINDOW_SERVICE);\n        width = wm.getDefaultDisplay().getWidth();\n        height = wm.getDefaultDisplay().getHeight();\n        System.out.println(\"width==\" + width);\n        System.out.println(\"height==\" + height);\n        p = new Paint();\n        if (all &gt;= width) {\n        } else {\n            exteraLength = (int) Math.ceil(1.0 * all / (width - all));\n        }\n        mSurfaceHolder = this.getHolder();\n        mSurfaceHolder.addCallback(this);\n        this.setFocusable(true);\n        this.setKeepScreenOn(true);\n        i = 0;\n    }\n\n    //动态画图\n    void complexdraw(int current) {\n        Canvas canvas = mSurfaceHolder\n                .lockCanvas(new Rect(current, 0, current + exteraLength, height));// 关键:获取画布    new Rect(current, 0, current+exteraLength,height)\n        Log.i(\"Canvas:X:\", \"complexdraw\");\n        if (mSurfaceHolder == null || canvas == null) {\n            return;\n        }\n        //处理不同的分辨率，造成画图的差异性\n        if (exteraLength != 1) {\n            if (i % exteraLength == exteraLength - 1) {\n                System.out.println(\"exteraLength==\" + exteraLength);\n                System.out.println(\"current==\" + current);\n                canvas.drawLine(current + current / exteraLength, 0, current + current / exteraLength, height, p);\n                canvas.drawLine(current + current / exteraLength + 1, 0, current + current / exteraLength + 1, height, p);\n            } else {\n                System.out.println(\"exteraLength==1---------&gt;\" + exteraLength);\n                System.out.println(\"current==\" + current);\n                canvas.drawLine(current + current / exteraLength, 0, current + current / exteraLength, height, p);\n            }\n        } else {\n            canvas.drawLine(current, 0, current, height, p);\n        }\n        mSurfaceHolder.unlockCanvasAndPost(canvas);\n    }\n\n    @Override\n    public void surfaceCreated(SurfaceHolder surfaceHolder) {\n        new Thread(this).start();\n    }\n\n    @Override\n    public void surfaceChanged(SurfaceHolder surfaceHolder, int i, int i2, int i3) {\n\n    }\n\n    @Override\n    public void surfaceDestroyed(SurfaceHolder surfaceHolder) {\n        i = all;//屏幕宽度的最大值\n    }\n\n    @Override\n    public void run() {\n// 创建画笔\n//		红（R：255 G：0 B：0）\n//		橙（R：255 G：156 B：0）\n//		黄（R：255 G：255 B：0）\n//		绿（R：0 G：255 B：0）\n//		青（R： G：255 B：255）\n//		蓝（R：0 G：0 B：255）\n//		紫（R：255 G： B：255）\n        System.out.println(\"canvas\");\n        int all = 256 * 5;\n        float strokeWidth = (float) (width * 1.0 / all);\n        System.out.println(\"strokeWidth==\" + strokeWidth);\n        Log.i(\"Canvas:X:\", \"complexdraw\");\n        while (i &lt; all) {\n            if (i &lt;= 255) {\n                p.setColor(Color.rgb(255, i, 0));\n            } else if (i &gt;= 256 &amp;&amp; i &lt;= 511) {\n                p.setColor(Color.rgb(511 - i, 255, 0));\n            } else if (i &gt;= 512 &amp;&amp; i &lt;= 767) {\n                p.setColor(Color.rgb(0, 255, i - 512));\n            } else if (i &gt;= 768 &amp;&amp; i &lt;= 1023) {\n                p.setColor(Color.rgb(0, 1023 - i, 255));\n            } else if (i &gt;= 1024 &amp;&amp; i &lt;= 1279) {\n                p.setColor(Color.rgb(i - 1024, 0, 255));\n            }\n            complexdraw(i);\n            i++;\n        }\n    }\n}</pre>\n<br> MainActvity.java\n<p></p> \n<p><strong><span style=\"font-size:18px\"><strong><span style=\"font-size:18px\"></span></strong></span></strong></p>\n<pre code_snippet_id=\"447182\" snippet_file_name=\"blog_20140810_2_3118876\" name=\"code\" class=\"java\">public class MainActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(R.layout.activity_color2);\n    }\n}</pre>\n<p></p> \n<p><strong><span style=\"font-size:18px\"><strong><span style=\"font-size:18px\">activity_color2.xml</span></strong></span></strong></p> \n<p><strong><span style=\"font-size:18px\"><strong><span style=\"font-size:18px\"></span></strong></span></strong></p>\n<pre code_snippet_id=\"447182\" snippet_file_name=\"blog_20140810_3_8800477\" name=\"code\" class=\"html\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n\n&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n              android:orientation=\"vertical\"\n              android:layout_width=\"fill_parent\"\n              android:layout_height=\"fill_parent\"&gt;\n    &lt;com.xxx.demo.ColorView2\n            android:id=\"@+id/colorView\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"fill_parent\"\n            /&gt;\n&lt;/LinearLayout&gt;</pre>\n<br> \n<br> \n<p></p> \n<p><br> </p>',NULL,'xingxing','2014-08-10 17:20:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/38471437','android tv',10),
	(32,'android tv 实现颜色条滚动效果','<p><span style=\"font-size:18px\"><strong>直接贴代码：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>ColorView.java</strong></span></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>\n<pre name=\"code\" class=\"java\">package com.xxx.demo;\n\nimport android.content.Context;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.View;\nimport android.view.WindowManager;\n/**\n * 色彩效果view1\n */\npublic class ColorView extends View {\n    int width;\n    int height;\n    Paint p;\n    int i = 0;\n    int all = 256 * 5;//颜色值变化\n    int exteraLength = 1;\n    Context context = null;\n    int j = 0;\n    int mLength = 0;//每次重绘时j的增量值\n\n    public ColorView(Context context) {\n        super(context);\n        this.context = context;\n        WindowManager wm = (WindowManager) getContext().getSystemService(\n                Context.WINDOW_SERVICE);\n        width = wm.getDefaultDisplay().getWidth();\n        height = wm.getDefaultDisplay().getHeight();\n        //判断是否是标准的高度\n        System.out.println(\"width==\" + width);\n        System.out.println(\"height==\" + height);\n        p = new Paint();\n        if (all &gt;= width) {\n            mLength = 80;\n        } else {\n            mLength = 30;\n            exteraLength = (int) Math.ceil(1.0 * all / (width - all));\n        }\n        this.setFocusable(true);\n        this.setKeepScreenOn(true);\n        i = 0;\n    }\n    public ColorView(Context context, AttributeSet attributeSet) {\n        super(context, attributeSet);\n        this.context = context;\n        WindowManager wm = (WindowManager) getContext().getSystemService(\n                Context.WINDOW_SERVICE);\n        width = wm.getDefaultDisplay().getWidth();\n        height = wm.getDefaultDisplay().getHeight();\n        System.out.println(\"width==\" + width);\n        System.out.println(\"height==\" + height);\n        p = new Paint();\n        p.setAntiAlias(true);\n        p.setStyle(Paint.Style.FILL);\n        if (all &gt;= width) {\n            mLength = 80;\n        } else {\n            mLength = 30;\n            exteraLength = (int) Math.ceil(1.0 * all / (width - all));\n        }\n        this.setFocusable(true);\n        this.setKeepScreenOn(true);\n        i = 0;\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        if (j &gt; all) {\n            //结束的情况。还是需要绘制的，不然界面会变黑\n            myDraw(canvas);\n            System.out.println(\"end\");\n            return;\n        }\n        myDraw(canvas);\n        j+=mLength;//改变j的值\n        invalidate();//onDraw后，重新绘制view,主观上产生动画效果\n    }\n\n\n    public void myDraw(Canvas canvas) {\n// 创建画笔\n//		红（R：255 G：0 B：0）\n//		橙（R：255 G：156 B：0）\n//		黄（R：255 G：255 B：0）\n//		绿（R：0 G：255 B：0）\n//		青（R： G：255 B：255）\n//		蓝（R：0 G：0 B：255）\n//		紫（R：255 G： B：255）\n        System.out.println(\"canvas\");\n        Log.i(\"Canvas:X:\", \"complexdraw\");\n        i = 0;\n        while (i &lt;= j) {\n            if (i &lt;= 255) {\n                p.setColor(Color.rgb(255, i, 0));\n            } else if (i &gt;= 256 &amp;&amp; i &lt;= 511) {\n                p.setColor(Color.rgb(511 - i, 255, 0));\n            } else if (i &gt;= 512 &amp;&amp; i &lt;= 767) {\n                p.setColor(Color.rgb(0, 255, i - 512));\n            } else if (i &gt;= 768 &amp;&amp; i &lt;= 1023) {\n                p.setColor(Color.rgb(0, 1023 - i, 255));\n            } else if (i &gt;= 1024 &amp;&amp; i &lt;= 1279) {\n                p.setColor(Color.rgb(i - 1024, 0, 255));\n            }\n            //处理不同的分辨率，造成画图的差异性，均分颜色值，屏幕宽度1280，颜色值的范围也是1280刚刚好，如果是小米电视的，屏幕宽度为1920,多出来的，需要均分，下面便是处理方式\n            if (exteraLength != 1) {\n                if (i % exteraLength == exteraLength - 1) {\n                    System.out.println(\"exteraLength==\" + exteraLength);\n                    System.out.println(\"current==\" + i);\n                    canvas.drawLine(i + i / exteraLength, 0, i + i / exteraLength, height, p);//画线\n                    canvas.drawLine(i + i / exteraLength + 1, 0, i + i / exteraLength + 1, height, p);\n                } else {\n                    System.out.println(\"exteraLength==1---------&gt;\" + exteraLength);\n                    System.out.println(\"current==\" + i);\n                    canvas.drawLine(i + i / exteraLength, 0, i + i / exteraLength, height, p);\n                }\n            } else {\n                canvas.drawLine(i, 0, i, height, p);\n            }\n            i++;\n        }\n    }\n}</pre>\n<br> MainActivity.java\n<p></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>\n<pre name=\"code\" class=\"java\">public class MainActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(R.layout.activity_color);\n    }\n}</pre>\n<br> activity_color.xml\n<p></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>\n<pre name=\"code\" class=\"html\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n\n&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n              android:orientation=\"vertical\"\n              android:layout_width=\"fill_parent\"\n              android:layout_height=\"fill_parent\"&gt;\n    &lt;com.xxx.demo.ColorView\n            android:id=\"@+id/colorView\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"fill_parent\"\n            /&gt;\n&lt;/LinearLayout&gt;</pre>\n<br> 在自定义view中的onDraw（）方法中，调用invalidate（）方法，可以实现类似于小球移动的效果。。\n<p></p>',NULL,'xingxing','2014-08-10 17:04:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/38471303','android tv',10),
	(33,'android studio 报编码 GBK 的不可映射字符问题','<p><strong><span style=\"font-size:18px\">解决办法：在build.gradle文件中添加：</span></strong></p> \n<p><strong><span style=\"font-size:18px\">buildscript {<br> &nbsp; &nbsp; repositories {<br> &nbsp; &nbsp; &nbsp; &nbsp; maven { url \'http://repo1.maven.org/maven2\' }<br> &nbsp; &nbsp; }<br> &nbsp; &nbsp; dependencies {<br> &nbsp; &nbsp; &nbsp; &nbsp; classpath \'com.android.tools.build:gradle:0.4\'<br> &nbsp; &nbsp; }<br> }<br> apply plugin: \'android\'<br> <br> <br> dependencies {<br> &nbsp; &nbsp; compile files(\'libs/android-support-v4.jar\')<br> &nbsp; &nbsp; compile files(\'libs/umeng-analytics-v5.2.4.jar\')<br> }<br> <br> <br> android {<br> &nbsp; &nbsp; compileSdkVersion 17<br> &nbsp; &nbsp; buildToolsVersion \"17.0.0\"<br> <br> <br> &nbsp; &nbsp; defaultConfig {<br> &nbsp; &nbsp; &nbsp; &nbsp; minSdkVersion 7<br> &nbsp; &nbsp; &nbsp; &nbsp; targetSdkVersion 16<br> &nbsp; &nbsp; }<br> &nbsp; &nbsp; signingConfigs {<br> &nbsp; &nbsp; &nbsp; &nbsp; myConfig {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //...<br> &nbsp; &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; }<br> &nbsp; &nbsp; buildTypes {<br> &nbsp; &nbsp; &nbsp; &nbsp; release {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; signingConfig signingConfigs.myConfig<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; runProguard true<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proguardFile \'proguard-project.txt\'<br> &nbsp; &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; }<br> }<br> <span style=\"color:#ff0000\">tasks.withType(Compile) {<br> &nbsp; &nbsp; options.encoding = \"UTF-8\"<br> }</span><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\">加上红色部分的代码就可以解决编码问题</span></strong></p> \n<p><br> </p> \n<p><br> </p>',NULL,'xingxing','2014-07-24 14:05:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/38083631','android tv',10),
	(34,'自定义view中在指定的矩形区域中放入一张图片','<p><strong><span style=\"font-size:18px\">如何在自定义view中，在指定的矩形区域中放入一张图片，让其刚好填充这个矩形区域，办法只能是对图片进行放大或者是缩小。</span></strong></p> \n<p><strong><span style=\"font-size:18px\"></span></strong></p>\n<pre name=\"code\" class=\"java\">Bitmap bitmap = BitmapFactory.decodeResource(getContext().getResources(), R.drawable.wenzi);//根据原来///的资源，得到bitmap\n        int bmpWidth = bitmap.getWidth();\n        int bmpHeight = bitmap.getHeight();\n        //矩形区域的大小，为正方形\n        int sideLength = height / 4;//矩形区域的大小，项目中使用的是正方形\n         /* 设置图片缩小比例 */\n        double scale = 0;\n//        //图片小于矩形区域,需要放大\n//        if(bmpWidth&lt;=sideLength){\n//        }else{\n//            //图片大于矩形区域，需要缩小\n//        }\n        /* 计算出缩小后的长宽 */\n        /* 产生Resize后的Bitmap对象 */\n        Matrix matrix = new Matrix();\n//       计算缩放率，新尺寸除原始尺寸\n        float scaleWidth = ((float) sideLength) / bmpWidth;\n        float scaleHeight = ((float) sideLength) / bmpHeight;\n        matrix.postScale(scaleWidth, scaleHeight);//设置缩放率，\n        Bitmap resizeBmp = Bitmap.createBitmap(bitmap, 0, 0, bmpWidth, bmpHeight,\n                matrix, true);//根据原图片和缩放大小，生成一张新的图片,这样图片的大小刚好与矩形区域是一致的</pre>\n<br> \n<br> \n<p></p>',NULL,'xingxing','2014-07-23 10:18:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/38059275','android tv',10),
	(35,'android canvas.drawBitmap的理解','<p><strong><span style=\"font-size:18px\">public void drawBitmap(android.graphics.Bitmap bitmap, float left, float top, android.graphics.Paint paint)</span></strong></p> \n<p><strong><span style=\"font-size:18px\">这个方法left,top指的是bitmap放置的左上方的坐标。是相对于屏幕整体来说的坐标位置。</span></strong></p> \n<p><span style=\"font-size:18px\"><strong>//以下部分转自<a target=\"_blank\" href=\"http://blog.csdn.net/zgf1991/article/details/7315281\">http://blog.csdn.net/zgf1991/article/details/7315281</a></strong></span></p> \n<p><strong><span style=\"font-size:18px\">public static void drawImage(Canvas canvas, Bitmap blt, int x, int y, int w, int h, int bx, int by) &nbsp;<br> &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //x,y表示绘画的起点， &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; Rect src = new Rect();// 图片 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; Rect dst = new Rect();// 屏幕 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; //src 这个是表示绘画图片的大小 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; src.left = bx; &nbsp; //0,0 &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; src.top = by; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; src.right = bx + w;// mBitDestTop.getWidth();,这个是桌面图的宽度， &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; src.bottom = by + h;//mBitDestTop.getHeight()/2;// 这个是桌面图的高度的一半 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; // 下面的 dst 是表示 绘画这个图片的位置 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; dst.left = x; &nbsp; //miDTX,//这个是可以改变的，也就是绘图的起点X位置 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; dst.top = y; &nbsp; &nbsp;//mBitQQ.getHeight();//这个是QQ图片的高度。 也就相当于 桌面图片绘画起点的Y坐标 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; dst.right = x + w; &nbsp;//miDTX + mBitDestTop.getWidth();// 表示需绘画的图片的右上角 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; dst.bottom = y + h; // mBitQQ.getHeight() + mBitDestTop.getHeight();//表示需绘画的图片的右下角 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; canvas.drawBitmap(blt, src, dst, null);//这个方法 &nbsp;第一个参数是图片，第二个参数是 绘画该图片需显示多少。也就是说你想绘画该图片的某一些地方，而不是全部图片，第三个参数表示该图片绘画的位置 &nbsp;<br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"font-size:18px\"><strong>&nbsp;canvas.drawBitmap(blt, src, dst, null);</strong></span><br> </span></strong></p> \n<p><span style=\"font-weight:bold\"><span style=\"font-size:18px\"><span style=\"font-size:18px\"><strong>一般情况下来说，src这个矩形区域可以设置为(0,0,bmp.getWidth(),bmp.getHeight());一般就这样设置就可以了，当初在项目中设置的src,dst都是完全一样的，导致四个<span style=\"font-size:18px\"><strong>drawBitmap只显示了一个，根据上文的理解，就明白了。</strong></span></strong></span></span></span></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p>',NULL,'xingxing','2014-07-23 10:03:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/38058659','android tv',10),
	(36,'android tv开发碰到的坑儿----第一篇','<p><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>记录时间为2014年7月21，这些问题发生于7.5到7.20之间</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>问题1：</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>gridview焦点问题，用gridview主要是想实现9宫格的布局风格，但是电视应用上会出现问题，没有办法填充整个屏幕，之后采用的是layout-weight权重分配的方式，解决的问题，还有onitemClick{}获取焦点的问题，暂时先记录一下问题，留待以后仔细探讨。</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>问题2：</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>用surfaceview实现画图效果，画的是动态可以随时改变的图形，（当然view也可以），implement callback runnable ,对于其原理还不是了解，现在只能仿着例子来写。</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>问题3：</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>图片效果，imageView中的android:scaleType属性的作用，对于这个属性的各个值需要了解其区别在哪</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>问题4:</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>自定义view实现的一些效果，好好体会一下，android canvas的处理过程，并贴出自己所做的一些简单的效果</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>问题5：</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>自定义view的竖排字体的显示，对齐问题，主要是由字体造成的，换成微软雅黑看起来就没有问题了，相对来说没有弯曲。</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>问题6：<span style=\"white-space:pre\"> </span></span></strong></p> \n<p><span style=\"font-weight:bold; white-space:pre\"></span><span style=\"font-size:18px\"><strong>色彩滑动效果，想要实现色彩谱图的效果，并且还要有滑动，滚动的效果，目前做出来的只是简单的，并不是设计人员需要的，以后完善</strong></span></p> \n<p><span style=\"font-size:18px\"><strong><span style=\"white-space:pre\"></span>问题7：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong><span style=\"white-space:pre\"></span>自定义view在xml文件中的显示，加载xml的原理，机制，需要理解android是怎么处理view的显示的，内部做了哪些事情</strong></span></p> \n<p><span style=\"font-size:18px\"><strong><span style=\"white-space:pre\"></span>问题8：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong><span style=\"white-space:pre\"></span>view的生命周期，处理过程（跟7类似）</strong></span></p> \n<p><span style=\"font-size:18px\"><strong><span style=\"white-space:pre\"></span>问题9：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong><span style=\"white-space:pre\"></span>按键key的处理流程，tv开发，主要都是键盘事件，需要好好理解一下，系统的处理过程，还有就是view的监听，activity,焦点的问题，都需要理清楚</strong></span></p> \n<p><span style=\"font-size:18px\"><strong><span style=\"white-space:pre\"></span>问题10：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong><span style=\"white-space:pre\"></span>动画效果，和前面说的某一点比较像，一遍画线，一遍移动它，做显示，这个效果一直做不出来，伤不起啊</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>问题11：handle.post方法，以前没有深入理解，现在需要抽出时间，仔细去体会他的处理过程，跟普通的子线程，传递消息的区别</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>先留下这么多的坑，有时间来填。。。</strong></span></p> \n<p><span style=\"white-space:pre\"></span></p>',NULL,'xingxing','2014-07-21 20:37:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/38023479','android tv',10),
	(37,'centos上mysql CannotCreateTransactionException分析','<p>先大致介绍下背景：</p><p>个人博客项目用的是ssm框架搭建的，阿里云主机（centos），mysql数据库。</p><p>开发环境是在mac下面</p><p>本来项目开发完毕了，本地也跑了很多回了，项目前天都上线了（现在过了12点了，又是新的一天了^_^）。</p><p>spring配置文件里面的数据源配置信息如下：</p><pre class=\"brush:xml;toolbar:false\">&lt;bean&nbsp;id=&quot;dataSource&quot;&nbsp;class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;\r\n		&lt;property&nbsp;name=&quot;driverClassName&quot;&nbsp;value=&quot;com.mysql.jdbc.Driver&quot;&nbsp;/&gt;\r\n		&lt;property&nbsp;name=&quot;url&quot;&nbsp;value=&quot;jdbc:mysql://127.0.0.1:3306/xxxblogs&quot;&nbsp;/&gt;\r\n		&lt;property&nbsp;name=&quot;username&quot;&nbsp;value=&quot;root&quot;&nbsp;/&gt;\r\n		&lt;property&nbsp;name=&quot;password&quot;&nbsp;value=&quot;root&quot;&nbsp;/&gt;\r\n		&lt;!--&nbsp;初始化连接大小&nbsp;--&gt;\r\n		&lt;property&nbsp;name=&quot;initialSize&quot;&nbsp;value=&quot;10&quot;&nbsp;/&gt;\r\n		&lt;!--&nbsp;连接池最大使用连接数量&nbsp;--&gt;\r\n		&lt;property&nbsp;name=&quot;maxActive&quot;&nbsp;value=&quot;40&quot;&nbsp;/&gt;\r\n		&lt;!--&nbsp;连接池最大空闲&nbsp;--&gt;\r\n		&lt;property&nbsp;name=&quot;maxIdle&quot;&nbsp;value=&quot;20&quot;&nbsp;/&gt;\r\n		&lt;!--&nbsp;连接池最小空闲&nbsp;--&gt;\r\n		&lt;property&nbsp;name=&quot;minIdle&quot;&nbsp;value=&quot;5&quot;&nbsp;/&gt;\r\n		&lt;!--&nbsp;获取连接最大等待时间&nbsp;--&gt;\r\n		&lt;property&nbsp;name=&quot;maxWait&quot;&nbsp;value=&quot;10000&quot;&nbsp;/&gt;\r\n	&lt;/bean&gt;</pre><p>配置的内容就是这些，但是项目上线之后出现了问题，大概是发版之后，第二天早上观察，怎么出现下面的问题了。</p><p><span style=\"color: rgb(255, 255, 255); font-family: Tahoma, Arial, sans-serif; font-size: 22px; font-weight: bold; background-color: rgb(82, 93, 118);\">HTTP Status 500 - Request processing failed; nested exception is org.springframework.transaction.CannotCreateTransactionException: Could not open JDBC Connection for transaction; nested exception is com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: The last packet successfully received from the server was 90,788,814 milliseconds ago. The last packet sent successfully to the server was 90,788,814 milliseconds ago. is longer than the server configured value of &#39;wait_timeout&#39;. You should consider either expiring and/or testing connection validity before use in your application, increasing the server configured values for client timeouts, or using the Connector/J connection property &#39;autoReconnect=true&#39; to avoid this problem.</span></p><p><br/></p><p>当时也没有想太多的问题，就简单处理了一下。重启了一下tomcat，就好了。</p><p>但是，今天晚上发现，有出现了问题，真是不能忍啊，网上查了不少资料，找到了原因所在，</p><p><span style=\"color: rgb(255, 0, 0);\"><strong>大部分原因是由于数据库回收了连接，而系统的缓冲池不知道，继续使用被回收的连接所致的。</strong></span></p><p>所以先按照以下的方式试下，明天早上再给结果确认。</p><pre class=\"brush:xml;toolbar:false\">&lt;!--&nbsp;#SQL查询,用来验证从连接池取出的连接&nbsp;--&gt;\r\n		&lt;property&nbsp;name=&quot;validationQuery&quot;&nbsp;value=&quot;SELECT&nbsp;1&quot;&nbsp;/&gt;\r\n		&lt;!--&nbsp;#指明连接是否被空闲连接回收器(如果有)进行检验，如果检测失败，则连接将被从池中去除&nbsp;--&gt;\r\n		&lt;property&nbsp;name=&quot;testWhileIdle&quot;&nbsp;value=&quot;true&quot;&nbsp;/&gt;</pre><p>&nbsp;&nbsp;</p><p>之前在公司的项目有出现过类似的情况，服务器上跑的是oracle数据库，本地笔记本配置太低，只有4内存，导致老是</p><p>Could not open JDBC Connection for transaction。但是线上的代码跑的挺好的。</p><p>最后本地开发也是通过这种方式添加验证解决。</p><p><br/></p><p>就先这样^_^...</p>','','xingxing','2015-06-05 00:33:16','xingxing','2015-06-05 00:33:16','','','','mysql相关',21),
	(38,'个人博客项目发版流程介绍','<p>我的博客项目现在部署在阿里云上，系统为centos，之前在mac下也开了个centos虚拟机测试学习了下，最后决定用真正的线上环境来学习下，积累下线上正式发版，处理线上碰到的一堆问题。这里只介绍，项目发版的主要的流程。</p><p>--------------------</p><p>mac下ssh登录，通过iterm2终端等等。（不详细介绍了^_^）</p><p><br/></p><p><span style=\"color: rgb(255, 0, 0);\">发版本的完整流程：</span></p><p><span style=\"color: rgb(255, 0, 0);\">1.停掉tomcat&nbsp;</span></p><p><span style=\"color: rgb(255, 0, 0);\">/usr/java/tomcat7/bin/shutdown.sh</span></p><p><br/></p><p><span style=\"color: rgb(255, 0, 0);\">ls -al /usr/java/tomcat7/webapps</span></p><p><br/></p><p><span style=\"color: rgb(255, 0, 0);\">2.删掉/usr/java/tomcat7/webapps/目录下的war包</span></p><p><span style=\"color: rgb(255, 0, 0);\">rm -rf /usr/java/tomcat7/webapps/xxxblogs*</span></p><p><br/></p><p><span style=\"color: rgb(255, 0, 0);\">3.上传新的版本到这个目录下面</span></p><p><span style=\"color: rgb(255, 0, 0);\">换个命令行执行(mac下)</span></p><p><span style=\"color: rgb(255, 0, 0);\">scp /Users/*/XXX.war root@*****:/usr/java/tomcat7/webapps/</span></p><p><span style=\"color: rgb(255, 0, 0);\">这个地方，修改为要发版的war包路径，以及阿里云的ip地址，tomcat的路径..</span></p><p><br/></p><p><span style=\"color: rgb(255, 0, 0);\">4.重启tomcat：</span></p><p><span style=\"color: rgb(255, 0, 0);\">/usr/java/tomcat7/bin/startup.sh</span></p><p><br/></p><p>--------------------</p><p><br/></p>','','xingxing','2015-06-05 00:45:47','xingxing','2015-06-05 00:45:47','','','','个人博客相关',22),
	(41,'线上图片存放问题','<p><br/></p><p>本项目配置的虚拟路径为</p><p>在server.xml</p><p></p><pre class=\"brush:xml;toolbar:false\">&lt;Context&nbsp;path=&quot;&quot;&nbsp;docBase=&quot;/usr/java/tomcat7/webapps/xxxblogs&quot;&nbsp;reloadable=&quot;false&quot;/&gt;\r\n&lt;Context&nbsp;docBase=&quot;/usr/java/pics&quot;&nbsp;path=&quot;/xxxpics&quot;&nbsp;reloadable=&quot;true&quot;/&gt;</pre><p><span style=\"color: rgb(255, 0, 0);\"></span><br/></p><p>第二行为项目中文章里面的图片的存放目录，以及映射路径，举例来说，通过访问：http://112.74.81.77/xxxpics/****/abc.jpeg的时候，其实访问的是磁盘/usr/java/pics/***/abc.jpeg所在的图片资源。</p><p><br/></p><p>****************************************</p><p>文章编写模块，用的是百度的ueditor插件，图片方面，上传方式是通过controller.jsp的方式上传上去的。</p><p>由于上传后，图片是存放在项目的webapp下的ueditor文件夹里面的目录中，这样，每次重启tomcat，发版本，都会导致图片资源丢失，所以需要将上传的图片复制到对应的磁盘目录下面，通过映射方式，来实现访问，当然这需要同时修改文章里面的图片的url。</p><p><br/></p><p>****************************************</p><p>出现的问题：</p><p>线上代码：</p><p>日志文件查看发现，通过ueditor上传图片，发现如下问题：</p><p>ueditor上传的图片的真实路径/usr/java/tomcat7/webapps/xxxblogs/<span style=\"color: rgb(255, 0, 0);\">http:/112.74.81.77</span>/ueditor/jsp/upload<wbr/>/image/20150606/1433523761980088266.png</p><p>保存到服务器的指定路径/usr/java/pics/upload/image/20150606/1433523761980088266.png</p><p><br/></p><p>ueditor上传后，打印的真实路径怎么会出现url的形式呢，这个问题先记录一下，通过自己对项目的理解，以及测试后发现，/usr/java/tomcat7/webapps/xxxblogs/ueditor/jsp/upload<wbr/>/image/20150606/1433523761980088266.png存在刚刚上传的图片，那么多出来的url，是怎么回事呢，这个还得写测试demo，才能判断。</p><p>写带有图片的博客，目前都是通过ip地址直接访问的，因为暂时没有购买域名，不知道跟着原因，有关没，还有就是本地测试时候，也没有出现过此种问题，线上竟然出现，让人费解，问题留着之后解决吧。</p><p><br/></p><p>********************************************************<br/></p><p>修改于2015-06-12</p><p><br/></p><p>上传图片的错误原因：</p><p>basePath的基本路径为：http://112.74.81.77:80/</p><p>通过程序取得的basePath路径需要处理一下啊，去掉80这个端口称号，不然字符串截取的时候，会导致取出来的临时路径对不上啊</p><p>截取后的临时路径为：http://112.74.81.77/ueditor/jsp/upload/image/20150609/14338569186730250</p><p><br/></p><p>这样截取出来的临时路径是不对的，通过拼接，是无法找到真实的临时路径，通过复制方法，无法把图片存放到本地磁盘的制定路径的。</p><p><br/></p><p>修改Commutil的getBasepath()方法；方法出错在对java基础知识不太关注，调试的时候检查了很久，竟然是由个小问题造成的。</p><p class=\"p1\"><span class=\"s1\">request</span>.getServerPort()的结果是int类型，是不能够通过字符串的方式比较，由于疏忽，调试这个问题，浪费了一晚上。</p><p class=\"p1\">git上提交的差别比较如下：</p><pre class=\"brush:java;toolbar:false\">&nbsp;	&nbsp;*&nbsp;@since&nbsp;2015-06-09&nbsp;若端口号为80，去掉不显示；\r\n&nbsp;	&nbsp;*&nbsp;@return\r\n&nbsp;	&nbsp;*/\r\n-	public&nbsp;static&nbsp;String&nbsp;getBasepath(HttpServletRequest&nbsp;request){\r\n+	public&nbsp;static&nbsp;String&nbsp;getBasepath(HttpServletRequest&nbsp;request)&nbsp;{\r\n&nbsp;		String&nbsp;path&nbsp;=&nbsp;request.getContextPath();\r\n-		String&nbsp;basePath=&quot;&quot;;\r\n-		if(!&quot;80&quot;.equals(request.getServerPort())){\r\n-			basePath&nbsp;=&nbsp;request.getScheme()&nbsp;+&nbsp;&quot;://&quot;\r\n-					+&nbsp;request.getServerName()&nbsp;+&nbsp;&quot;:&quot;&nbsp;+&nbsp;request.getServerPort()\r\n-					+&nbsp;path&nbsp;+&nbsp;&quot;/&quot;;\r\n-		}else&nbsp;if(&quot;80&quot;.equals(request.getServerPort())){\r\n-			basePath&nbsp;=&nbsp;request.getScheme()&nbsp;+&nbsp;&quot;://&quot;\r\n-					+&nbsp;request.getServerName()\r\n+		String&nbsp;basePath&nbsp;=&nbsp;&quot;&quot;;\r\n+		if&nbsp;(80!=request.getServerPort())&nbsp;{\r\n+			basePath&nbsp;=&nbsp;request.getScheme()&nbsp;+&nbsp;&quot;://&quot;&nbsp;+&nbsp;request.getServerName()\r\n+					+&nbsp;&quot;:&quot;&nbsp;+&nbsp;request.getServerPort()&nbsp;+&nbsp;path&nbsp;+&nbsp;&quot;/&quot;;\r\n+		}&nbsp;else&nbsp;if&nbsp;(80==request.getServerPort())&nbsp;{\r\n+			basePath&nbsp;=&nbsp;request.getScheme()&nbsp;+&nbsp;&quot;://&quot;&nbsp;+&nbsp;request.getServerName()\r\n&nbsp;					+&nbsp;path&nbsp;+&nbsp;&quot;/&quot;;\r\n&nbsp;		}\r\n&nbsp;		return&nbsp;basePath;</pre><p><br/></p>','','xingxing','2015-06-09 21:08:11','xingxing','2015-06-12 12:57:02','','','','个人博客相关',22),
	(44,'ssh软件介绍－－第一篇','<p style=\"white-space: normal;\">在window平台下，个人觉得比较好用的ssh软件是ssh secure shell client。</p><p style=\"white-space: normal;\">这里只介绍一下最基本的用法：<br/></p><p style=\"white-space: normal;\">先打开ssh secure file transfer 点击quick connect:</p><p style=\"white-space: normal;\"><img src=\"http://112.74.81.77/xxxpics/upload/image/20150611/1433994256010065117.png\" title=\"1433994256010065117.png\" alt=\"1433994256010065117.png\" width=\"550\" height=\"540\" border=\"0\" vspace=\"0\" style=\"width: 550px; height: 540px;\"/></p><p style=\"white-space: normal;\"><br/></p><p style=\"white-space: normal;\">输入信息之后，点击connect：</p><p style=\"white-space: normal;\">出现如图所示的效果，便是正确的：</p><p style=\"white-space: normal;\"><img src=\"http://112.74.81.77/xxxpics/upload/image/20150611/1433994306053076015.png\" title=\"1433994306053076015.png\" alt=\"1433994306053076015.png\" width=\"600\" height=\"380\" border=\"0\" vspace=\"0\" style=\"width: 600px; height: 380px;\"/></p><p style=\"white-space: normal;\"><br/></p><p style=\"white-space: normal;\">有时候，我们需要使用的终端，只需要点击菜单栏下的一个按钮，即可打开终端，用过命令行的方式，操作centos系统。</p><p style=\"white-space: normal;\">如下图所示：<br/></p><p style=\"white-space: normal;\"><img src=\"http://112.74.81.77/xxxpics/upload/image/20150611/1433994336649040134.png\" title=\"1433994336649040134.png\" alt=\"1433994336649040134.png\" width=\"480\" height=\"380\" border=\"0\" vspace=\"0\" style=\"width: 480px; height: 380px;\"/></p><p style=\"white-space: normal;\">在此终端下，输入命令，即可实现任何想要达到的功能了。</p><p style=\"white-space: normal;\">这里就不在一一介绍了，不得不说，ueditor上传完图片后，图片不好调整大小啊，项目还需要进一步处理啊。</p><p><br/></p>','http://112.74.81.77/ueditor/jsp/upload/image/20150611/1433994256010065117.png,http://112.74.81.77/ueditor/jsp/upload/image/20150611/1433994306053076015.png,http://112.74.81.77/ueditor/jsp/upload/image/20150611/1433994336649040134.png,','xingxing','2015-06-11 11:47:41','xingxing','2015-06-11 11:47:41','http://112.74.81.77/xxxpics/upload/image/20150611/1433994256010065117.png,http://112.74.81.77/xxxpics/upload/image/20150611/1433994306053076015.png,http://112.74.81.77/xxxpics/upload/image/20150611/1433994336649040134.png','/usr/java/pics/upload/image/20150611/1433994256010065117.png,/usr/java/pics/upload/image/20150611/1433994306053076015.png,/usr/java/pics/upload/image/20150611/1433994336649040134.png','','ssh软件相关',23);

/*!40000 ALTER TABLE `tb_article` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table tb_article_l
# ------------------------------------------------------------

DROP TABLE IF EXISTS `tb_article_l`;

CREATE TABLE `tb_article_l` (
  `id` int(11) DEFAULT NULL,
  `title` varchar(256) DEFAULT '' COMMENT '标题',
  `content` text COMMENT '正文内容',
  `pics` varchar(256) DEFAULT '' COMMENT '本地上传图片，ueditor路径',
  `creater` varchar(20) DEFAULT '' COMMENT '创建人',
  `createtime` datetime DEFAULT NULL COMMENT '创建时间',
  `lastmodifier` varchar(20) DEFAULT '' COMMENT '最后修改人',
  `lastmodifytime` datetime DEFAULT NULL COMMENT '最后修改时间',
  `xxxpics` varchar(256) DEFAULT '' COMMENT '最终的图片路径，urls，存放在文章中的路径',
  `xxxrealpathpics` varchar(256) DEFAULT '' COMMENT '在文章中的路径，服务器上的物理路径',
  `fromurl` varchar(256) DEFAULT NULL COMMENT '文章来源',
  `categoryname` varchar(40) DEFAULT NULL COMMENT '类别名称',
  `categoryid` int(11) DEFAULT NULL COMMENT '列别id'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `tb_article_l` WRITE;
/*!40000 ALTER TABLE `tb_article_l` DISABLE KEYS */;

INSERT INTO `tb_article_l` (`id`, `title`, `content`, `pics`, `creater`, `createtime`, `lastmodifier`, `lastmodifytime`, `xxxpics`, `xxxrealpathpics`, `fromurl`, `categoryname`, `categoryid`)
VALUES
	(41,'线上图片存放问题','<p><br/></p><p>本项目配置的虚拟路径为</p><p>在server.xml</p><p>&lt;Context path=&quot;&quot; docBase=&quot;/usr/java/tomcat7/webapps/xxxblogs&quot; reloadable=&quot;false&quot;/&gt;</p><p><span style=\"color: rgb(255, 0, 0);\">&lt;Context docBase=&quot;/usr/java/pics&quot; path=&quot;/xxxpics&quot; reloadable=&quot;true&quot;/&gt;</span></p><p>红色部分为项目中文章里面的图片的存放目录，以及映射路径，举例来说，通过访问：http://112.74.81.77/xxxpics/****/abc.jpeg的时候，其实访问的是磁盘/usr/java/pics/***/abc.jpeg所在的图片资源。</p><p><br/></p><p>****************************************</p><p>文章编写模块，用的是百度的ueditor插件，图片方面，上传方式是通过controller.jsp的方式上传上去的。</p><p>由于上传后，图片是存放在项目的webapp下的ueditor文件夹里面的目录中，这样，每次重启tomcat，发版本，都会导致图片资源丢失，所以需要将上传的图片复制到对应的磁盘目录下面，通过映射方式，来实现访问，当然这需要同时修改文章里面的图片的url。</p><p><br/></p><p>****************************************</p><p>出现的问题：</p><p>线上代码：</p><p>日志文件查看发现，通过ueditor上传图片，发现如下问题：</p><p>ueditor上传的图片的真实路径/usr/java/tomcat7/webapps/xxxblogs/<span style=\"color: rgb(255, 0, 0);\">http:/112.74.81.77</span>/ueditor/jsp/upload/image/20150606/1433523761980088266.png</p><p>保存到服务器的指定路径/usr/java/pics/upload/image/20150606/1433523761980088266.png</p><p><br/></p><p>ueditor上传后，打印的真实路径怎么会出现url的形式呢，这个问题先记录一下，通过自己对项目的理解，以及测试后发现，/usr/java/tomcat7/webapps/xxxblogs/ueditor/jsp/upload/image/20150606/1433523761980088266.png存在刚刚上传的图片，那么多出来的url，是怎么回事呢，这个还得写测试demo，才能判断。</p><p>写带有图片的博客，目前都是通过ip地址直接访问的，因为暂时没有购买域名，不知道跟着原因，有关没，还有就是本地测试时候，也没有出现过此种问题，线上竟然出现，让人费解，问题留着之后解决吧。</p><p><br/></p><p><br/></p><p><br/></p>','','xingxing','2015-06-09 21:08:11','xingxing','2015-06-09 21:08:11','','','','个人博客相关',22),
	(41,'线上图片存放问题','<p><br/></p><p>本项目配置的虚拟路径为</p><p>在server.xml</p><p>&lt;Context path=&quot;&quot; docBase=&quot;/usr/java/tomcat7/webapps/xxxblogs&quot; reloadable=&quot;false&quot;/&gt;</p><p><span style=\"color: rgb(255, 0, 0);\">&lt;Context docBase=&quot;/usr/java/pics&quot; path=&quot;/xxxpics&quot; reloadable=&quot;true&quot;/&gt;</span></p><p>红色部分为项目中文章里面的图片的存放目录，以及映射路径，举例来说，通过访问：http://112.74.81.77/xxxpics/****/abc.jpeg的时候，其实访问的是磁盘/usr/java/pics/***/abc.jpeg所在的图片资源。</p><p><br/></p><p>****************************************</p><p>文章编写模块，用的是百度的ueditor插件，图片方面，上传方式是通过controller.jsp的方式上传上去的。</p><p>由于上传后，图片是存放在项目的webapp下的ueditor文件夹里面的目录中，这样，每次重启tomcat，发版本，都会导致图片资源丢失，所以需要将上传的图片复制到对应的磁盘目录下面，通过映射方式，来实现访问，当然这需要同时修改文章里面的图片的url。</p><p><br/></p><p>****************************************</p><p>出现的问题：</p><p>线上代码：</p><p>日志文件查看发现，通过ueditor上传图片，发现如下问题：</p><p>ueditor上传的图片的真实路径/usr/java/tomcat7/webapps/xxxblogs/<span style=\"color: rgb(255, 0, 0);\">http:/112.74.81.77</span>/ueditor/jsp/upload<wbr/>/image/20150606/1433523761980088266.png</p><p>保存到服务器的指定路径/usr/java/pics/upload/image/20150606/1433523761980088266.png</p><p><br/></p><p>ueditor上传后，打印的真实路径怎么会出现url的形式呢，这个问题先记录一下，通过自己对项目的理解，以及测试后发现，/usr/java/tomcat7/webapps/xxxblogs/ueditor/jsp/upload<wbr/>/image/20150606/1433523761980088266.png存在刚刚上传的图片，那么多出来的url，是怎么回事呢，这个还得写测试demo，才能判断。</p><p>写带有图片的博客，目前都是通过ip地址直接访问的，因为暂时没有购买域名，不知道跟着原因，有关没，还有就是本地测试时候，也没有出现过此种问题，线上竟然出现，让人费解，问题留着之后解决吧。</p><p><br/></p><p>********************************************************<br/></p><p>修改于2015-06-12</p><p><br/></p><p>上传图片的错误原因：</p><p>basePath的基本路径为：http://112.74.81.77:80/</p><p>通过程序取得的basePath路径需要处理一下啊，去掉80这个端口称号，不然字符串截取的时候，会导致取出来的临时路径对不上啊</p><p>截取后的临时路径为：http://112.74.81.77/ueditor/jsp/upload/image/20150609/14338569186730250</p><p><br/></p><p>这样截取出来的临时路径是不对的，通过拼接，是无法找到真实的临时路径，通过复制方法，无法把图片存放到本地磁盘的制定路径的。</p><p><br/></p><p>修改Commutil的getBasepath()方法；方法出错在对java基础知识不太关注，调试的时候检查了很久，竟然是由个小问题造成的。</p><p class=\"p1\"><span class=\"s1\">request</span>.getServerPort()的结果是int类型，是不能够通过字符串的方式比较，由于疏忽，调试这个问题，浪费了一晚上。</p><p class=\"p1\">git上提交的差别比较如下：</p><pre class=\"brush:java;toolbar:false\">&nbsp;	&nbsp;*&nbsp;@since&nbsp;2015-06-09&nbsp;若端口号为80，去掉不显示；\r\n&nbsp;	&nbsp;*&nbsp;@return\r\n&nbsp;	&nbsp;*/\r\n-	public&nbsp;static&nbsp;String&nbsp;getBasepath(HttpServletRequest&nbsp;request){\r\n+	public&nbsp;static&nbsp;String&nbsp;getBasepath(HttpServletRequest&nbsp;request)&nbsp;{\r\n&nbsp;		String&nbsp;path&nbsp;=&nbsp;request.getContextPath();\r\n-		String&nbsp;basePath=&quot;&quot;;\r\n-		if(!&quot;80&quot;.equals(request.getServerPort())){\r\n-			basePath&nbsp;=&nbsp;request.getScheme()&nbsp;+&nbsp;&quot;://&quot;\r\n-					+&nbsp;request.getServerName()&nbsp;+&nbsp;&quot;:&quot;&nbsp;+&nbsp;request.getServerPort()\r\n-					+&nbsp;path&nbsp;+&nbsp;&quot;/&quot;;\r\n-		}else&nbsp;if(&quot;80&quot;.equals(request.getServerPort())){\r\n-			basePath&nbsp;=&nbsp;request.getScheme()&nbsp;+&nbsp;&quot;://&quot;\r\n-					+&nbsp;request.getServerName()\r\n+		String&nbsp;basePath&nbsp;=&nbsp;&quot;&quot;;\r\n+		if&nbsp;(80!=request.getServerPort())&nbsp;{\r\n+			basePath&nbsp;=&nbsp;request.getScheme()&nbsp;+&nbsp;&quot;://&quot;&nbsp;+&nbsp;request.getServerName()\r\n+					+&nbsp;&quot;:&quot;&nbsp;+&nbsp;request.getServerPort()&nbsp;+&nbsp;path&nbsp;+&nbsp;&quot;/&quot;;\r\n+		}&nbsp;else&nbsp;if&nbsp;(80==request.getServerPort())&nbsp;{\r\n+			basePath&nbsp;=&nbsp;request.getScheme()&nbsp;+&nbsp;&quot;://&quot;&nbsp;+&nbsp;request.getServerName()\r\n&nbsp;					+&nbsp;path&nbsp;+&nbsp;&quot;/&quot;;\r\n&nbsp;		}\r\n&nbsp;		return&nbsp;basePath;</pre><p><br/></p>','','xingxing','2015-06-09 21:08:11','xingxing','2015-06-12 12:22:50','','','','个人博客相关',22);

/*!40000 ALTER TABLE `tb_article_l` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table tb_category
# ------------------------------------------------------------

DROP TABLE IF EXISTS `tb_category`;

CREATE TABLE `tb_category` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `categoryname` varchar(30) DEFAULT '' COMMENT '类别名称',
  `articlecount` int(11) DEFAULT NULL COMMENT '统计文章的篇数',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='文章信息表';

LOCK TABLES `tb_category` WRITE;
/*!40000 ALTER TABLE `tb_category` DISABLE KEYS */;

INSERT INTO `tb_category` (`id`, `categoryname`, `articlecount`)
VALUES
	(1,'java基础',1),
	(2,'ssh常见问题',1),
	(3,'php',2),
	(4,'职业生涯',1),
	(5,'感悟',2),
	(6,'杂项',1),
	(7,'android',7),
	(8,'算法',15),
	(9,'java插件',1),
	(10,'android tv',7),
	(21,'mysql相关',2),
	(22,'个人博客相关',3),
	(23,'ssh软件相关',5);

/*!40000 ALTER TABLE `tb_category` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table tb_category_l
# ------------------------------------------------------------

DROP TABLE IF EXISTS `tb_category_l`;

CREATE TABLE `tb_category_l` (
  `id` int(11) NOT NULL COMMENT '主键',
  `categoryname` varchar(30) DEFAULT '' COMMENT '类别名称',
  `articlecount` int(11) DEFAULT NULL COMMENT '统计文章的篇数'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;



# Dump of table tb_csdn_article
# ------------------------------------------------------------

DROP TABLE IF EXISTS `tb_csdn_article`;

CREATE TABLE `tb_csdn_article` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `title` varchar(256) DEFAULT '' COMMENT '标题',
  `content` text COMMENT '正文内容',
  `pics` varchar(256) DEFAULT '' COMMENT '本地上传图片，ueditor路径',
  `creater` varchar(20) DEFAULT '' COMMENT '创建人',
  `createtime` datetime DEFAULT NULL COMMENT '创建时间',
  `lastmodifier` varchar(20) DEFAULT '' COMMENT '最后修改人',
  `lastmodifytime` datetime DEFAULT NULL COMMENT '最后修改时间',
  `xxxpics` varchar(256) DEFAULT '' COMMENT '最终的图片路径，urls，存放在文章中的路径',
  `xxxrealpathpics` varchar(256) DEFAULT '' COMMENT '在文章中的路径，服务器上的物理路径',
  `fromurl` varchar(256) DEFAULT NULL COMMENT '文章同步来源',
  `categoryname` varchar(40) DEFAULT NULL COMMENT '类别名称',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='文章信息表';

LOCK TABLES `tb_csdn_article` WRITE;
/*!40000 ALTER TABLE `tb_csdn_article` DISABLE KEYS */;

INSERT INTO `tb_csdn_article` (`id`, `title`, `content`, `pics`, `creater`, `createtime`, `lastmodifier`, `lastmodifytime`, `xxxpics`, `xxxrealpathpics`, `fromurl`, `categoryname`)
VALUES
	(1,'ssh常见错误一(result \'null\' not found)小结','<p><span style=\"color:#ff0000\">问题描述：</span></p> \n<p><span style=\"white-space:pre\"></span><span style=\"color:#ff0000\">如图所示：</span></p> \n<p><img src=\"http://img.blog.csdn.net/20140319124721953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHh4ODIzOTUyMzc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br> </p> \n<p><span style=\"white-space:pre\"></span><strong><span style=\"font-size:18px; color:#ff0000\">当我在第2页编辑学号为11的学生后，修改学生的信息，然后保存。处理过程如下：</span></strong></p> \n<p><img src=\"http://img.blog.csdn.net/20140319125007406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHh4ODIzOTUyMzc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br> </p> \n<p><span style=\"font-size:18px; color:#ff0000\">按修改后希望跳转回第2页。</span></p> \n<p><img src=\"http://img.blog.csdn.net/20140319125259531?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHh4ODIzOTUyMzc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br> </p> \n<p><span style=\"white-space:pre\"></span>以上便是我需要达到的效果：</p> \n<p><span style=\"white-space:pre\"></span>在实现过程中出现了一些错误，<span style=\"font-size:24px; color:#ff0000\">404 - result \'null\' not found，</span></p> \n<p><span style=\"white-space:pre\"></span>根据在网上所查的资料，发现时struts.xml配置文件里面有错误。</p> \n<p></p>\n<pre code_snippet_id=\"244961\" snippet_file_name=\"blog_20140319_1_1583463\" name=\"code\" class=\"html\"><span style=\"white-space:pre\">	</span>&lt;action name=\"student\" class=\"com.xxx.action.StudentAction\"&gt;\n	<span style=\"white-space:pre\">	</span>&lt;!-- 显示学生信息--&gt;\n	<span style=\"white-space:pre\">	</span>&lt;result name=\"show\"&gt;/show.jsp&lt;/result&gt;\n	<span style=\"white-space:pre\">	</span>&lt;!--准备修改学生信息--&gt;\n	<span style=\"white-space:pre\">	</span>&lt;result name=\"edit\"&gt;/update.jsp&lt;/result&gt;\n	<span style=\"white-space:pre\">	</span>&lt;!-- 修改学生信息--&gt;\n	<span style=\"white-space:pre\">	</span>&lt;result name=\"update\" <span style=\"color:#ff0000;\">type=\"redirectAction\"</span>&gt;\n	<span style=\"white-space:pre\">	</span>	&lt;param name=\"actionName\"&gt;student!show.action&lt;/param&gt;  \n        <span style=\"white-space:pre\">		</span>&lt;param name=\"currentPage\"&gt;${currentPage}&lt;/param&gt;\n	<span style=\"white-space:pre\">	</span>&lt;/result&gt;\n	<span style=\"white-space:pre\">	</span>&lt;result name=\"error\"&gt;/error.jsp&lt;/result&gt;\n&lt;/action&gt;</pre>上面的是修改正确的文件。\n<br> \n<br> \n<p></p> \n<p>type=\"redirectAction是配置的关键信息 ，若没有它变会出现<span style=\"color:rgb(255,0,0); font-size:24px\">404 - result \'null\' not found错误</span><br> </p> \n<p>下面是去掉type=\"redirectAction的显示结果。&nbsp;<img src=\"http://img.blog.csdn.net/20140319130324546?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHh4ODIzOTUyMzc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p> \n<p><br> </p> \n<p>具体内容，请下载</p> \n<p><span style=\"font-size:18px; color:#ff0000\">http://download.csdn.net/detail/xxx823952375/7065709</span><br> </p> \n<p><span style=\"font-size:18px; color:#ff0000\"><br> </span></p> \n<p><span style=\"font-size:18px; color:#ff0000\"><br> </span></p>',NULL,NULL,'2014-03-19 16:28:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/21517563','ssh常见问题'),
	(2,'服务器安装PHP扩展:curl问题解决办法(针对Wampserver2.4-x86)','<p><strong><span style=\"font-size:14px\">本人使用的是<span style=\"color:#ff0000\">Wampserver2.4-x86.exe</span>这个软件来搭建的php环境。因此解决办法仅适用于这种情况下的...................</span></strong></p> \n<p><strong><span style=\"font-size:14px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:14px\">在网上搜集了一些方案，来解决这个问题，发现诸多方案并不适合。</span></strong></p> \n<p><strong><span style=\"font-size:14px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:14px\">类似于下面的方案：</span></strong></p> \n<p><span style=\"font-size:24px; color:#ff0000; background-color:rgb(255,255,255)\">两种办法：<br> 1.如果在php安装路径的ext目录下已经有了php_curl.dll，那么在php.ini中找到extension=php_curl.dll并去掉注释,改成extension_dir=d:\\php\\ext(假设ext路径是d:\\php\\ext)；将php_curl.dll，libeay32.dll， ssleay32.dll， php5ts.dll和php.ini拷贝到system32下，重启apache。<br> 2.确保php的目录下面存在ssleay32.dll和libeay32.dll，在apache的httpd.conf的中添加下边两条：<br> LoadFile \"D:/webserver/php/ssleay32.dll\"&nbsp;<br> LoadFile \"D:/webserver/php/libeay32.dll\"<br> 然后重启一下apache。</span><br> </p> \n<p><br> </p> \n<p><br> </p> \n<p><strong><span style=\"font-size:14px\">这两种方法都不适合我所碰到的问题。以上两种方法都亲自测试过。。</span></strong></p> \n<p><strong><span style=\"font-size:14px\">所碰到的问题就是下图中的红色部分。。。</span></strong></p> \n<p><img src=\"http://img.blog.csdn.net/20140416105336937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHh4ODIzOTUyMzc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br> </p> \n<p><strong><span style=\"font-size:14px\">最后找到的解决办法竟然在wamp自身所带的工具上。太坑了吧。。。。。。。。。。。。。</span></strong></p> \n<p>&nbsp; &nbsp; &nbsp;<img src=\"http://img.blog.csdn.net/20140416105412687?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHh4ODIzOTUyMzc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\">&nbsp; &nbsp; &nbsp;&nbsp;</p> \n<p>选择php，会级联出红色箭头上的php extensions</p> \n<p>&nbsp; &nbsp;&nbsp;<img src=\"http://img.blog.csdn.net/20140416105501656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHh4ODIzOTUyMzc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p> \n<p>接着会出现一堆的扩展模块。。。</p> \n<p><img src=\"http://img.blog.csdn.net/20140416105531031?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHh4ODIzOTUyMzc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br> </p> \n<p><strong><span style=\"font-size:14px\">选中红圈中的php_curl即可。</span></strong></p> \n<p><strong><span style=\"font-size:14px\">接着会重启服务。再次安装项目，向导提示如下图。</span></strong></p> \n<p><img src=\"http://img.blog.csdn.net/20140416105617500?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHh4ODIzOTUyMzc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br> </p> \n<p><strong><span style=\"font-size:14px\">终于成功了。。实在是难得啊。。。。。。。。。。。。。</span></strong></p> \n<p><strong><span style=\"font-size:14px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:14px\">之前还碰到了其他的问题。最开始的时候采用的是appserv-win32-2.5.10.exe这个安装套件搭建的php环境，以前一直都是使用它作为php环境搭建的首选。</span></strong></p> \n<p><strong><span style=\"font-size:14px\">在做android端通过api取得它的授权时，一直出错。。。报的错误又是一堆编码。。。</span></strong></p> \n<p><strong><span style=\"font-size:14px\">最后进入php服务器端项目源代码，终于找到错误的原因了，你妹的，这不是逗我玩吗。。。。。。。。。</span></strong></p> \n<p><strong><span style=\"font-size:14px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:14px\"><span style=\"white-space:pre\"></span>if(!function_exists(\'mcrypt_module_open\')){<br> <span style=\"white-space:pre\"></span>$message[\'message\'] = \'服务器错误:缺少加密扩展mcrypt\';<br> <span style=\"white-space:pre\"></span>$message[\'code\'] &nbsp; &nbsp;= \'00000\';<br> <span style=\"white-space:pre\"></span>exit( json_encode( $message ) );<br> <span style=\"white-space:pre\"></span>}<br> </span></strong></p> \n<p><strong><span style=\"font-size:14px\">竟然是缺少加密扩展库。。服务器没有启用此项功能。。。。。。。。。。</span></strong></p> \n<p><strong><span style=\"font-size:14px\">更坑的是网上的一些教程，方案都对启用mcrypt库无效啊。。。。或许是appserv-win32-2.5.10.exe这个套件的原因吧。。。</span></strong></p> \n<p><strong><span style=\"font-size:14px\">真是各种坑，不得不吐槽，程序员太伤不起了。。。。。。。。。。。</span></strong></p> \n<p><strong><span style=\"font-size:14px\"><br> </span></strong></p> \n<p><br> </p> \n<p><br> </p>',NULL,NULL,'2014-04-16 10:57:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/23825453','php'),
	(3,'WAMP安装教程','<strong><span style=\"font-size:18px\">WAMP安装好后，mysql教程密码是为空的，那么要如何修改呢？其实很简单，通过几条指令就行了，下面我就一步步来操作。<br> <br> <br> 　　首先，通过WAMP打开mysql控制台。<br> <br> <br> 　　提示输入密码，因为现在是空，所以直接按回车。<br> <br> <br> 　　然后输入“use mysql”，意思是使用mysql这个数据库教程，提示“Database changed”就行。<br> <br> <br> 　　然后输入要修改的密码的sql语句“update user set password=PASSWORD(\'hooray\') where user=\'root\';”，注意，sql语句结尾的分号不能少，提示什么什么OK就行了。<br> <br> <br> 　　最后输入“flush privileges;”，不输入这个的话，修改密码的操作不会生效的。<br> <br> <br> 　　然后输入“quit”退出。<br> <br> <br> 　　另外，很多人说通过php教程myadmin直接修改mysql表里的密码就行，原理上应该是没错，但是我发现修改后mysql整个库都不见了，害的我重装了WAMP，最终还是通过命令行去修改的。<br> <br> <br> <br> <br> 原文出自【比特网】，转载请保留原文链接：http://soft.chinabyte.com/database/466/12132466.shtml</span></strong>',NULL,NULL,'2014-04-15 21:11:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/23787489','php'),
	(4,'我的2013---程序员的奋斗历程','<p>&nbsp;&nbsp; 写这篇文章，算是对自己这一年进行一个总结吧，不然会觉得不自在的。</p> \n<p>&nbsp;&nbsp;&nbsp;年初的时候，那时候我还只能算是一个大二的学生，在学校呆了一年半了，但我一直都知道要奋斗，努力，利用好一点一滴的时间来学习，提升自己。正月初6,7开始就呆在家里，练习编程，从学校回到家里的时候带了两本书，和我的笔记本，在这里还是介绍一下书的名字，是李兴华的&lt;&lt;java开发实战经典&gt;&gt;和&lt;&lt;javaweb开发实战经典基础篇&gt;&gt;，这不算是打广告，这两本书都还不错。对我个人自学编程起着很大的作用。在家里一边看视频，一边用editplus敲java程序，用命令行体验最基本的编译，运行过程。在家里学习李兴华的书的时候，已经算是我第三遍学习java了，之前的一些书的内容不全，不够详尽，写起程序来，不好理解，也不能有很好的侧重点，不利于快速入门。特别是我学习jsp，servlet的时候，身边没有好的书，程序出现问题了真是不好解决，也是由于前面的基础不够扎实，在买了javaweb开发实战经典基础篇后感觉到了，很有用，讲的都有针对性。最后才买的java开发实战经典，重温一遍，打牢基础。这算是简单介绍我大二上的学习过程吧。在家里的那段时间很短，只有一个月左右的时间，对于我当初的目标任务而言，感觉时间还是有点紧张的，不够用。我当初的任务是重新复习一遍java基础知识，然后再把大二上学习的jsp，servlet回顾一下，体会mvc分层思想。所以个人觉得任务量还是不少的。不过正月6,7号的时候java基础已经算是基本复习了一遍了，自然还是有侧重点，主要是以面向对象，io，集合框架，jdbc为主，其他的也都大致回顾了一下，如java的其他常用类库,SimpleDateFormat,StringBuffer等一些常用的东西，还有枚举类型，反射，注解，java6的一些新特性。之后的几天就是开始复习jsp,还有jdom,dom4j等一些常用的第三方jar包的使用，jsp的常用内置对象，servlet，filter,不断练习李兴华书中的一些比较有针对性的小案例，如一个简单的用户注册例子，还有session的一些使用地方，filter的使用环境，都算是很好的东西。然后就是体会web开发中的分层思想mvc，jsp做页面展示，servlet负责控制跳转，javaben处理一些简单的业务操作。这就是年初的学习经历了。</p> \n<p>&nbsp;&nbsp; 之后返回学校了，开始新一年的学习，对于学校安排的课程我真是很不满意，有数据结构c++版，计算机组成，工程经济学，软件工程，软件工程导论，很多都还是打酱油的课程，除了计算机组成的老师讲的还好外，其他的都只能算是一般般，我还是按照我自己的学习任务进行着，当初计划大二下和暑假学完三大框架的，一直都想通过做点实际的东西，来锻炼自己，但是一直感觉自己还有太多的东西不会，只能赶着时间，先学完这些东西，再来做实际的东西，现在看来，这完全是不好的，不过对于那时候的我来说，也一直是以打好基础为主，对于struts2这个框架，如果不能够很好的知道他是用来干嘛的，该怎么用，它的大致处理流程，我是不会加快进度学习下一个框架的，还是得一步一步的来，平常白天就正常上课，没课的时候赶紧完成老师的任务，晚上的时间基本上就用来练习编程，，学习的过程中碰到了太多的问题，烦恼，让我很苦恼，比如说，在搭建struts2环境的过程中，有几次本来已经配置好了，也能正常访问，但是等我下一次打开电脑重新部署访问，就会出现错误，404，弄的我都很莫名奇妙的，只好在重头搭建环境，对于有的问题，通过对于还是可以解决的，也能够知道问题所在，但是想这种邪门的问题，我只能呵呵一下，复制一下项目，重头改一遍，慢慢就好了。学了一段时间对struts2也算是有所体会了，知道它是将请求和响应分离，达到分层处理。不过那个时候的认识还是不深，没有做过什么有实际意义的项目，倒是做过一个企业门户网站，不过业务简单，界面也弄的一般，只能算是拿来练手，处理起来一点都不正规，使用框架就发现一个问题，用框架开发，效率真的是很慢，当然很大一部分原因是由于我还不太熟练。之后陆陆续续的学习了hibernate，开始学习的时候觉得很爽，这个框架真的很好很强大，我再也不用写繁琐的jdbc操作代码了。不用每次都要打开一个connection，创建一个statement,然后来执行查询，或者是插入更新操作，不用要自己手动来取数据，rs.getstring(\'\')，关闭连接等一系列繁琐的事。这个框架真的很爽。他通过反射机制，还有一些其他的操作帮助我们处理这些重复的任务。基础掌握好了，对这个框架就了解的比较清楚了。当然了对于他的关联关系，这个地方还真是个烦恼的事。估计还是由于缺乏真实的项目经验吧，对于怎么处理好，怎么映射还需要不断的学习。之后就是spring了，感觉spring做的比较好的就是ioc，和aop，一般情况下我就是使用ioc处理类之间的管理，用aop处理事务。对于spring的理解，就是觉得它在减轻开发者的任务量，竟可能的让其他框架无缝整合到一起。这只是本人的观点，本人的水准有限。大二下半年就做了这些事情，学习上也没有耽误，还参加了程序员考试，最后也还拿到了证书。</p> \n<p>之后就是暑假了，暑假在学校呆了一个月吧，练习编程，当初设想的是利用暑假做几个简单点的项目，来熟悉三大框架的整合使用情况，最后并没有达到理想的目标，暑假的那段时间是在是太热了，就只坚持了一个月，就回家了。在学校里，跟自己的一个好朋友，每天带上电脑自习，一天就7,8个小时的学习时间吧，来练习，积累实际经验，晚上回来就去跑步，锻炼一下身体，之后就打打dota，一起开心一下，在学校的时间里，一共练习了两个小项目，收获并不大，在此期间，又从新回顾了所学的知识，东西是在是太多了，一不小心就忘的差不多了。整体感觉来说，还算是不错的。之后就回家了，在家里把java的swing那块给重温了一遍，之前学习的时候没有侧重学习，还学习了一下php的开发，学了一周吧，算是简单上手了，发现自己这人是在是太浮躁了，什么都学，不好。还是决定安心弄java。</p> \n<p>暑假之后，便是大三了啊，想想就感到压力山大，得继续努力啊，开学第一周做了简单的计算器，然后就将这个程序打包,用exe4j和Inno Setup 5将这个jar包弄成可以安装的exe程序，虽然程序不复杂，但是感觉将其打包成可以安装的还是觉得有点厉害的样子。接下来的时间主要是准备软件设计师考试，还有我在学校申请的一个创新训练项目，在此期间，学到了不少东西，虽然东西目前都还做的不让我满意，但是我学到了不少开发中的经验，对于数据库的设计真的很重要，本人数据库被我重新修改了2,3次，还有hibernate的使用细节真是多，对于如何用好它，我还需要努力研究，总之，在这个阶段，收获良多，也体会到设计好了，其他的编码真的不是太大的问题，当然我学长跟我说的是架构好了，其他的都不难，本人目前还没有体会到。</p> \n<p>以上就是本人这一年来的奋斗过程，在这一年里学到了很多，也越来越不甘只做一个程序员，我想要走的更远。学海无涯，希望能与志同道合的人相互交流共同进步吧，对于明年，目前是希望能够找个实习单位，体验一下，实际工作中是如何开发，做项目的。积累一下经验吧，学习上，在看看linux，andriod。希望明年能做的更好。</p>',NULL,NULL,'2013-12-29 14:35:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/17653095','感悟'),
	(5,'时间飞逝——大三感悟','<p><span style=\"white-space:pre\"></span>时间过的很快，一晃我都从大一的新生变成的将要离开学校的程序员，想想就不得不感慨啊，自从选择了计算机这个破专业，每天对着的都是电脑，本来就内向的性格弄的更内向了，记得还是从大二开始，逛逛csdn的，平常碰到问题，一百度，答案大多都来自于csdn，cnblog,iteye，不过那时候还不知道cnblog,iteye是神马东东，说来真是惭愧。在网上也算是见识到了不少强人，知道了我还很渺小，人啊不能坐井观天，需要多逛逛出名点儿的论坛，增加自己的见识，平常逛论坛，都是潜水般的存在，既不灌水，也不骗经验，对那些没太大兴趣，到了现在，觉得自己主要的问题就是性格上的，也想通过一些途径，来改变一下，这样才能较好的适应社会的需求，而且最近也深受一些想法的影响，我应该主动起来，所以我写下了在csdn上的第一篇文章，以前有过想写文章的想法，不过一直都没有落实，出于各种原因吧，当然并不是说本人懒哦，由于本人是程序员，对于文字表达的能力还有待加强，希望看我文章的道友们不要介意，我还需要努力。</p> \n<p><span style=\"white-space:pre\"></span>从这篇文章开始，算是给自己定个小目标吧，我不希望自己大学四年都没有实质性的东西留下，除了一些残破的记忆，印象外，所以写写文章吧，一来算是当作对学过的东西的复习，二来，想通过这种方式跟同道中人一同交流，共同进步吧。</p> \n<p><span style=\"white-space:pre\"></span>本人现在也算不上高手，有很多不足，还希望能多跟大家学习，探讨。</p>',NULL,NULL,'2013-12-27 18:57:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/17616879','感悟'),
	(6,'建站体会','<p><span style=\"color:rgb(51,51,51); font-family:微软雅黑; font-size:14px; line-height:22px\">这两天一时心血来潮，就上网学习了一下，如何建站吧，今天在淘宝上买了个6块钱的空间，还送了个3级域名，拿来练手，一直都没有亲自测试过是怎么部署项目到外网上，然后访问，今天终于体会到了，6块钱也不多，算是学到了不少东西，现在给出链接，欢迎大家访问，不过内容不多哦，大家见谅。。网址。。</span><a target=\"_blank\" href=\"http://blogxxx.hk5.qianduzj.net/?p=12\" class=\" c_tx\" style=\"color:rgb(69,105,141); text-decoration:initial; margin:0px; padding:0px; font-family:微软雅黑; font-size:14px; line-height:22px\">http://blogxxx.hk5.qianduzj.net/?p=12</a></p> \n<h2><span style=\"font-weight:normal\">本人弄的比较简单，直接买的空间附带一个3级域名，所以就不用考虑dns绑定什么乱七八糟的事了，然后就是用空间的账号，登录空间后台，进行其他的操作，用ftp工具把wordpress这个开源软件上传到空间中，本人用的是8uftp工具，上传的时候是传的压缩包，之后在空间上进行解压缩，不过我在这出现了问题，花了好长时间才解决，在这里告诫大家出现了问题，最好还是问卖家吧，他们应该很清楚。弄完后就可以在线安装wordpress程序了。一路弄下来，还是挺有成就感的。</span></h2>',NULL,NULL,'2013-12-27 20:55:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/17619051','杂项'),
	(7,'android tv 实现全屏画竖线','<p><strong><span style=\"font-size:18px\">自定义view</span></strong></p> \n<p><strong><span style=\"font-size:18px\">采用canvas双缓冲的方式，可以减少绘制的时间，提升性能。</span></strong></p> \n<p><strong><span style=\"font-size:18px\">StaggeredView.java</span></strong></p> \n<p><strong><span style=\"font-size:18px\">源代码如下：</span></strong></p> \n<p></p>\n<pre name=\"code\" class=\"java\">package com.xxx.demo;\n\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.view.View;\nimport android.view.WindowManager;\npublic class StaggeredView extends View {\n    int width;\n    int height;\n    Paint p;\n    Bitmap bitmap = null;\n    Canvas x = null;\n\n    public StaggeredView(Context context) {\n        super(context);\n        WindowManager wm = (WindowManager) getContext().getSystemService(\n                Context.WINDOW_SERVICE);\n        width = wm.getDefaultDisplay().getWidth();\n        height = wm.getDefaultDisplay().getHeight();\n        p = new Paint();\n    }\n\n    private void initMyCanvas() {\n        p.setColor(Color.WHITE);// 设置绿色\n        bitmap = Bitmap.createBitmap(20, 20, Bitmap.Config.ARGB_8888);\n        // Create canvas.\n        x = new Canvas();\n        x.setBitmap(bitmap);\n        p.setStyle(Paint.Style.STROKE);\n        p.setAntiAlias(true);\n        for (int i = 0; i &lt;=20; i++) {\n            changeColor(i, p);\n            x.drawLine(i, 0, i, 20, p);// 画线\n        }\n    }\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        canvas.drawColor(Color.WHITE);\n        // 创建画笔\n        long startTime=System.currentTimeMillis();\n        initMyCanvas();\n        int bitWidth = bitmap.getWidth();\n        int bitHeight = bitmap.getHeight();\n        for (int i = 0; i &lt; height; i += bitHeight) {\n            for (int j = 0; j &lt; width; j += bitWidth) {\n//                changeColor(i,j,p);\n//                canvas.drawPoint(i, j, p);\n                canvas.drawBitmap(bitmap, j, i, p);\n            }\n        }\n        System.out.println(\"时间===\"+(System.currentTimeMillis()-startTime));\n    }\n    /**\n     * 改变画笔的颜色\n     *\n     * @param i\n     * @param p\n     */\n    private void changeColor(int i, Paint p) {\n        switch (i % 2) {\n            case 0:\n                p.setColor(Color.WHITE);\n                break;\n            case 1:\n                p.setColor(Color.BLACK);\n                break;\n        }\n    }\n}\n</pre>\n<p></p> \n<p><span style=\"font-size:18px\"><strong>首先先画出一个小的矩形区域，创建一个canvas画在BitMap上，之后使用系统的canavas复用前面的BitMap,可以提高处理的效率。</strong></span></p> \n<p><br> </p> MainActivity.java \n<p></p>\n<pre name=\"code\" class=\"java\">public class MainActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(new StaggeredView(this));\n    }\n}</pre>\n<strong><span style=\"font-size:18px\">打印的结果如下：<br> &nbsp;I/System.out: 时间===91</span></strong>\n<p></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\">方法二：</span></strong></p> \n<p><strong><span style=\"font-size:18px\">StaggeredView2.java</span></strong></p> \n<p><strong><span style=\"font-size:18px\">采用默认的方式，就是一个循环，画width个竖线。效率还是很低下的。。</span></strong></p> \n<p></p>\n<pre name=\"code\" class=\"java\">public class StaggeredView2 extends View {\n    int width;\n    int height;\n    Paint p;\n    Bitmap bitmap = null;\n    Canvas x = null;\n\n    public StaggeredView2(Context context) {\n        super(context);\n        WindowManager wm = (WindowManager) getContext().getSystemService(\n                Context.WINDOW_SERVICE);\n        width = wm.getDefaultDisplay().getWidth();\n        height = wm.getDefaultDisplay().getHeight();\n        p = new Paint();\n        initMyCanvas();\n    }\n\n    private void initMyCanvas() {\n        p.setColor(Color.WHITE);// 设置绿色\n        bitmap = Bitmap.createBitmap(20, 20, Bitmap.Config.ARGB_8888);\n        // Create canvas.\n        x = new Canvas();\n        x.setBitmap(bitmap);\n        p.setStyle(Paint.Style.STROKE);\n        p.setAntiAlias(true);\n        for (int i = 0; i &lt;= 30; i++) {\n            changeColor(i, p);\n            x.drawLine(i, 0, i, 30, p);// 画线\n        }\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        canvas.drawColor(Color.WHITE);\n        // 创建画笔\n        long startTime=System.currentTimeMillis();\n        for (int i = 0; i &lt; width; i++) {\n            changeColor(i, p);\n            canvas.drawLine(i,0, i, height - 1, p);\n        }\n        System.out.println(\"时间===\"+(System.currentTimeMillis()-startTime));\n    }\n\n    /**\n     * 改变画笔的颜色\n     *\n     * @param i\n     * @param p\n     */\n    private void changeColor(int i, Paint p) {\n        switch (i % 2) {\n            case 0:\n                p.setColor(Color.WHITE);\n                break;\n            case 1:\n                p.setColor(Color.BLACK);\n                break;\n        }\n    }\n}\n</pre>\n<strong><span style=\"font-size:18px\">结果为：</span></strong>\n<p></p> \n<p><strong><span style=\"font-size:18px\">I/System.out: 时间===277</span></strong></p> \n<p><strong><span style=\"font-size:18px\">相对前面的方式而言，效率是很低下的。。。</span></strong></p> \n<p><br> <br> </p> \n<p><br> <br> </p>',NULL,NULL,'2014-08-10 18:24:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/38471883','android'),
	(8,'android tv 实现颜色条滚动效果(第二种方式)','<p><span style=\"font-size:18px\"><strong>方法二显得比较笨重，算是蠢方法吧。。</strong></span></p> \n<p><strong><span style=\"font-size:18px\">最开始没有办法的情况下采用的一种方式。</span></strong></p> \n<p><strong><span style=\"font-size:18px\">采用的是</span></strong></p> \n<p><strong><span style=\"font-size:18px\">ColorView2 extends SurfaceView implements SurfaceHolder.Callback, Runnable方式<br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\">代码如下：</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><strong><span style=\"font-size:18px\">ColorView2.java</span></strong><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\"><strong><span style=\"font-size:18px\"></span></strong></span></strong></p>\n<pre code_snippet_id=\"447182\" snippet_file_name=\"blog_20140810_1_6564439\" name=\"code\" class=\"java\">/**\n * 色彩效果view1\n */\npublic class ColorView2 extends SurfaceView implements SurfaceHolder.Callback, Runnable {\n    int width;\n    int height;\n    Paint p;\n    int i = 0;\n    SurfaceHolder mSurfaceHolder = null;\n    int all = 256 * 5;\n    float strokeWidth = 0;\n    int exteraLength = 1;\n\n    public ColorView2(Context context) {\n        super(context);\n        WindowManager wm = (WindowManager) getContext().getSystemService(\n                Context.WINDOW_SERVICE);\n        width = wm.getDefaultDisplay().getWidth();\n        height = wm.getDefaultDisplay().getHeight();\n        System.out.println(\"width==\" + width);\n        System.out.println(\"height==\" + height);\n        p = new Paint();\n        if (all &gt;= width) {\n        } else {\n            exteraLength = (int) Math.ceil(1.0 * all / (width - all));\n        }\n        mSurfaceHolder = this.getHolder();\n        mSurfaceHolder.addCallback(this);\n        this.setFocusable(true);\n        this.setKeepScreenOn(true);\n        i = 0;\n    }\n\n    public ColorView2(Context context, AttributeSet attributeSet) {\n        super(context, attributeSet);\n        WindowManager wm = (WindowManager) getContext().getSystemService(\n                Context.WINDOW_SERVICE);\n        width = wm.getDefaultDisplay().getWidth();\n        height = wm.getDefaultDisplay().getHeight();\n        System.out.println(\"width==\" + width);\n        System.out.println(\"height==\" + height);\n        p = new Paint();\n        if (all &gt;= width) {\n        } else {\n            exteraLength = (int) Math.ceil(1.0 * all / (width - all));\n        }\n        mSurfaceHolder = this.getHolder();\n        mSurfaceHolder.addCallback(this);\n        this.setFocusable(true);\n        this.setKeepScreenOn(true);\n        i = 0;\n    }\n\n    //动态画图\n    void complexdraw(int current) {\n        Canvas canvas = mSurfaceHolder\n                .lockCanvas(new Rect(current, 0, current + exteraLength, height));// 关键:获取画布    new Rect(current, 0, current+exteraLength,height)\n        Log.i(\"Canvas:X:\", \"complexdraw\");\n        if (mSurfaceHolder == null || canvas == null) {\n            return;\n        }\n        //处理不同的分辨率，造成画图的差异性\n        if (exteraLength != 1) {\n            if (i % exteraLength == exteraLength - 1) {\n                System.out.println(\"exteraLength==\" + exteraLength);\n                System.out.println(\"current==\" + current);\n                canvas.drawLine(current + current / exteraLength, 0, current + current / exteraLength, height, p);\n                canvas.drawLine(current + current / exteraLength + 1, 0, current + current / exteraLength + 1, height, p);\n            } else {\n                System.out.println(\"exteraLength==1---------&gt;\" + exteraLength);\n                System.out.println(\"current==\" + current);\n                canvas.drawLine(current + current / exteraLength, 0, current + current / exteraLength, height, p);\n            }\n        } else {\n            canvas.drawLine(current, 0, current, height, p);\n        }\n        mSurfaceHolder.unlockCanvasAndPost(canvas);\n    }\n\n    @Override\n    public void surfaceCreated(SurfaceHolder surfaceHolder) {\n        new Thread(this).start();\n    }\n\n    @Override\n    public void surfaceChanged(SurfaceHolder surfaceHolder, int i, int i2, int i3) {\n\n    }\n\n    @Override\n    public void surfaceDestroyed(SurfaceHolder surfaceHolder) {\n        i = all;//屏幕宽度的最大值\n    }\n\n    @Override\n    public void run() {\n// 创建画笔\n//		红（R：255 G：0 B：0）\n//		橙（R：255 G：156 B：0）\n//		黄（R：255 G：255 B：0）\n//		绿（R：0 G：255 B：0）\n//		青（R： G：255 B：255）\n//		蓝（R：0 G：0 B：255）\n//		紫（R：255 G： B：255）\n        System.out.println(\"canvas\");\n        int all = 256 * 5;\n        float strokeWidth = (float) (width * 1.0 / all);\n        System.out.println(\"strokeWidth==\" + strokeWidth);\n        Log.i(\"Canvas:X:\", \"complexdraw\");\n        while (i &lt; all) {\n            if (i &lt;= 255) {\n                p.setColor(Color.rgb(255, i, 0));\n            } else if (i &gt;= 256 &amp;&amp; i &lt;= 511) {\n                p.setColor(Color.rgb(511 - i, 255, 0));\n            } else if (i &gt;= 512 &amp;&amp; i &lt;= 767) {\n                p.setColor(Color.rgb(0, 255, i - 512));\n            } else if (i &gt;= 768 &amp;&amp; i &lt;= 1023) {\n                p.setColor(Color.rgb(0, 1023 - i, 255));\n            } else if (i &gt;= 1024 &amp;&amp; i &lt;= 1279) {\n                p.setColor(Color.rgb(i - 1024, 0, 255));\n            }\n            complexdraw(i);\n            i++;\n        }\n    }\n}</pre>\n<br> MainActvity.java\n<p></p> \n<p><strong><span style=\"font-size:18px\"><strong><span style=\"font-size:18px\"></span></strong></span></strong></p>\n<pre code_snippet_id=\"447182\" snippet_file_name=\"blog_20140810_2_3118876\" name=\"code\" class=\"java\">public class MainActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(R.layout.activity_color2);\n    }\n}</pre>\n<p></p> \n<p><strong><span style=\"font-size:18px\"><strong><span style=\"font-size:18px\">activity_color2.xml</span></strong></span></strong></p> \n<p><strong><span style=\"font-size:18px\"><strong><span style=\"font-size:18px\"></span></strong></span></strong></p>\n<pre code_snippet_id=\"447182\" snippet_file_name=\"blog_20140810_3_8800477\" name=\"code\" class=\"html\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n\n&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n              android:orientation=\"vertical\"\n              android:layout_width=\"fill_parent\"\n              android:layout_height=\"fill_parent\"&gt;\n    &lt;com.xxx.demo.ColorView2\n            android:id=\"@+id/colorView\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"fill_parent\"\n            /&gt;\n&lt;/LinearLayout&gt;</pre>\n<br> \n<br> \n<p></p> \n<p><br> </p>',NULL,NULL,'2014-08-10 17:20:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/38471437','android'),
	(9,'android tv 实现颜色条滚动效果','<p><span style=\"font-size:18px\"><strong>直接贴代码：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>ColorView.java</strong></span></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>\n<pre name=\"code\" class=\"java\">package com.xxx.demo;\n\nimport android.content.Context;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.View;\nimport android.view.WindowManager;\n/**\n * 色彩效果view1\n */\npublic class ColorView extends View {\n    int width;\n    int height;\n    Paint p;\n    int i = 0;\n    int all = 256 * 5;//颜色值变化\n    int exteraLength = 1;\n    Context context = null;\n    int j = 0;\n    int mLength = 0;//每次重绘时j的增量值\n\n    public ColorView(Context context) {\n        super(context);\n        this.context = context;\n        WindowManager wm = (WindowManager) getContext().getSystemService(\n                Context.WINDOW_SERVICE);\n        width = wm.getDefaultDisplay().getWidth();\n        height = wm.getDefaultDisplay().getHeight();\n        //判断是否是标准的高度\n        System.out.println(\"width==\" + width);\n        System.out.println(\"height==\" + height);\n        p = new Paint();\n        if (all &gt;= width) {\n            mLength = 80;\n        } else {\n            mLength = 30;\n            exteraLength = (int) Math.ceil(1.0 * all / (width - all));\n        }\n        this.setFocusable(true);\n        this.setKeepScreenOn(true);\n        i = 0;\n    }\n    public ColorView(Context context, AttributeSet attributeSet) {\n        super(context, attributeSet);\n        this.context = context;\n        WindowManager wm = (WindowManager) getContext().getSystemService(\n                Context.WINDOW_SERVICE);\n        width = wm.getDefaultDisplay().getWidth();\n        height = wm.getDefaultDisplay().getHeight();\n        System.out.println(\"width==\" + width);\n        System.out.println(\"height==\" + height);\n        p = new Paint();\n        p.setAntiAlias(true);\n        p.setStyle(Paint.Style.FILL);\n        if (all &gt;= width) {\n            mLength = 80;\n        } else {\n            mLength = 30;\n            exteraLength = (int) Math.ceil(1.0 * all / (width - all));\n        }\n        this.setFocusable(true);\n        this.setKeepScreenOn(true);\n        i = 0;\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        if (j &gt; all) {\n            //结束的情况。还是需要绘制的，不然界面会变黑\n            myDraw(canvas);\n            System.out.println(\"end\");\n            return;\n        }\n        myDraw(canvas);\n        j+=mLength;//改变j的值\n        invalidate();//onDraw后，重新绘制view,主观上产生动画效果\n    }\n\n\n    public void myDraw(Canvas canvas) {\n// 创建画笔\n//		红（R：255 G：0 B：0）\n//		橙（R：255 G：156 B：0）\n//		黄（R：255 G：255 B：0）\n//		绿（R：0 G：255 B：0）\n//		青（R： G：255 B：255）\n//		蓝（R：0 G：0 B：255）\n//		紫（R：255 G： B：255）\n        System.out.println(\"canvas\");\n        Log.i(\"Canvas:X:\", \"complexdraw\");\n        i = 0;\n        while (i &lt;= j) {\n            if (i &lt;= 255) {\n                p.setColor(Color.rgb(255, i, 0));\n            } else if (i &gt;= 256 &amp;&amp; i &lt;= 511) {\n                p.setColor(Color.rgb(511 - i, 255, 0));\n            } else if (i &gt;= 512 &amp;&amp; i &lt;= 767) {\n                p.setColor(Color.rgb(0, 255, i - 512));\n            } else if (i &gt;= 768 &amp;&amp; i &lt;= 1023) {\n                p.setColor(Color.rgb(0, 1023 - i, 255));\n            } else if (i &gt;= 1024 &amp;&amp; i &lt;= 1279) {\n                p.setColor(Color.rgb(i - 1024, 0, 255));\n            }\n            //处理不同的分辨率，造成画图的差异性，均分颜色值，屏幕宽度1280，颜色值的范围也是1280刚刚好，如果是小米电视的，屏幕宽度为1920,多出来的，需要均分，下面便是处理方式\n            if (exteraLength != 1) {\n                if (i % exteraLength == exteraLength - 1) {\n                    System.out.println(\"exteraLength==\" + exteraLength);\n                    System.out.println(\"current==\" + i);\n                    canvas.drawLine(i + i / exteraLength, 0, i + i / exteraLength, height, p);//画线\n                    canvas.drawLine(i + i / exteraLength + 1, 0, i + i / exteraLength + 1, height, p);\n                } else {\n                    System.out.println(\"exteraLength==1---------&gt;\" + exteraLength);\n                    System.out.println(\"current==\" + i);\n                    canvas.drawLine(i + i / exteraLength, 0, i + i / exteraLength, height, p);\n                }\n            } else {\n                canvas.drawLine(i, 0, i, height, p);\n            }\n            i++;\n        }\n    }\n}</pre>\n<br> MainActivity.java\n<p></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>\n<pre name=\"code\" class=\"java\">public class MainActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(R.layout.activity_color);\n    }\n}</pre>\n<br> activity_color.xml\n<p></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>\n<pre name=\"code\" class=\"html\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n\n&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n              android:orientation=\"vertical\"\n              android:layout_width=\"fill_parent\"\n              android:layout_height=\"fill_parent\"&gt;\n    &lt;com.xxx.demo.ColorView\n            android:id=\"@+id/colorView\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"fill_parent\"\n            /&gt;\n&lt;/LinearLayout&gt;</pre>\n<br> 在自定义view中的onDraw（）方法中，调用invalidate（）方法，可以实现类似于小球移动的效果。。\n<p></p>',NULL,NULL,'2014-08-10 17:04:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/38471303','android'),
	(10,'android studio 报编码 GBK 的不可映射字符问题','<p><strong><span style=\"font-size:18px\">解决办法：在build.gradle文件中添加：</span></strong></p> \n<p><strong><span style=\"font-size:18px\">buildscript {<br> &nbsp; &nbsp; repositories {<br> &nbsp; &nbsp; &nbsp; &nbsp; maven { url \'http://repo1.maven.org/maven2\' }<br> &nbsp; &nbsp; }<br> &nbsp; &nbsp; dependencies {<br> &nbsp; &nbsp; &nbsp; &nbsp; classpath \'com.android.tools.build:gradle:0.4\'<br> &nbsp; &nbsp; }<br> }<br> apply plugin: \'android\'<br> <br> <br> dependencies {<br> &nbsp; &nbsp; compile files(\'libs/android-support-v4.jar\')<br> &nbsp; &nbsp; compile files(\'libs/umeng-analytics-v5.2.4.jar\')<br> }<br> <br> <br> android {<br> &nbsp; &nbsp; compileSdkVersion 17<br> &nbsp; &nbsp; buildToolsVersion \"17.0.0\"<br> <br> <br> &nbsp; &nbsp; defaultConfig {<br> &nbsp; &nbsp; &nbsp; &nbsp; minSdkVersion 7<br> &nbsp; &nbsp; &nbsp; &nbsp; targetSdkVersion 16<br> &nbsp; &nbsp; }<br> &nbsp; &nbsp; signingConfigs {<br> &nbsp; &nbsp; &nbsp; &nbsp; myConfig {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //...<br> &nbsp; &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; }<br> &nbsp; &nbsp; buildTypes {<br> &nbsp; &nbsp; &nbsp; &nbsp; release {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; signingConfig signingConfigs.myConfig<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; runProguard true<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proguardFile \'proguard-project.txt\'<br> &nbsp; &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; }<br> }<br> <span style=\"color:#ff0000\">tasks.withType(Compile) {<br> &nbsp; &nbsp; options.encoding = \"UTF-8\"<br> }</span><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\">加上红色部分的代码就可以解决编码问题</span></strong></p> \n<p><br> </p> \n<p><br> </p>',NULL,NULL,'2014-07-24 14:05:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/38083631','android'),
	(11,'自定义view中在指定的矩形区域中放入一张图片','<p><strong><span style=\"font-size:18px\">如何在自定义view中，在指定的矩形区域中放入一张图片，让其刚好填充这个矩形区域，办法只能是对图片进行放大或者是缩小。</span></strong></p> \n<p><strong><span style=\"font-size:18px\"></span></strong></p>\n<pre name=\"code\" class=\"java\">Bitmap bitmap = BitmapFactory.decodeResource(getContext().getResources(), R.drawable.wenzi);//根据原来///的资源，得到bitmap\n        int bmpWidth = bitmap.getWidth();\n        int bmpHeight = bitmap.getHeight();\n        //矩形区域的大小，为正方形\n        int sideLength = height / 4;//矩形区域的大小，项目中使用的是正方形\n         /* 设置图片缩小比例 */\n        double scale = 0;\n//        //图片小于矩形区域,需要放大\n//        if(bmpWidth&lt;=sideLength){\n//        }else{\n//            //图片大于矩形区域，需要缩小\n//        }\n        /* 计算出缩小后的长宽 */\n        /* 产生Resize后的Bitmap对象 */\n        Matrix matrix = new Matrix();\n//       计算缩放率，新尺寸除原始尺寸\n        float scaleWidth = ((float) sideLength) / bmpWidth;\n        float scaleHeight = ((float) sideLength) / bmpHeight;\n        matrix.postScale(scaleWidth, scaleHeight);//设置缩放率，\n        Bitmap resizeBmp = Bitmap.createBitmap(bitmap, 0, 0, bmpWidth, bmpHeight,\n                matrix, true);//根据原图片和缩放大小，生成一张新的图片,这样图片的大小刚好与矩形区域是一致的</pre>\n<br> \n<br> \n<p></p>',NULL,NULL,'2014-07-23 10:18:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/38059275','android'),
	(12,'android canvas.drawBitmap的理解','<p><strong><span style=\"font-size:18px\">public void drawBitmap(android.graphics.Bitmap bitmap, float left, float top, android.graphics.Paint paint)</span></strong></p> \n<p><strong><span style=\"font-size:18px\">这个方法left,top指的是bitmap放置的左上方的坐标。是相对于屏幕整体来说的坐标位置。</span></strong></p> \n<p><span style=\"font-size:18px\"><strong>//以下部分转自<a target=\"_blank\" href=\"http://blog.csdn.net/zgf1991/article/details/7315281\">http://blog.csdn.net/zgf1991/article/details/7315281</a></strong></span></p> \n<p><strong><span style=\"font-size:18px\">public static void drawImage(Canvas canvas, Bitmap blt, int x, int y, int w, int h, int bx, int by) &nbsp;<br> &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //x,y表示绘画的起点， &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; Rect src = new Rect();// 图片 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; Rect dst = new Rect();// 屏幕 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; //src 这个是表示绘画图片的大小 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; src.left = bx; &nbsp; //0,0 &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; src.top = by; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; src.right = bx + w;// mBitDestTop.getWidth();,这个是桌面图的宽度， &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; src.bottom = by + h;//mBitDestTop.getHeight()/2;// 这个是桌面图的高度的一半 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; // 下面的 dst 是表示 绘画这个图片的位置 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; dst.left = x; &nbsp; //miDTX,//这个是可以改变的，也就是绘图的起点X位置 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; dst.top = y; &nbsp; &nbsp;//mBitQQ.getHeight();//这个是QQ图片的高度。 也就相当于 桌面图片绘画起点的Y坐标 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; dst.right = x + w; &nbsp;//miDTX + mBitDestTop.getWidth();// 表示需绘画的图片的右上角 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; dst.bottom = y + h; // mBitQQ.getHeight() + mBitDestTop.getHeight();//表示需绘画的图片的右下角 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; canvas.drawBitmap(blt, src, dst, null);//这个方法 &nbsp;第一个参数是图片，第二个参数是 绘画该图片需显示多少。也就是说你想绘画该图片的某一些地方，而不是全部图片，第三个参数表示该图片绘画的位置 &nbsp;<br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"font-size:18px\"><strong>&nbsp;canvas.drawBitmap(blt, src, dst, null);</strong></span><br> </span></strong></p> \n<p><span style=\"font-weight:bold\"><span style=\"font-size:18px\"><span style=\"font-size:18px\"><strong>一般情况下来说，src这个矩形区域可以设置为(0,0,bmp.getWidth(),bmp.getHeight());一般就这样设置就可以了，当初在项目中设置的src,dst都是完全一样的，导致四个<span style=\"font-size:18px\"><strong>drawBitmap只显示了一个，根据上文的理解，就明白了。</strong></span></strong></span></span></span></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p>',NULL,NULL,'2014-07-23 10:03:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/38058659','android'),
	(13,'Android命令生成编译出build.xml文件','<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> <br> </p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> 今天把安装的<strong>android开发环境打开。</strong>弄了测试项目，但没发现build.xml。找了下资料。弄了下，过程如下：</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> <img alt=\"\" src=\"http://www.pms.cc/pic/201308/52071daa4fzpsfhdf5plja2e7fatp2mkakhh.png\" style=\"border:0px; max-width:100%\"><br> <br> 输入:&nbsp;<strong>android.bat list target</strong>&nbsp; 来查询我们现有的版本list有哪些.<br> <img alt=\"\" src=\"http://www.pms.cc/pic/201308/52071db322gt5eyl65cfpazpyhsjn5a33840.png\" style=\"border:0px; max-width:100%\"><br> <br> <br> 记住这个ID号码,下的代码面会用到.<br> <span class=\"edui-filter-decoration-none\">输入:&nbsp;<strong>android update project -n ButtonDemo -t 1 -p E:workspacendroidButtonDemo</strong><br> </span><br> <strong>-n&nbsp;</strong>对应的是项目名称<br> <strong>-t&nbsp;</strong>就是我们之前查询的SDK版本对应的ID,大家根据自己的项目版本做出选择即可,我这个是android-8 所以用ID 1 .<br> <strong>-p</strong>就是生成的路径<br> 成功后显示:<br> <img alt=\"\" src=\"http://www.pms.cc/pic/201308/52071db80ecv0bh3trzklsmotxzrj0ywedhk.png\" style=\"border:0px; max-width:100%\"><br> 好了以下是生成的build.xml代码段:<br> &nbsp;</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;<br> &lt;project name=\"ZpTest\" default=\"help\"&gt;</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp; &lt;!-- The local.properties file is created and updated by the \'android\' tool.<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; It contains the path to the SDK. It should *NOT* be checked into<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Version Control Systems. --&gt;<br> &nbsp;&nbsp;&nbsp; &lt;property file=\"local.properties\" /&gt;</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp; &lt;!-- The ant.properties file can be created by you. It is only edited by the<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \'android\' tool to add properties to it.<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This is the place to change some Ant specific build properties.<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Here are some properties you may want to change/update:来源 www.pms.cc</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; source.dir<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The name of the source directory. Default is \'src\'.<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out.dir<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The name of the output directory. Default is \'bin\'.</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For other overridable properties, look at the beginning of the rules<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; files in the SDK, at tools/ant/build.xml</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Properties related to the SDK location or the project target should<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; be updated using the \'android\' tool with the \'update\' action.</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This file is an integral part of the build system for your<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; application and should be checked into Version Control Systems.</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --&gt;<br> &nbsp;&nbsp;&nbsp; &lt;property file=\"ant.properties\" /&gt;</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp; &lt;!-- if sdk.dir was not set from one of the property file, then<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get it from the ANDROID_HOME env var.<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This must be done before we load project.properties since<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the proguard config can use sdk.dir --&gt;<br> &nbsp;&nbsp;&nbsp; &lt;property environment=\"env\" /&gt;<br> &nbsp;&nbsp;&nbsp; &lt;condition property=\"sdk.dir\" value=\"${env.ANDROID_HOME}\"&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;isset property=\"env.ANDROID_HOME\" /&gt;<br> &nbsp;&nbsp;&nbsp; &lt;/condition&gt;</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp; &lt;!-- The project.properties file is created and updated by the \'android\'<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tool, as well as ADT.</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This contains project specific properties such as project target, and library<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dependencies. Lower level build properties are stored in ant.properties<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (or in .classpath for Eclipse projects).</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This file is an integral part of the build system for your<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; application and should be checked into Version Control Systems. --&gt;<br> &nbsp;&nbsp;&nbsp; &lt;loadproperties srcFile=\"project.properties\" /&gt;</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp; &lt;!-- quick check on sdk.dir --&gt;<br> &nbsp;&nbsp;&nbsp; &lt;fail<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; message=\"sdk.dir is missing. Make sure to generate local.properties using \'android update project\' or to inject it through the ANDROID_HOME environment variable.\"<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unless=\"sdk.dir\"<br> &nbsp;&nbsp;&nbsp; /&gt;</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp; &lt;!--<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Import per project custom build rules if present at the root of the project.<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This is the place to put custom intermediary targets such as:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -pre-build<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -pre-compile<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -post-compile (This is typically used for code obfuscation.<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Compiled code location: ${out.classes.absolute.dir}来源 www.pms.cc<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If this is not done in place, override ${out.dex.input.absolute.dir})<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -post-package<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -post-build<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -pre-clean<br> &nbsp;&nbsp;&nbsp; --&gt;<br> &nbsp;&nbsp;&nbsp; &lt;import file=\"custom_rules.xml\" optional=\"true\" /&gt;</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp; &lt;!-- Import the actual build file.</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; To customize existing targets, there are two options:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Customize only one target:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - copy/paste the target into this file, *before* the<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;import&gt; task.<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - customize it to your needs.<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Customize the whole content of build.xml<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - copy/paste the content of the rules files (minus the top node)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; into this file, replacing the &lt;import&gt; task.<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - customize to your needs.</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ***********************<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ****** IMPORTANT ******<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ***********************<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; In all cases you must update the value of version-tag below to read \'custom\' instead of an integer,<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in order to avoid having your file be overridden by tools such as \"android update project\"<br> &nbsp;&nbsp;&nbsp; --&gt;<br> &nbsp;&nbsp;&nbsp; &lt;!-- version-tag: 1 --&gt;<br> &nbsp;&nbsp;&nbsp; &lt;import file=\"${sdk.dir}/tools/ant/build.xml\" /&gt;</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> &lt;/project&gt;</p> \n<p style=\"margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:\'Microsoft Yahei\',Tahoma,Arial,SimSun,\'Hiragino Sans GB\',PMingLiu,Verdana,sans-serif; font-size:13px; line-height:21px; background-color:rgb(249,249,249)\"> 本文转载自：<a target=\"_blank\" href=\"http://www.pms.cc/android/dev/201308/Android_build_xml.html\">http://www.pms.cc/android/dev/201308/Android_build_xml.html</a></p>',NULL,NULL,'2014-03-28 08:52:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/22372957','android'),
	(14,'算法——基础篇——二分查找','<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp;二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表，且插入删除困难。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。</span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\">&nbsp; &nbsp; 首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</span></strong></span></p> \n<p><strong><span style=\"font-size:18px\">由于此算法理解起来简单，就不多说什么了。。</span></strong></p> \n<p><strong><span style=\"font-size:18px\">递归实现：</span></strong></p> \n<p><strong><span style=\"font-size:18px\"></span></strong></p>\n<pre code_snippet_id=\"359052\" snippet_file_name=\"blog_20140522_1_1903692\" name=\"code\" class=\"java\">package hello.ant;\n\npublic class AlogBinarySearch2 {\n	public static void main(String[] args) {\n		int array[]={1,2,3,5,6,8,9};\n		int pos=binarySearch(array,0,array.length-1,8);\n		System.out.println(pos);\n	}\n	static int binarySearch(int[] array,int begin,int end, int x) {\n		int mid=0;\n		if(begin&gt;end){\n			return -1;\n		}else {\n			mid=(begin+end)/2;\n			System.out.println(\"mid==\"+mid);\n			if(x==array[mid]){\n				return mid;\n			}else if(x&lt;array[mid]) {\n				end=mid-1;\n			}else {\n				begin=mid+1;\n			}\n			return binarySearch(array, begin, end, x);\n		}\n	}\n	\n}</pre>\n<br> 结果：\n<p></p> \n<p><strong><span style=\"font-size:18px\">mid==3<br> mid==5<br> 5<br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\">非递归实现：</span></strong></p> \n<p><strong><span style=\"font-size:18px\"></span></strong></p>\n<pre code_snippet_id=\"359052\" snippet_file_name=\"blog_20140522_2_2525356\" name=\"code\" class=\"java\">package hello.ant;\n\npublic class AlogBinarySearch {\n	public static void main(String[] args) {\n		int array[]={1,2,3,5,6,8,9};\n		int pos=binarySearch(array,7);\n		System.out.println(pos);\n	}\n	static int binarySearch(int[] array, int x) {\n		int begin=0,end=array.length-1;\n		int mid=0;\n		while(begin&lt;=end){\n			mid=(begin+end)/2;\n			System.out.println(\"mid==\"+mid);\n			if(x==array[mid]){\n				return mid;\n			}else if(x&lt;array[mid]) {\n				end=mid-1;\n			}else {\n				begin=mid+1;\n			}\n		}\n		System.out.println(mid);\n		return -1;\n	}\n	\n}</pre>\n<br> mid==3\n<br> mid==5\n<br> mid==4\n<br> 4\n<br> -1\n<br> \n<p></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p>',NULL,NULL,'2014-05-22 21:37:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26622407','算法'),
	(15,'算法——基础篇——快速排序','<p><strong><span style=\"font-size:18px\">快速排序是一个经常使用的算法，由于每次用的时候，都感觉没有理解清楚，特写一篇文章记录一下。</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"font-family:微软雅黑,黑体,Verdana; font-size:24px; line-height:24px\">算法介绍</span><br> </span></strong></p> \n<p><br> </p> \n<p><strong><span style=\"font-size:18px\">快速排序有点类似有冒泡排序，冒泡排序从相邻的两个元素比较，小的在左边，大的在右边，这个算法很容易理解。而快速排序它相当于是在一头一尾两边分别排序比较，比较的对象是当前元素值，和一个选定的key值，主题的思想就是通过跟key值比较，把大于key的值放在右边，小于的放在左边这样就完成了一次排序，接着在对key值左边的序列进行同样的操作，右边也是，最后便能将所有的元素给排好序，由于它每次排序，都会分成左右两部分，左边和右边的相对于key值来说是排好序的，接着只需要对左右两边分别递归一次排序的过程就可以了，它的效率较冒泡排序还是要高很多的，O(nlgn)...</span></strong><br> </p> \n<p><span style=\"font-size:18px\"><strong>详细处理过程：（来自百度百科）</strong></span></p> \n<p><strong><span style=\"font-size:18px\">设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。<br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\">一趟快速排序的算法是：<br> 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；<br> 2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；<br> 3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]赋给A[i]；<br> 4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]赋给A[j]；<br> 5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。<br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\">代码：</span></strong></p> \n<p><strong><span style=\"font-size:18px\"></span></strong></p>\n<pre code_snippet_id=\"356319\" snippet_file_name=\"blog_20140521_1_6501335\" name=\"code\" class=\"java\">package hello.ant;\n\npublic class AlogQuickSort {\n	public static void main(String[] args) {\n		int array[]={4,5,1,2,0,11,3,6};\n//		int array[]={4,5,1,2,0,6};\n		sort(array,0,array.length-1);\n		for(int i=0;i&lt;array.length;i++){\n			System.out.print(array[i]+\" \");\n		}\n	}\n	static void sort(int[] array, int low, int heigh) {\n		int i=low,j=heigh;\n		if(i&gt;j){\n			return;\n		}\n		int key=array[i];\n		while(i&lt;j){\n			while(i&lt;j&amp;&amp;array[j]&gt;=key){\n				j--;\n			}\n			array[i]=array[j];\n			while(i&lt;j&amp;&amp;array[i]&lt;=key){\n				i++;\n			}\n			array[j]=array[i];\n		}\n		array[i]=key;\n		sort(array, low, i-1);\n		sort(array, j+1, heigh);\n	}\n}\n</pre>\n<p></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p> 结果：\n<br> 0 1 2 3 4 5 6 11&nbsp;\n<br> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p>',NULL,NULL,'2014-05-21 13:06:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26463663','算法'),
	(16,'算法——动态规划篇——最长公共子序列','<p><strong><span style=\"color:rgb(51,51,51); font-family:微软雅黑,黑体,Verdana; font-size:24px; line-height:24px; text-indent:28px\">问题描述</span><br style=\"color:rgb(51,51,51); font-family:微软雅黑,黑体,Verdana; font-size:24px; line-height:24px; text-indent:28px\"> <br> </strong></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp;最长公共子序列，英文缩写为LCS（Longest Common Subsequence）。其定义是，一个序列 S ，如果分别是两个或多个已知序列的子序列，且是所有符合此条件序列中最长的，则 S 称为已知序列的最长公共子序列。 &nbsp;</span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\">&nbsp; &nbsp; 解决最长公共子序列，一种常用的办法，就是穷举法，组合出所有的情况，但是这样对于长序列的情况来说，是非常不实际。。</span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\">假设现在有两个序列，x[]={\'A\',\'B\',\'C\',\'B\',\'D\',\'A\',\'B\'};y[]={\'B\',\'D\',\'C\',\'A\',\'B\',\'A\'};<br> </span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\">如果采用穷举的方式，会是以下情况</span></strong></span></p> \n<p><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:#333333\">x:</span><span style=\"color:#ff0000\">A</span><span style=\"color:#333333\">,</span><span style=\"color:#6633ff; background-color:rgb(0,204,204)\">B</span><span style=\"color:#333333\">,C,B,D,A,B</span></span></span></span></strong></span></p> \n<p><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:#333333\">y:B,D,C,</span><span style=\"color:#ff0000\">A</span><span style=\"color:#333333\">,<span style=\"background-color:rgb(0,204,204)\">B</span>,A</span></span></span><br> </span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\">A与B比较，一直到A与Y中出现的第一个A遇到事停止（红色部分），然后再从X序列中的B与Y中B开始比较，（绿色部分），接着这样下去，直观上看，执行这一次遍历，就是n*n的代价，要是把所有的可能都遍历一下，代价太大了。。</span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><br> </span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\">只有采用其他的方法了，</span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\">动态规划：</span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\">观察到序列求解过程中，有一定的相似度，比如说，如果我们的序列是X:A,B,C;Y:B,D,C;由于Xc=Yc,所有要往前面的两个元素看，也就是比较X:A,B;Y:B,D，由于Xb!=Yd,那么我们需要判断X:A；Y:B,D的最大序列，以及X:A,B；YB的最大序列，取两者中最大的一个，保留下来，作为<span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-size:18px\">X:A,B;Y:B,D的最大序列值。</span></span></span></span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-size:18px\">分析问题的时候一直要先从整体上来把握，体会他的整体局部的相关性，而不是孤立出来，只是单纯的从元素本身来判断，那样就不好明白问题的规律。。。</span></span></span></span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-size:18px\">最后还是翻看了算法导论，才明白这一点，没有把握住，问题的本质。。</span></span></span></span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-size:18px\">最长子序列的规律：</span></span></span></span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-size:18px\">c[i][j]={</span></span></span></span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>0 &nbsp;,i=0||j=0</span></span></span></span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>c[i-1][j-1]+1 &nbsp;,i,j&gt;0&amp;&amp;xi=yj</span></span></span></span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp; max(c[i-1][j],c[i][j-1]),i,j&gt;0&amp;&amp;xi!=yj</span></span></span></span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-size:18px\">}</span></span></span></span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><br> </span></span></span></span></span></strong></span></p> \n<p><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px; color:#ff0000\"><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\">分析清楚问题真的很重要。。。。把握问题的本质。。。</span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><br> </span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\">代码如下：</span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"></span></span></span></span></span></strong></span></p>\n<pre code_snippet_id=\"356051\" snippet_file_name=\"blog_20140521_1_9059982\" name=\"code\" class=\"java\">package hello.ant;\n//最长公共子序列\npublic class AlogLCS {\n	public static void main(String[] args) {\n		char x[]={\'A\',\'B\',\'C\',\'B\',\'D\',\'A\',\'B\'};\n		char y[]={\'B\',\'D\',\'C\',\'A\',\'B\',\'A\'};\n		\n		int c[][]=new int[x.length+1][y.length+1];\n		//////////////    ^|^               ~~               ~~~\n		/////////////      |               ~ -------            ~~~\n		//////////////     |                ~~                      ~~\n		//////////////     用0表示向上       1向左                           		2表示斜向左上\n		int flag[][]=new int[x.length+1][y.length+1];//用来控制打印的方向\n		\n		//初始化\n		for(int i=0;i&lt;y.length+1;i++){\n			c[0][i]=0;\n		}\n		for(int i=0;i&lt;x.length+1;i++){\n			c[i][0]=0;\n		}\n		for(int i=1;i&lt;x.length+1;i++){\n			for(int j=1;j&lt;y.length+1;j++){\n				if(x[i-1]==y[j-1]){\n					c[i][j]=c[i-1][j-1]+1;\n					flag[i][j]=2;\n				}else {\n					if(c[i-1][j]&gt;=c[i][j-1]){\n						c[i][j]=c[i-1][j];\n						flag[i][j]=0;\n					}else {\n						c[i][j]=c[i][j-1];\n						flag[i][j]=1;\n					}\n				}\n			}\n		}\n		StringBuilder result=new StringBuilder();\n		display(x,flag,x.length,y.length,result);\n		System.out.println(\"\\n*********\");\n		System.out.println(result.reverse().toString());\n	}\n\n	static void display(char[] x, int[][] flag, int i, int j,StringBuilder result) {\n		if(i==0||j==0){\n			return;\n		}\n		if(flag[i][j]==2){\n			System.out.print(x[i-1]+\"  \");\n			result.append(x[i-1]);\n			display(x, flag, i-1, j-1,result);\n		}else if(flag[i][j]==1){\n			display(x, flag, i, j-1,result);\n		}else if(flag[i][j]==0){\n			display(x, flag, i-1, j,result);\n		}\n	}\n}\n</pre>\n<br> 结果如下：\n<p></p> \n<p><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:#333333\">A &nbsp;B &nbsp;C &nbsp;B &nbsp;</span><br> <span style=\"color:#333333\">*********</span><br> <span style=\"color:#ff0000\">BCBA</span><br> </span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><br> </span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\">红色部分才是真正的最长子序列。。。</span></span></span></span></span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><br> </span></span></span></span></span></strong></span></p>',NULL,NULL,'2014-05-21 10:29:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26448519','算法'),
	(17,'算法——动态规划篇——斐波那契数列','<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\">斐波那契数列，又称黄金分割数列，指的是这样一个数列：0、1、1、2、3、5、8、13、21、……在数学上，斐波纳契数列以如下被以递归的方法定义：F0=0，F1=1，Fn=F(n-1)+F(n-2)（n&gt;=2，n∈N*）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从1960年代起出版了《斐波纳契数列》季刊，专门刊载这方面的研究成果。</span></strong></span></p> \n<p><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong><span style=\"font-size:18px\">以上内容来自百度百科。。</span></strong></span></p> \n<p><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><strong style=\"color:rgb(51,51,51)\">今天主要是想用动态规划的思想求解</strong><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><strong style=\"color:rgb(51,51,51)\">斐波那契数列，用来观察动态规划带来的优势，</strong><span style=\"color:#ff0000\">空间换时间，不重复求解</span></span></span></span></span></p> \n<p><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong>方法一采用的是常规的递归方式求解，会发现，在递归的过程中会有太多的重复性操作，比如说f5=f4+f3=(f3+f2)+(f2+f1)=((f2+f1)+(f1+f0))+((f1+f0+f1)),越到后面，基本上求解的都是重复性的解，采用动态规划，可以避免这一不足，同时还将已往的解保留了下来，提高了程序的效率。</strong></span></span></span></p> \n<p><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong>代码：</strong></span></span></span></p> \n<p><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong></strong></span></span></span></p>\n<pre code_snippet_id=\"354275\" snippet_file_name=\"blog_20140520_1_6800456\" name=\"code\" class=\"java\">package hello.ant;\n//斐波那契数列应该是:0,1,1,2,3,5,8,13,21,34,55,89,144,233,...\n//规律是:f[0]=0,f[1]=1,f[i]=f[i-1]+f[i-2],i&gt;1\n\npublic class AlogFibonacci2 {\n	public static void main(String[] args) {\n		int n=40;\n		long startTime=System.currentTimeMillis();\n		System.out.println(fibonacci(n));\n		System.out.println(\"\\ntime:\"+(System.currentTimeMillis()-startTime));\n	}\n	static int fibonacci(int i){\n		if(i==0){\n			return 0;\n		}else if(i==1){\n			return 1;\n		}else {\n			return fibonacci(i-1)+fibonacci(i-2);\n		}\n	}\n}\n</pre>\n<br> 结果如下：\n<p></p> \n<p><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong>102334155<br> <br> <br> time:1199<br> </strong></span></span></span></p> \n<p><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><span style=\"font-size:18px\"><span style=\"font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px\"><strong>时间花的也比较多。</strong></span></span></span></p> \n<p><strong style=\"line-height:24px; font-family:arial,宋体,sans-serif; font-size:18px; text-indent:28px\">动态规划方式：</strong></p> \n<p><strong style=\"line-height:24px; font-family:arial,宋体,sans-serif; font-size:18px; text-indent:28px\">代码：</strong></p> \n<p><strong style=\"line-height:24px; font-family:arial,宋体,sans-serif; font-size:18px; text-indent:28px\"></strong></p>\n<pre code_snippet_id=\"354275\" snippet_file_name=\"blog_20140520_2_7422120\" name=\"code\" class=\"java\">package hello.ant;\n//斐波那契数列应该是:0,1,1,2,3,5,8,13,21,34,55,89,144,233,...\n//规律是:f[0]=0,f[1]=1,f[i]=f[i-1]+f[i-2],i&gt;1\n\npublic class AlogFibonacci {\n	public static void main(String[] args) {\n		int n=40;\n		long array[]=new long [n+1];\n		array[0]=0;\n		array[1]=1;\n		long startTime=System.currentTimeMillis();\n		for(int i=2;i&lt;n+1;i++){\n			array[i]=array[i-1]+array[i-2];\n		}\n		for(int i=1;i&lt;n+1;i++){\n			System.out.print(array[i]+\"  \");\n		}\n		System.out.println(\"\\ntime:\"+(System.currentTimeMillis()-startTime));\n	}\n}\n</pre>\n<br> 结果如下：\n<p></p> \n<p style=\"text-indent:28px\"><span style=\"font-family:arial,宋体,sans-serif; font-size:18px\"><span style=\"line-height:24px\"><strong>1 &nbsp;1 &nbsp;2 &nbsp;3 &nbsp;5 &nbsp;8 &nbsp;13 &nbsp;21 &nbsp;34 &nbsp;55 &nbsp;89 &nbsp;144 &nbsp;233 &nbsp;377 &nbsp;610 &nbsp;987 &nbsp;1597 &nbsp;2584 &nbsp;4181 &nbsp;6765 &nbsp;10946 &nbsp;17711 &nbsp;28657 &nbsp;46368 &nbsp;75025 &nbsp;121393 &nbsp;196418 &nbsp;317811 &nbsp;514229 &nbsp;832040 &nbsp;1346269 &nbsp;2178309 &nbsp;3524578 &nbsp;5702887 &nbsp;9227465 &nbsp;14930352 &nbsp;24157817 &nbsp;39088169 &nbsp;63245986 &nbsp;102334155 &nbsp;<br> time:1<br> </strong></span></span></p> \n<p style=\"text-indent:28px\"><span style=\"font-family:arial,宋体,sans-serif; font-size:18px\"><span style=\"line-height:24px\"><strong>两者相比较，差距还是很大的啊。。</strong></span></span></p> \n<p style=\"text-indent:28px\"><span style=\"font-family:arial,宋体,sans-serif; font-size:18px\"><span style=\"line-height:24px\"><strong>动态规划<span style=\"color:rgb(255,0,0); font-family:arial,宋体,sans-serif; font-size:18px; line-height:24px; text-indent:28px\">空间换时间，不重复求解，</span><span style=\"font-family:arial,宋体,sans-serif; font-size:18px; line-height:24px; text-indent:28px\">这一特性表现的很突出。。。</span></strong></span></span></p>',NULL,NULL,'2014-05-20 09:53:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26341385','算法'),
	(18,'算法——一天一道算法题篇——找只出现一次的两个数','<h2 style=\"font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; line-height:1.1; color:rgb(51,51,51); margin-top:20px; margin-bottom:10px; font-size:30px\"> 找只出现一次的两个数</h2> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"> </p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; line-height:20px\"> <strong><span style=\"font-size:18px\">题目:</span></strong></p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; line-height:20px\"> <strong><span style=\"font-size:18px\">一个整型数组里除了两个数字只出现一次之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</span></strong></p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; line-height:20px\"> <strong><span style=\"font-size:18px\"><br> </span></strong></p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; line-height:20px\"> <strong><span style=\"font-size:18px\">举例说明：</span></strong></p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"> <strong>现在有一个数组：{1,3,4,2,4,3};</strong></p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"> <strong>假设数组元素的规模不是很大，想要找到只出现一次的元素，可以定义一个辅助数组,flag[100];里面存放的是数组元素出现的次数，flag数组的下标表示的是<span style=\"color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\">数组：{1,3,4,2,4,3}里的元素。</span></strong></p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"> <strong><span style=\"color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\">代码如下：</span></strong></p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"> <strong><span style=\"color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"></span></strong></p>\n<pre code_snippet_id=\"353375\" snippet_file_name=\"blog_20140519_1_3080076\" name=\"code\" class=\"java\">package hello.ant;\n\npublic class AlogArrayFind2 {\n	public static void main(String[] args) {\n		int array[]={1,3,4,2,4,3};\n		int flag[]=new int[100];\n		for(int i=0;i&lt;array.length;i++){\n			flag[array[i]]++;\n		}\n		for(int i=0;i&lt;flag.length;i++){\n			if(flag[i]==1){\n				System.out.print(i+\"  \");\n			}\n		}\n	}\n}\n</pre>\n<br> 如果数组元素比较大的话，比如说，{1000,2,2,1000,33,45,}这种方式肯定不好，采用了官方给的提示，利用java中set，用来存放不重复的元素，来解决元素之间相差太大带来的问题：\n<p></p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"> <strong><span style=\"color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\">代码如下：</span></strong></p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"> <strong><span style=\"color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"></span></strong></p>\n<pre code_snippet_id=\"353375\" snippet_file_name=\"blog_20140519_2_6209995\" name=\"code\" class=\"java\">package hello.ant;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n//从数组中查找出个数为1的两个数，\npublic class AlogArrayFind {\n	public static void main(String[] args) {\n		int array[]={1000,2,2,1000,33,45};\n		Set&lt;Integer&gt; set=new HashSet&lt;Integer&gt;();\n		for(int i=0;i&lt;array.length;i++){\n			int x=set.size();\n			set.add(array[i]);\n			if(x==set.size()){\n//				System.out.println(array[i]);\n				set.remove(array[i]);\n			}\n		}\n		System.out.println(set);\n	}\n}\n</pre>\n<br> 结果如下：[33, 45]\n<p></p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"> <strong><span style=\"color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\">最好的一种方法如下：</span></strong></p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"> <strong><span style=\"color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"></span></strong></p> \n<pre class=\"prettyprint prettyprinted\" style=\"font-family:Menlo,Monaco,Consolas,\'Courier New\',monospace; font-size:13px; white-space:pre-wrap; padding:2px; margin-top:0px; margin-bottom:10px; line-height:1.428571429; color:rgb(51,51,51); word-break:break-all; word-wrap:break-word; background-color:rgb(245,245,245); border:1px solid rgb(136,136,136)\"><p style=\"margin-top:0px; margin-bottom:10px\"><span class=\"pun\" style=\"color:rgb(102,102,0)\">异或运算：任何一个数字异或它自己都等于</span><span class=\"lit\" style=\"color:rgb(0,102,102)\">0</span><span class=\"pun\" style=\"color:rgb(102,102,0)\">。</span></p><span class=\"pln\" style=\"color:rgb(0,0,0)\">\n\n</span><p style=\"margin-top:0px; margin-bottom:10px\"><span class=\"pln\" style=\"color:rgb(0,0,0)\">A</span><span class=\"pun\" style=\"color:rgb(102,102,0)\">.我们将数组中所有的数字异或，所得的结果相当于只出现一次的两个数的异或结果。</span><br style=\"\"><span class=\"pln\" style=\"color:rgb(0,0,0)\"> B</span><span class=\"pun\" style=\"color:rgb(102,102,0)\">.接着我们考虑，如果能够将原数组分为两个子数组，而且两个只出现一次的数分别在不同的子数组中。那么再分别对子数组异或，就可以得到这两个数。</span></p><span class=\"pln\" style=\"color:rgb(0,0,0)\">\n\n</span><p style=\"margin-top:0px; margin-bottom:10px\"><span class=\"pun\" style=\"color:rgb(102,102,0)\">现在我们考虑</span><span class=\"pln\" style=\"color:rgb(0,0,0)\">A</span><span class=\"pun\" style=\"color:rgb(102,102,0)\">中的结果，由于出现一次的两个数不同，所以它们异或的结果的二进制表示中至少有一位为</span><span class=\"lit\" style=\"color:rgb(0,102,102)\">1</span><span class=\"pun\" style=\"color:rgb(102,102,0)\">。在结果中找出第一个为</span><span class=\"lit\" style=\"color:rgb(0,102,102)\">1</span><span class=\"pun\" style=\"color:rgb(102,102,0)\">的位置,记为</span><span class=\"pln\" style=\"color:rgb(0,0,0)\">n</span><span class=\"pun\" style=\"color:rgb(102,102,0)\">，就可以区分这两个数，因为这两个数的二进制第</span><span class=\"pln\" style=\"color:rgb(0,0,0)\">n</span><span class=\"pun\" style=\"color:rgb(102,102,0)\">位肯定不同。</span><br style=\"\"><span class=\"pln\" style=\"color:rgb(0,0,0)\"> </span><span class=\"pun\" style=\"color:rgb(102,102,0)\">然后将原数组中的数，按照二进制第</span><span class=\"pln\" style=\"color:rgb(0,0,0)\">n</span><span class=\"pun\" style=\"color:rgb(102,102,0)\">位是否为</span><span class=\"lit\" style=\"color:rgb(0,102,102)\">1</span><span class=\"pun\" style=\"color:rgb(102,102,0)\">可以划分为两个子数组，这样，问题就解决了。</span></p></pre> 代码大部分是借鉴官方的，还是贴出来吧，对于位运算部分，不得不说，是挺巧妙的。 \n<p></p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"> <strong><span style=\"color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"></span></strong></p>\n<pre code_snippet_id=\"353375\" snippet_file_name=\"blog_20140519_3_8368802\" name=\"code\" class=\"java\">package hello.ant;\n/**\n * @author gejing E-mail:gjblmdlm@sina.com\n * @version 创建时间：2014年5月13日 下午8:50:07 类说明 寻找数组中只出现一次的两个数，其他的都出现了两次\n */\npublic class Code010 {\n	public static void main(String[] args) {\n		int data[] = { 1,3,1,12,2,2};\n		findAppearOnce(data);\n	}\n\n	/**\n	 * 找出数组中只出现一次的两个数\n	 * \n	 * @param data\n	 */\n	private static void findAppearOnce(int[] data) {\n		int result = 0;\n		int num1 = 0, num2 = 0;\n		System.out.println(isFirst1(1, 1));\n		// 求出所有数组元素的异或结果\n		for (int i = 0; i &lt; data.length; i++) {\n			result = data[i] ^ result;\n		}\n		// 求出结果二进制第一位为1的索引\n		String binaryResult = Integer.toBinaryString(result);\n		int first1 = binaryResult.indexOf(\"1\");\n		System.out.println(first1);\n		// 按照该索引将数组分为两个子数组\n		for (int i = 0; i &lt; data.length; i++) {\n			if (isFirst1(data[i], first1 + 1)) {// 由于数组索引和需要移的位差一位\n				num1 = data[i] ^ num1;\n			} else {\n				num2 = data[i] ^ num2;\n			}\n		}\n		System.out.println(num1 + \"   \" + num2);\n\n	}\n\n	/**\n	 * 判断第index位是否为1\n	 * \n	 * @param i\n	 * @param index\n	 * @return\n	 */\n	private static boolean isFirst1(int i, int index) {\n		if (((i &gt;&gt; index) &amp; 1) == 1) {\n			return true;\n		} else {\n			return false;\n		}\n	}\n\n}\n</pre>\n<br> 不过我也存在一个疑惑，Integer.toBinaryString(result).indexOf(\"1\")，大部分情况下都为0，而每次i&gt;&gt;index个单位，怎么还能满足要求，由于时间问题，暂时研究到这，记录下来，下次再看。。。\n<p></p> \n<p style=\"margin-top:0px; margin-bottom:10px; color:rgb(51,51,51); font-family:\'Helvetica Neue\',Helvetica,Arial,sans-serif; font-size:14px; line-height:20px\"> <br> </p>',NULL,NULL,'2014-05-19 17:19:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26256319','算法'),
	(19,'算法——递归篇——树叶下落问题','<strong><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp;</span></strong> \n<h2 class=\"title content-title\" style=\"margin:0px 0px 10px; padding:0px; font-size:20px; font-family:tahoma,helvetica,\'microsoft yahei\',arial\"> <span style=\"color:#ff0000\">UVa 699<strong><span style=\"font-size:18px\">The Falling Leaves&nbsp;</span></strong></span></h2> \n<strong><span style=\"font-size:18px\">Each year, fall in the North Central region is accompanied by the brilliant colors of the leaves on the trees, followed quickly by the falling leaves accumulating under the trees. If the same thing happened to binary trees, how large would the piles of leaves become?</span></strong>\n<br> \n<br> \n<br> \n<p><strong><span style=\"font-size:18px\">We assume each node in a binary tree \"drops\" a number of leaves equal to the integer value stored in that node. We also assume that these leaves drop vertically to the ground (thankfully, there\'s no wind to blow them around). Finally, we assume that the nodes are positioned horizontally in such a manner that the left and right children of a node are exactly one unit to the left and one unit to the right, respectively, of their parent. Consider the following tree:</span></strong></p> \n<p><strong><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src=\"http://uva.onlinejudge.org/external/6/p699.gif\" alt=\"699&nbsp;<wbr>-&nbsp;<wbr>The&nbsp;<wbr>Falling&nbsp;<wbr>Leaves\" title=\"699&nbsp;<wbr>-&nbsp;<wbr>The&nbsp;<wbr>Falling&nbsp;<wbr>Leaves\" style=\"margin:0px; padding:0px; border:0px; list-style:none; color:rgb(50,62,50); font-family:simsun; font-size:14px; background-color:rgb(220,236,204)\"></span></strong></p> \n<strong><span style=\"font-size:18px\">&nbsp;<br> <br> <br> The nodes containing 5 and 6 have the same horizontal position (with different vertical positions, of course). The node containing 7 is one unit to the left of those containing 5 and 6, and the node containing 3 is one unit to their right. When the \"leaves\" drop from these nodes, three piles are created: the leftmost one contains 7 leaves (from the leftmost node), the next contains 11 (from the nodes containing 5 and 6), and the rightmost pile contains 3. (While it is true that only leaf nodes in a tree would logically have leaves, we ignore that in this problem.)<br> &nbsp;<br> Input&nbsp;<br> The input contains multiple test cases, each describing a single tree. A tree is specified by giving the value in the root node, followed by the description of the left subtree, and then the description of the right subtree. If a subtree is empty, the value -1 is supplied. Thus the tree shown above is specified as 5 7 -1 6 -1 -1 3 -1 -1. Each actual tree node contains a positive, non-zero value. The last test case is followed by a single -1 (which would otherwise represent an empty tree).<br> &nbsp;<br> Output&nbsp;<br> For each test case, display the case number (they are numbered sequentially, starting with 1) on a line by itself. On the next line display the number of \"leaves\" in each pile, from left to right, with a single space separating each value. This display must start in column 1, and will not exceed the width of an 80-character line. Follow the output for each case by a blank line. This format is illustrated in the examples below.<br> &nbsp;<br> Sample Input&nbsp;<br> &nbsp;<br> </span></strong> \n<p><strong><span style=\"font-size:18px\">&nbsp;5 7 -1 6 -1 -1 3 -1 -1</span></strong></p> \n<p><strong><span style=\"font-size:18px\">&nbsp;8 2 9 -1 -1 6 5 -1 -1 12 -1 -1 3 7 -1 -1 -1 -1</span></strong></p> \n<strong><span style=\"font-size:18px\">&nbsp;<br> Sample Output&nbsp;<br> </span></strong> \n<p><strong><span style=\"font-size:18px\">Case 1: 7 11 3&nbsp;</span></strong></p> \n<p><strong><span style=\"font-size:18px\">Case 2: 9 7 21 15</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\">题目的意思是让我们从左到右输出树叶下落的数量</span></strong></p> \n<p><span style=\"font-size:18px\"><strong>举例说明一下：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong><strong><span style=\"font-size:18px\"><span style=\"color:#ff0000\">&nbsp;8 2 9 -1 -1 6 5 -1 -1 12 -1 -1 3 7 -1 -1 -1 -1</span></span></strong><br> </strong></span></p> \n<p><strong><span style=\"font-size:18px\">二叉树结构为：</span></strong></p> \n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img src=\"http://img.blog.csdn.net/20140518163734781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHh4ODIzOTUyMzc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\">&nbsp; &nbsp;&nbsp;<img src=\"http://img.blog.csdn.net/20140518164002875?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHh4ODIzOTUyMzc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>如上图所示，右边的图是修改后的，从垂直方向上看，依次是，9,2+5,8+6+7,3+12，这种结构就是我们想要的答案。</span></strong></p> \n<p><strong><span style=\"font-size:18px\">其实一开始想到的是怎么建立二叉树，然后在进行一系列复杂的处理，说实话，这个题真没有想到有这么巧妙的技巧，直接采用先序遍历的方式，先对头结点做处理.考虑到题目中的意思数组长度最长为80，一开始，我们从下标为40的执行，array[40]=8,然后递归执行左子树，接着是右子树。整体思路是这样，执行左子树的时候，传入的下标-1,判断当前左子树的头结点的值，然后继续递归调用其左右子树。。。</span></strong></p> \n<p><strong><span style=\"font-size:18px\">代码如下：</span></strong></p> \n<p></p>\n<pre code_snippet_id=\"351668\" snippet_file_name=\"blog_20140518_1_2001147\" name=\"code\" class=\"java\">package hello.ant;\n\nimport java.util.Scanner;\n\npublic class AlogLeaves {\n	static Scanner scanner=new Scanner(System.in);\n	public static void main(String[] args) {\n		int array[]=new int[80];\n		findLeaves(array,40);\n		displayArray(array);\n	}\n\n	static void displayArray(int[] array) {\n		for(int i=0;i&lt;array.length;i++){\n			if(array[i]!=0){\n				System.out.print(array[i]+\"  \");\n			}\n		}\n		System.out.println();\n	}\n\n	static void findLeaves(int[] array, int index) {\n		int x=scanner.nextInt();\n		if(x!=-1){\n			array[index]+=x;\n			findLeaves(array, index-1);\n			findLeaves(array, index+1);\n		}\n	}\n}\n</pre>\n<br> \n<strong><span style=\"font-size:18px\">结果：</span></strong>\n<p></p> \n<p><strong><span style=\"font-size:18px\">8 2 9 -1 -1 6 5 -1 -1 12 -1 -1 3 7 -1 -1 -1<br> 9 &nbsp;7 &nbsp;21 &nbsp;15 &nbsp;</span></strong><br> </p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\">5 7 -1 6 -1 -1 3 -1 -1<br> 7 &nbsp;11 &nbsp;3 &nbsp;<br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\">本文参考了这篇文章，<a target=\"_blank\" href=\"http://blog.csdn.net/frankiller/article/details/7765929\">http://blog.csdn.net/frankiller/article/details/7765929</a></span></strong></p> \n<p><strong><span style=\"font-size:18px\">深深体会到，这种技巧真不好把握。。。</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p>',NULL,NULL,'2014-05-18 17:03:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26155209','算法'),
	(20,'算法——排列组合篇02','<p><strong><span style=\"font-size:18px\">&nbsp; &nbsp;问题：</span></strong></p> \n<p><strong><span style=\"font-size:18px\">&nbsp; &nbsp;输入两个整数n和m,从数列1,2,3，……n中随意取几个数，使其和等于m。要求将所有的可能组合列出来</span></strong></p> \n<p><strong><span style=\"font-size:18px\">&nbsp; &nbsp;</span></strong></p> \n<p><strong><span style=\"font-size:18px\">&nbsp; &nbsp;考虑一下，该怎么解决。</span></strong></p> \n<p><strong><span style=\"font-size:18px\">&nbsp; &nbsp;举例说明：</span></strong></p> \n<p><strong><span style=\"font-size:18px\">&nbsp; &nbsp;当m=5，n=4时，所有的组合为14,23</span></strong></p> \n<p><strong><span style=\"font-size:18px\">&nbsp; &nbsp;当m=6,n=5时，所有的组合为15,24,123</span></strong></p> \n<p><span style=\"font-size:18px\"><strong>&nbsp; &nbsp; 方法一：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>&nbsp; &nbsp;遍历整个数列，从1开始，一直到n，在遍历的过程中，递归调用本方法，传入当前元素的值并+sum（初始值为0），当sum的值刚好等于m时，就打印遍历的结果。然后返回上次递归过程，继续处理下一步的执行。</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>整体的结构就是一个for(){}循环，再循环的内部，传入参数，继续调用本方法。直到条件满足，便打印。。</strong></span></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>\n<pre code_snippet_id=\"350708\" snippet_file_name=\"blog_20140517_1_9291195\" name=\"code\" class=\"java\">package hello.ant;\n//递归回溯\npublic class Alog_PL_ZH3 {\n	static int m=10,n=10;\n	public static void main(String[] args) {\n		int result[]=new int[n];\n		long startTime=System.currentTimeMillis();\n		findResult(result, 0, 0, 0);\n		long endTime=System.currentTimeMillis();\n		\n		System.out.println(\"****\"+(endTime-startTime)/1000.0);\n	}\n	static void findResult(int result[],int begin,int index,int sum){\n		if(sum&gt;m){\n			return ;\n		}else if(sum==m){\n			for(int i=0;i&lt;index;i++){\n				System.out.print(result[i]);\n			}\n			System.out.println();\n		}else {\n			for(int i=begin;i&lt;n;i++){\n				result[index]=i+1;//i+1表示数列对应的元素值\n				findResult( result, i+1, index+1, sum+i+1);\n			}\n		}\n	}\n}\n</pre>\n<br> 方法二：（参考了他人的思路）\n<p></p> \n<p><span style=\"font-size:18px\"><strong>背包的思想：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>f(m,n)的组合情况，包含n的情况，</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>若将n放入背包中，那么背包的组成就为f(m-n,n-1)+n，这里的n-1,代表着元素的下标，相等于前面背包问题里面所说的物品数量，如果不将n放入背包，背包的组成就为f(m,n-1)，用这种模拟的意思，来解释这种方法是什么思路。。。</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>代码如下：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>\n<pre code_snippet_id=\"350708\" snippet_file_name=\"blog_20140517_2_239695\" name=\"code\" class=\"java\">package hello.ant;\n\nimport java.util.Stack;\n\npublic class Alog_PL_ZH4 {\n	static Stack&lt;Integer&gt; stack=new Stack&lt;Integer&gt;();\n	public static void main(String[] args) {\n		int m=10,n=10;\n		findResult(m,n);\n	}\n\n	static void findResult(int m,int n) {\n		if(m&lt;1||n&lt;1){\n			return;\n		}\n		if(m==n){\n			printStack();\n			System.out.println(n);\n		}\n		stack.add(n);\n		findResult(m-n, n-1);\n		stack.pop();\n		findResult(m, n-1);\n	}\n	static void printStack(){\n		for(Integer x:stack){\n			System.out.print(x+\"  \");\n		}\n	}\n}\n</pre>\n<br> 结果：\n<p></p> \n<p><span style=\"font-size:18px\"><strong>10<br> 9 &nbsp;1<br> 8 &nbsp;2<br> 7 &nbsp;3<br> 7 &nbsp;2 &nbsp;1<br> 6 &nbsp;4<br> 6 &nbsp;3 &nbsp;1<br> 5 &nbsp;4 &nbsp;1<br> 5 &nbsp;3 &nbsp;2<br> 4 &nbsp;3 &nbsp;2 &nbsp;1<br> </strong></span></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>',NULL,NULL,'2014-05-17 20:59:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26093761','算法'),
	(21,'算法——动态规划篇——采药问题','<strong><span style=\"font-size:18px\">采药<br> &nbsp; &nbsp; 辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”<br> &nbsp; &nbsp; 如果你是辰辰，你能完成这个任务吗？<br> &nbsp; &nbsp; 输入：第一行有两个整数T（1 &lt;=<br> &nbsp; &nbsp;T &lt;= 1000）和M（1 &lt;=<br> &nbsp; &nbsp;M &lt;= 100），用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行 &nbsp; &nbsp; &nbsp;每行包括两个在1到100之间（包括1和100）的整数，分别表示采摘某株草药的时间和这株草药的价值。<br> &nbsp; &nbsp;输出：只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。<br> &nbsp; &nbsp;如：输入：<br> &nbsp; 70 3<br> &nbsp; 71 100<br> &nbsp; 69 1<br> &nbsp; 1 2<br> &nbsp; 输出：<br> </span></strong> \n<p><strong><span style=\"font-size:18px\">&nbsp; 3</span></strong></p> \n<p><strong><span style=\"font-size:18px\">和上一篇的01背包问题的解决办法一样。</span></strong></p> \n<p><strong><span style=\"font-size:18px\">定义一个数组，array[][],用来存放随时间变化，草药的价值的变化;</span></strong></p> \n<p><strong><span style=\"font-size:18px\">time[]记录不同草药要花的时间，value[]记录不同草药的价值。t为总时间，count为草药的数量</span></strong></p> \n<p><strong><span style=\"font-size:18px\">首先考虑第一株草药，它的花费时间为71，对于这株草药，我们需要循环遍历数组array,根据j的值与71比较，来确定array[1][j]的值，这个很前面是同样的。。</span></strong></p> \n<p><strong><span style=\"font-size:18px\">如果j&gt;71，表示可以采药，此时需要再将array[0][j]的值和array[0][j-71]+第一株草药的价值，取其中大的作为array[0][j]的结果。</span></strong></p> \n<p><strong><span style=\"font-size:18px\">如果j&lt;71，那么array[1][j]=array[0][j];</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p> \n<p><span style=\"font-size:18px\"><strong>代码如下：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>\n<pre code_snippet_id=\"350306\" snippet_file_name=\"blog_20140517_1_2503765\" name=\"code\" class=\"java\">package hello.ant;\n\nimport java.util.Scanner;\n\npublic class AlogCaiYao2 {\n	public static void main(String[] args) {\n		int t=70, count=3;\n		int time[]=null;\n		int value[]=null;\n		int i;\n		Scanner scanner=new Scanner(System.in);\n		t=scanner.nextInt();\n		count=scanner.nextInt();\n		\n		\n		time=new int[count];\n		value=new int[count];\n		for(i=0;i&lt;time.length;i++){\n			time[i]=scanner.nextInt();\n			value[i]=scanner.nextInt();\n//			System.out.println(time[i]+\"  \"+value[i]);\n		}\n		int array[][]=new int[count+1][t+1];\n		\n		//初始化\n		for(i=0;i&lt;t+1;i++){\n			array[0][i]=0;\n		}\n		for(i=0;i&lt;count+1;i++){\n			array[i][0]=0;\n		}\n		for(i=1;i&lt;count+1;i++){\n			for(int j=1;j&lt;t+1;j++){\n				if(j&gt;=time[i-1]){\n					array[i][j]=max(array[i-1][j],array[i-1][j-time[i-1]]+value[i-1]);\n				}else {\n					array[i][j]=array[i-1][j];\n				}\n				System.out.print(array[i][j]+\"  \");\n			}\n			System.out.println();\n		}\n		\n	}\n	static int max(int i, int j) {\n		if(i&gt;=j){\n			return i;\n		}\n		return j;\n	}\n}\n</pre>\n<br> \n<br> \n<p></p> \n<p><strong><span style=\"font-size:18px\">结果</span></strong></p> \n<p><strong><span style=\"font-size:18px\">70 3<br> 71 100<br> 69 1<br> 1 2<br> 0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;<br> 0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;0 &nbsp;1 &nbsp;1 &nbsp;<br> 2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;2 &nbsp;3 &nbsp;<br> </span></strong></p>',NULL,NULL,'2014-05-17 15:56:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26075131','算法'),
	(22,'算法——动态规划篇——01背包问题','<p><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; line-height:24px\"><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>问题描述：给定n种物品和一背包，物品i的重量是wi，其价值是pi，背包的容量是M，问如何选择装入背包中的物品总价值最大？</span></strong></span></p> \n<p><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; line-height:24px\"><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>比如说，现在有一个背包，容量上限是10，可以放物品的个数为3，即m=10,n=3;</span></strong></span></p> \n<p><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; line-height:24px\"><strong><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp; 物品的容量和价值分别为：</span></strong></span></p> \n<p><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; line-height:24px\"><strong><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp; 3，4</span></strong></span></p> \n<p><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; line-height:24px\"><strong><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp; 4, &nbsp; &nbsp;5</span></strong></span></p> \n<p><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; line-height:24px\"><strong><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp; 5，6</span></strong></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong>&nbsp; &nbsp; &nbsp; &nbsp; 考虑怎么做，可以从这三件物品中选出价值最大的东西来进行组合呢。</strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong>&nbsp; &nbsp; &nbsp; 直观上可以看出，就是后两种组合到一起，问题的关键是如何让计算机知道，来分析这个过程</strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong>&nbsp; &nbsp; &nbsp; 动态规划的思想：空间换时间</strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong><br> </strong></span></span> </p>\n<table border=\"1\" width=\"500\" height=\"400\" cellspacing=\"1\" cellpadding=\"1\"> \n <tbody> \n  <tr> \n   <td>0</td> \n   <td>1</td> \n   <td>2</td> \n   <td>3</td> \n   <td>4</td> \n   <td>5</td> \n   <td>6</td> \n   <td>7</td> \n   <td>8</td> \n   <td>9</td> \n   <td>10</td> \n  </tr> \n  <tr> \n   <td>0</td> \n   <td>0</td> \n   <td>0</td> \n   <td>0</td> \n   <td>0</td> \n   <td>0</td> \n   <td>0</td> \n   <td>0</td> \n   <td>0</td> \n   <td>0</td> \n   <td>0</td> \n  </tr> \n  <tr> \n   <td>0</td> \n   <td>0</td> \n   <td>0</td> \n   <td>4</td> \n   <td>4</td> \n   <td>4</td> \n   <td>4</td> \n   <td>4</td> \n   <td>4</td> \n   <td>4</td> \n   <td>4</td> \n  </tr> \n  <tr> \n   <td>0</td> \n   <td>0</td> \n   <td>0</td> \n   <td>4</td> \n   <td>5</td> \n   <td>5</td> \n   <td>5</td> \n   <td>9</td> \n   <td>9</td> \n   <td>9</td> \n   <td>9</td> \n  </tr> \n  <tr> \n   <td>0</td> \n   <td>0</td> \n   <td>0</td> \n   <td>4</td> \n   <td>5</td> \n   <td>6</td> \n   <td>6</td> \n   <td>9</td> \n   <td>10</td> \n   <td>11</td> \n   <td>11</td> \n  </tr> \n </tbody> \n</table> 观察上面的表\n<p></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong>这也是一个二维数组total[4][11];</strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong>扩大了数组的范围，用来填充下标为0的情况。。</strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong><br> </strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong>分析：</strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong>我们考虑从三个物品中任选一个物品开始讨论，假设按顺序放，开始情况为total[1][1];表示在容量为1的情况下放1个物品，怎么放呢，由于第一物品的容量为3&gt;1，无法放进去，所以total[1][1]的值应该沿着在容量为1放0个物品的情况下的值过来，即<span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\">total[1][1]=total[0][1]=0；</span></strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\">同理<span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\">total[1][2]=0，</span></span></strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong>那么total[1][3]呢，total[1][3]的容量为3，第一个物品对应的容量也刚好为3，所以理论上是可以将物品1放到背包里面，但是，还需要考虑的是，万一total[0][3]的价值比物品1的价值大呢，（这个地方，<span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\">total[0][3]=0，只是用来说明有这种情况</span>），</strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong>我们换一种情况来说明；</strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\">total[3][6]，物品3的容量为5，小于6，可以将物品3放入到背包中，该不该放入呢，我们需要知道total[2][6]的值，为5。如果将物品3放入的话，那么容量只剩下6-5=1的容量了，原来是要放入2件物品的，即是total[2][1],有前面的表知道它为0。总的来说就是要判断total[2][6],跟total[2][1]+物品3的价值，他们两者中的大的一个，作为<span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\">total[3][6]的值。</span></span><br> </strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\"><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\">大致的思路就是这样的，具体还需要自己体会。。。</span></span></strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\"><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\">代码如下：</span></span></strong></span></span></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\"><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\"></span></span></strong></span></span></p> \n<pre code_snippet_id=\"350222\" snippet_file_name=\"blog_20140517_1_532582\" name=\"code\" class=\"java\">package hello.ant;\n\npublic class AlogBeiBao {\n	//动态规划\n	public static void main(String[] args) {\n		int m=10,count=3;\n		int capacity[]={3,4,5};\n		int value[]={4,5,6};\n		int total[][]=new int[count+1][m+1];\n		int i;\n		//初始化\n		for(i=0;i&lt;m+1;i++){\n			total[0][i]=0;\n		}\n		for(i=0;i&lt;count+1;i++){\n			total[i][0]=0;\n		}\n		for(i=1;i&lt;count+1;i++){\n			for(int j=1;j&lt;m+1;j++){\n				if(j&gt;=capacity[i-1]){\n					total[i][j]=max(total[i-1][j],total[i-1][j-capacity[i-1]]+value[i-1]);\n				}else {\n					total[i][j]=total[i-1][j];\n				}\n				System.out.print(total[i][j]+\"  \");\n			}\n			System.out.println();\n		}\n	}\n	static int max(int i, int j) {\n		if(i&gt;=j){\n			return i;\n		}\n		return j;\n	}\n}\n</pre>\n<br> 结果如下，去掉了下标为0的记录： \n<p></p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\"><span style=\"color:rgb(50,62,50); font-family:\'Times new roman\'; font-size:18px; line-height:24px\">0 &nbsp;0 &nbsp;4 &nbsp;4 &nbsp;4 &nbsp;4 &nbsp;4 &nbsp;4 &nbsp;4 &nbsp;4 &nbsp;<br> 0 &nbsp;0 &nbsp;4 &nbsp;5 &nbsp;5 &nbsp;5 &nbsp;9 &nbsp;9 &nbsp;9 &nbsp;9 &nbsp;<br> 0 &nbsp;0 &nbsp;4 &nbsp;5 &nbsp;6 &nbsp;6 &nbsp;9 &nbsp;10 &nbsp;11 &nbsp;11 &nbsp;<br> </span></span></strong></span></span></p> \n<p><br> </p> \n<p><span style=\"font-family:Times new roman; font-size:18px; color:#323e32\"><span style=\"line-height:24px\"><strong>动态规划的思想就是将每一步计算的值保留下来，留作以后使用，空间换时间，还需要不断的去体会。</strong></span></span></p>',NULL,NULL,'2014-05-17 15:06:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26068949','算法'),
	(23,'算法——基础篇——FJ的字符串','<strong><span style=\"font-size:18px\">A1057. FJ的字符串（</span></strong> \n<h1 class=\"mb-5\" style=\"margin:0px 0px 5px; padding:0px; font-size:16px; line-height:26px; font-family:\'Microsoft YaHei\',SimHei,arial; word-break:break-all; color:rgb(51,51,51)\"> <span class=\"ask-title \" style=\"display:inline-block; width:595px; overflow:hidden\">http://www.tsinsen.com/A1057</span></h1> ）\n<br> 问题描述　　FJ在沙盘上写了这样一些字符串：\n<br> 　　A1 = “A”\n<br> 　　A2 = “ABA”\n<br> 　　A3 = “ABACABA”\n<br> 　　A4 = “ABACABADABACABA”\n<br> 　　… …\n<br> 　　你能找出其中的规律并写所有的数列AN吗？\n<br> 输入格式　　仅有一个数：N ≤ 26。\n<br> 输出格式　　请输出相应的字符串AN，以一个换行符结束。输出中不得含有多余的空格或换行、回车符。\n<br> 样例输入3\n<br> \n<p><strong><span style=\"font-size:18px\">样例输出ABACABA</span></strong></p> \n<p><span style=\"font-size:18px\"><strong>思路：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>观察规律，对于A2的结果来说，可以看到，A2的结果由三部分组成，A1+B+A1,可以接着往下猜测，A3也可能满足此规律，A3=A2+C+A2，的确也满足这种规律，由此可以推测出如下公式</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>&nbsp; &nbsp; &nbsp;f(A)=A;</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>&nbsp; &nbsp; &nbsp;f(B)=f(A)+B+f(A);</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>&nbsp; &nbsp; &nbsp;f(C)=f(B)+C+f(B);</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>&nbsp; &nbsp; f(D)=f(C)+D+f(C);</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>就是一个递归调用的过程。</strong></span></p> \n<p><span style=\"font-size:18px\"><strong><br> </strong></span></p> \n<p><span style=\"font-size:18px\"><strong>代码如下：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>\n<pre code_snippet_id=\"350068\" snippet_file_name=\"blog_20140517_1_5941584\" name=\"code\" class=\"java\">package hello.ant;\n\nimport java.util.Scanner;\n\npublic class AlogFJ2 {\n	static char[] str={\n		\'A\',\'B\',\'C\',\'D\',\'E\',\n		\'F\',\'G\',\'H\',\'I\',\'J\',\n		\'K\',\'L\',\'M\',\'N\',\'O\',\n		\'P\',\'Q\',\'R\',\'S\',\'T\',\n		\'U\',\'V\',\'W\',\'X\',\'Y\',\n		\'Z\'};\n	public static void main(String[] args) {\n		Scanner scanner=new Scanner(System.in);\n		int n=0;\n		n=scanner.nextInt();\n		String str=findFJ(n-1);\n		System.out.println(str);\n	}\n	static String findFJ(int n) {\n		if(n==0){\n			return \"\"+str[n];\n		}else {\n			return findFJ(n-1)+str[n]+findFJ(n-1);\n		}\n	}\n}\n</pre>输入\n<br> 3\n<br> ABACABA\n<br> \n<p></p> \n<p><span style=\"font-size:18px\"><strong>多观察规律，这种题是可以做出来的。。</strong></span></p> \n<p><span style=\"font-size:18px\"><strong><br> </strong></span></p>',NULL,NULL,'2014-05-17 12:43:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26061807','算法'),
	(24,'算法——基础篇——字母图形','<strong><span style=\"font-size:18px\">&nbsp; 问题描述<br> &nbsp; 利用字母可以组成一些美丽的图形，下面给出了一个例子：<br> &nbsp; ABCDEFG<br> &nbsp; BABCDEF<br> &nbsp; CBABCDE<br> &nbsp; DCBABCD<br> &nbsp; EDCBABC<br> &nbsp; 这是一个5行7列的图形，请找出这个图形的规律，并输出一个n行m列的图形。<br> &nbsp; 输入格式<br> &nbsp; 输入一行，包含两个整数n和m，分别表示你要输出的图形的行数的列数。<br> &nbsp; 输出格式<br> &nbsp; 输出n行，每个m个字符，为你的图形。<br> &nbsp; 样例输入<br> &nbsp; 5 7<br> &nbsp; 样例输出<br> &nbsp; ABCDEFG<br> &nbsp; BABCDEF<br> &nbsp; CBABCDE<br> &nbsp; DCBABCD<br> </span></strong> \n<p><strong><span style=\"font-size:18px\">&nbsp; EDCBABC</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p> \n<p><span style=\"font-size:18px\"><strong>思路：观察二维数组的结构，用下标i表示行，j表示列：</strong></span></p> \n<p><span style=\"font-size:18px; color:#ff0000\"><strong>对于字母A满足规律i-j=0，例如array[0][0]=A,<span style=\"font-size:18px\">array[1][1]=A,<span style=\"font-size:18px\">array[2][3]=A,</span></span></strong></span></p> \n<p><span style=\"font-size:18px\"><strong><span style=\"color:#ff0000\"><span style=\"white-space:pre\"></span>字母B满足规律i-j=1或-1,</span><span style=\"font-size:18px\"><span style=\"color:#ff0000\">例如array[1][0]=B,array[2][1]=B,array[0][1]=B,<span style=\"font-size:18px\">array[1][2]=B</span></span></span></strong></span></p> \n<p><span style=\"font-size:18px\"><strong>同理，其他的都是这样的规律：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong><br> </strong></span></p> \n<p><span style=\"font-size:18px\"><strong>代码如下：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>\n<pre code_snippet_id=\"350010\" snippet_file_name=\"blog_20140517_1_5335300\" name=\"code\" class=\"java\">package hello.ant;\n\nimport java.util.Scanner;\n\npublic class AlogTuXing {\n	static char[] str={\'A\',\'B\',\'C\',\'D\',\'E\',\n						\'F\',\'G\',\'H\',\'I\',\'J\',\n						\'K\',\'L\',\'M\',\'N\',\'O\',\n						\'P\',\'Q\',\'R\',\'S\',\'T\',\n						\'U\',\'V\',\'W\',\'X\',\'Y\',\n						\'Z\'};\n	public static void main(String[] args) {\n		int n=5,m=7;//5行7列\n		Scanner scanner=new Scanner(System.in);\n		n=scanner.nextInt();\n		m=scanner.nextInt();\n		char array[][]=new char[n][m];\n		for(int i=0;i&lt;n;i++){\n			for(int j=0;j&lt;m;j++){\n				int x=i-j;\n				if(x&lt;0){\n					x=-1*x;\n				}\n				array[i][j]=str[x];\n			}\n		}\n		displayArray(array);\n	}\n	static void displayArray(char array[][]){\n		for(int i=0;i&lt;array.length;i++){\n			for(int j=0;j&lt;array[i].length;j++){\n				System.out.print(array[i][j]);\n			}\n			System.out.println();\n		}\n	}\n}\n</pre>\n<br> 本题在把握了规律之后，就没有什么难度了。\n<p></p> \n<p><span style=\"font-size:18px\"><strong>题目来源于<a target=\"_blank\" href=\"http://blog.csdn.net/hymanxq/article/details/26019039\">http://blog.csdn.net/hymanxq/article/details/26019039</a></strong></span></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p>',NULL,NULL,'2014-05-17 11:40:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26058639','算法'),
	(25,'算法——蓝桥杯篇——乘积最大','<div class=\"pdsec\" style=\"color:rgb(51,51,51); line-height:26px; margin:16px 0px 8px; padding:0px; font-family:微软雅黑,黑体,宋体; font-size:16px\">\n  问题描述\n</div> \n<div class=\"pdcont\" style=\"color:rgb(51,51,51); font-size:14px; margin:0px 0px 0px 16px; padding:0px; font-family:宋体,\'Times New Roman\'; line-height:22px\">\n  　　今年是国际数学联盟确定的“2000——世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰90周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友XZ也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：\n <br style=\"margin:0px; padding:0px\"> \n <br style=\"margin:0px; padding:0px\"> 　　设有一个长度为N的数字串，要求选手使用K个乘号将它分成K+1个部分，找出一种分法，使得这K+1个部分的乘积能够为最大。\n <br style=\"margin:0px; padding:0px\"> \n <br style=\"margin:0px; padding:0px\"> 　　同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：\n <br style=\"margin:0px; padding:0px\"> \n <br style=\"margin:0px; padding:0px\"> 　　有一个数字串：312， 当N=3，K=1时会有以下两种分法：\n <br style=\"margin:0px; padding:0px\"> \n <br style=\"margin:0px; padding:0px\"> 　　3*12=36\n <br style=\"margin:0px; padding:0px\"> 　　31*2=62\n <br style=\"margin:0px; padding:0px\"> \n <br style=\"margin:0px; padding:0px\"> 　　这时，符合题目要求的结果是：31*2=62\n <br style=\"margin:0px; padding:0px\"> \n <br style=\"margin:0px; padding:0px\"> 　　现在，请你帮助你的好朋友XZ设计一个程序，求得正确的答案。\n</div> \n<div class=\"pdsec\" style=\"color:rgb(51,51,51); line-height:26px; margin:16px 0px 8px; padding:0px; font-family:微软雅黑,黑体,宋体; font-size:16px\">\n  输入格式\n</div> \n<div class=\"pdcont\" style=\"color:rgb(51,51,51); font-size:14px; margin:0px 0px 0px 16px; padding:0px; font-family:宋体,\'Times New Roman\'; line-height:22px\">\n  　　程序的输入共有两行：\n <br style=\"margin:0px; padding:0px\"> 　　第一行共有2个自然数N，K（6≤N≤40，1≤K≤6）\n <br style=\"margin:0px; padding:0px\"> 　　第二行是一个长度为N的数字串。\n</div> \n<div class=\"pdsec\" style=\"color:rgb(51,51,51); line-height:26px; margin:16px 0px 8px; padding:0px; font-family:微软雅黑,黑体,宋体; font-size:16px\">\n  输出格式\n</div> \n<div class=\"pdcont\" style=\"color:rgb(51,51,51); font-size:14px; margin:0px 0px 0px 16px; padding:0px; font-family:宋体,\'Times New Roman\'; line-height:22px\">\n  　　输出所求得的最大乘积（一个自然数）。\n</div> \n<div class=\"pdsec\" style=\"color:rgb(51,51,51); line-height:26px; margin:16px 0px 8px; padding:0px; font-family:微软雅黑,黑体,宋体; font-size:16px\">\n  样例输入\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  4 2\n <br style=\"margin:0px; padding:0px; font-family:宋体,\'Times New Roman\'\"> 1231\n</div> \n<div class=\"pdsec\" style=\"color:rgb(51,51,51); line-height:26px; margin:16px 0px 8px; padding:0px; font-family:微软雅黑,黑体,宋体; font-size:16px\">\n  样例输出\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  62\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\"> \n <br> \n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  思路：\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  假设现在有数据array[]=(1,2,3,4),N=4,K=2;\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  乘法相乘的表达式为：\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  1*2*34\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  1*23*4\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  12*3*4\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  一共这三种情况，具体是怎么分析的呢，如下\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  假设我首先选定了下标为0的元素1，即意味着我的表达式结构变成了1*(2,3,4),然后要考虑的就是对表达式的右边部分做处理，（2,3,4）\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  现在要求的就是（2,3,4）的相乘的结果，我们继续选取下标为1的元素，即元素2,表达式就变成了2*(3,4)。到这里应该可以观察出来，这是一个递归的过程了，由于我们最开始的K值为2,递归两次后就可以了，只需要返回（3,4）的值就可以了。\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  整体上来说，，思路就是这样的。\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\"> \n <br> \n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  现在假设数组为array[]={1,2,3,4,5};N=5,K=2\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  还是从下标为0的元素1开始遍历，即1*（2,3,4,5）；然后处理（2,3,4,5），对于这个过程是从下标为1开始的，2*（3,4,5）\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\">\n  到这里，已经两次了，需要计算出（3,4,5）的值，并返回结果，做处理。之后便是返回到上一个的处理中，从\n <span style=\"color:rgb(51,51,51); font-family:\'Courier New\',Courier,monospace; font-size:14px; line-height:26px\">下标为2开始进行，即1*（2,3,4,5）的接下来一步过程从2*（3,4,5）变成了23*（4,5）在进行计算，返回结果，并与先前的一个结果比较，保留最大的。</span>\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\"> \n <span style=\"color:rgb(51,51,51); font-family:\'Courier New\',Courier,monospace; font-size:14px; line-height:26px\"><br> </span>\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\"> \n <span style=\"color:rgb(51,51,51); font-family:\'Courier New\',Courier,monospace; font-size:14px; line-height:26px\">整体思路就是这样的。</span>\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\"> \n <span style=\"color:rgb(51,51,51); font-family:\'Courier New\',Courier,monospace; font-size:14px; line-height:26px\">以下便是代码：</span>\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\"> \n <span style=\"color:rgb(51,51,51); font-family:\'Courier New\',Courier,monospace; font-size:14px; line-height:26px\"></span>\n <pre code_snippet_id=\"349944\" snippet_file_name=\"blog_20140517_1_4262955\" name=\"code\" class=\"java\">package hello.ant;\n\npublic class AlogKM {\n	static int N=4;\n	static int K=2;\n	public static void main(String[] args) {\n		int array[]={1,2,3,1};\n		System.out.println(getResult(array, 0, K));\n	}\n	static int getResult(int array[],int begin,int k){\n		if(k==0){\n			return getIntFromArray(array, begin, array.length-1);\n		}else{\n			int result=0;\n			for(int i=begin;i&lt;array.length;i++){\n				int x=getIntFromArray(array, begin, i)*getResult(array, i+1, k-1);\n				if(x&gt;result){\n					result=x;\n				}\n//				if(k==K){\n//					System.out.println(result);\n//				}\n			}\n			return result;\n		}\n	}\n	static int getIntFromArray(int array[],int begin,int i){\n		int sum=0;\n		while(begin&lt;=i){\n			sum=sum*10+array[begin];\n			begin++;\n		}\n		return sum;\n	}\n}\n</pre>\n <br> 加上输入操作的代码为（完整的）：\n</div> \n<div class=\"pddata\" style=\"color:rgb(51,51,51); font-size:14px; line-height:26px; margin:0px 0px 0px 16px; padding:0px 0px 0px 2em; font-family:\'Courier New\',Courier,monospace\"> \n <span style=\"color:rgb(51,51,51); font-family:\'Courier New\',Courier,monospace; font-size:14px; line-height:26px\"></span>\n <pre code_snippet_id=\"349944\" snippet_file_name=\"blog_20140517_2_2212832\" name=\"code\" class=\"java\">package hello.ant;\n\nimport java.util.Scanner;\n\npublic class AlogKM2 {\n	static int N=4;\n	static int K=2;\n	public static void main(String[] args) {\n		Scanner scanner=new Scanner(System.in);\n		N=scanner.nextInt();\n		K=scanner.nextInt();\n		String str=scanner.next();\n		System.out.println(N);\n		System.out.println(K);\n		System.out.println(str);\n//		int array[]={1,2,3,1};\n		int array[]=strToArray(str);\n		System.out.println(getResult(array, 0, K));\n	}\n	static int[] strToArray(String str){\n		int array[]=new int[N];\n		for(int i=0;i&lt;str.length();i++){\n			array[i]=str.charAt(i)-48;\n//			System.out.println(array[i]);\n		}\n		return array;\n	}\n	static int getResult(int array[],int begin,int k){\n		if(k==0){\n			return getIntFromArray(array, begin, array.length-1);\n		}else{\n			int result=0;\n			for(int i=begin;i&lt;array.length;i++){\n				int x=getIntFromArray(array, begin, i)*getResult(array, i+1, k-1);\n				if(x&gt;result){\n					result=x;\n				}\n//				if(k==K){\n//					System.out.println(result);\n//				}\n			}\n			return result;\n		}\n	}\n	//取出数组指定位置上的元素，比如getIntFromArray(array,0,1)即将数组的前两个元素组合为一个数\n	static int getIntFromArray(int array[],int begin,int i){\n		int sum=0;\n		while(begin&lt;=i){\n			sum=sum*10+array[begin];\n			begin++;\n		}\n		return sum;\n	}\n}\n</pre>\n <br> \n <br> \n</div>',NULL,NULL,'2014-05-17 10:54:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26052655','算法'),
	(26,'算法——排列组合篇01','<p><span style=\"font-size:18px\"><strong>现在有一个数组1,2,3,4,5，要求从数组中选取3个元素对其进行排列组合。</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>基本思路就是，先组合，先从数组中选取出所有的组合情况，然后对这每一种组合进行排列。</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>代码如下：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>\n<pre code_snippet_id=\"349847\" snippet_file_name=\"blog_20140517_1_6273323\" name=\"code\" class=\"java\">package hello.ant;\n\npublic class Alog_PL_ZH {\n	public static void main(String[] args) {\n		int array[]={1,2,3,4,5};\n		//先组合，在排列\n		int n=3;\n		int result[]=new int[n];\n		ZH(array,result,0,0,n);\n//		PL(array, 0);\n	}\n\n	static void ZH(int[] array,int result[],int begin,int index,int length) {\n		if(length==0){\n//			for(int i=0;i&lt;result.length;i++){\n//				System.out.print(result[i]);\n//			}\n			System.out.println();\n			PL(result, 0);\n		}else{\n			for(int i=begin;i&lt;array.length;i++){\n				result[index]=array[i];\n				ZH(array,result,i+1,index+1,length-1);\n			}\n		}\n	}\n	static void PL(int result[],int index){\n		if(result.length==index){\n			for(int i=0;i&lt;result.length;i++){\n				System.out.print(result[i]);\n			}\n			System.out.println();\n		}else{\n			for(int i=index;i&lt;result.length;i++){\n				swap(result,i,index);\n				PL(result,index+1);\n				swap(result,i,index);\n			}\n		}\n	}\n\n	static void swap(int[] result, int i, int index) {\n		int temp=result[i];\n		result[i]=result[index];\n		result[index]=temp;\n	}\n}\n</pre>留下一个疑问，如果要求出所有的情况，比如说，组合情况还有1,2,3,4,5,12,13,14,15.......123,124,125....1234,1235......12345\n<p></p> \n<p><span style=\"font-size:18px\"><strong>这种情况下该怎么处理，难道就是简单的在上面的基础上，加上for循环，让result数组的长度从1变到5吗，这样的话，算法的执行效率不高吧。</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>程序代码如下：（暂时没有考虑执行效率）</strong></span></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>\n<pre code_snippet_id=\"349847\" snippet_file_name=\"blog_20140517_2_1224577\" name=\"code\" class=\"java\">package hello.ant;\n\npublic class Alog_PL_ZH2 {\n	public static void main(String[] args) {\n		first();\n//		PL(array, 0);\n	}\n	static void first(){\n		int array[]={1,2,3,4,5};\n		//先组合，在排列\n		int n=3;\n		int result[]=null;\n		for(int i=0;i&lt;array.length;i++){\n			result=new int[i+1];//每次循环都改变result的长度，即意味着第一次是组合的是长度为1的，\n//			这样就可以打印所有情况下的排列组合了。\n			ZH(array,result,0,0,result.length);\n		}\n		\n	}\n	static void ZH(int[] array,int result[],int begin,int index,int length) {\n		if(length==0){\n//			for(int i=0;i&lt;result.length;i++){\n//				System.out.print(result[i]);\n//			}\n			System.out.println();\n			PL(result, 0);\n		}else{\n			for(int i=begin;i&lt;array.length;i++){\n				result[index]=array[i];\n				ZH(array,result,i+1,index+1,length-1);\n			}\n		}\n	}\n	static void PL(int result[],int index){\n		if(result.length==index){\n			for(int i=0;i&lt;result.length;i++){\n				System.out.print(result[i]);\n			}\n			System.out.println();\n		}else{\n			for(int i=index;i&lt;result.length;i++){\n				swap(result,i,index);\n				PL(result,index+1);\n				swap(result,i,index);\n			}\n		}\n	}\n\n	static void swap(int[] result, int i, int index) {\n		int temp=result[i];\n		result[i]=result[index];\n		result[index]=temp;\n	}\n}\n</pre>\n<br> 本文参考了这篇文章\n<a target=\"_blank\" href=\"http://blog.csdn.net/zmazon/article/details/8315418\">http://blog.csdn.net/zmazon/article/details/8315418</a>\n<br> \n<br> \n<p></p>',NULL,NULL,'2014-05-17 08:50:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26043299','算法'),
	(27,'算法——组合篇01','<p><strong><span style=\"font-size:18px\">现在有一个数组array[]={1,2,3,4};要求从4个数中取出两个，不重复，组合公式C4^2=6种，即12,13,14,23,24,34.根据这个过程我们可以考虑按从小到大的顺序遍历数组，然后递归执行。</span></strong></p> \n<p><strong><span style=\"font-size:18px\">具体代码如下：</span></strong></p> \n<p><strong><span style=\"font-size:18px\">方法一：</span></strong></p> \n<p><strong><span style=\"font-size:18px\"></span></strong></p>\n<pre code_snippet_id=\"349838\" snippet_file_name=\"blog_20140517_1_8382543\" name=\"code\" class=\"java\">package hello.ant;\n\npublic class AlogZH{\n	\n	public static void main(String[] args) {\n		int array[]={1,2,3,4};\n		int n=2;\n		int result[]=new int[n];\n		ZH(array, result, 0,0,n);\n	}\n	static void ZH(int array[],int result[],int index,int begin,int length){\n		if(length==0){\n			for(int i=0;i&lt;result.length;i++){\n				System.out.print(result[i]);\n			}\n			System.out.println();\n		}else{\n			for(int i=begin;i&lt;array.length;i++){\n				result[index]=array[i];\n				ZH(array, result, index+1,i+1, length-1);\n			}\n		}\n	}\n	\n}</pre>方法二：\n<p></p> \n<p><strong><span style=\"font-size:18px\"></span></strong></p>\n<pre code_snippet_id=\"349838\" snippet_file_name=\"blog_20140517_2_1872317\" name=\"code\" class=\"java\">package hello.ant;\n\npublic class AlogZH2 {\n	static int n=2;\n	static int result[]=new int[n];\n	static int array[]={1,2,3,4,5};\n	static boolean flag[]=new boolean[array.length];\n	public static void main(String[] args) {\n		ZH(0, 0);\n		\n	}\n	static void ZH(int index,int begin){\n		if(index==n){\n			for(int i=0;i&lt;result.length;i++){\n				System.out.print(result[i]);\n			}\n			System.out.println();\n		}else{\n			for(int i=begin;i&lt;array.length;i++){\n				if(flag[i]){\n					continue;\n				}\n				flag[i]=true;\n				result[index]=array[i];\n				ZH(index+1,i+1);\n				flag[i]=false;\n			}\n		}\n	}\n}\n</pre>\n<br> 对于这类问题的分析，感觉就是从宏观上把握它的处理过程，先是一个for循环遍历从下标为0一直到最后一个元素，在循环内部在递归代用本方法，传递参数的时候注意，让它从当前下标+1进行。不断递归，就可以实现题目要求的结果，整体上把握这个过程，就不会错，具体细节，需要多调试，观察。\n<p></p> \n<p><strong><span style=\"font-size:18px\">参考了<a target=\"_blank\" href=\"http://blog.csdn.net/hymanxq/article/details/24490419\">http://blog.csdn.net/hymanxq/article/details/24490419</a>这篇文章的内容。。<br> <br> </span></strong></p> \n<p><br> </p>',NULL,NULL,'2014-05-17 08:30:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/26042359','算法'),
	(28,'算法——排列篇01','<p><strong><span style=\"font-size:18px\">排列问题:</span></strong></p> \n<p>&nbsp; &nbsp; 将数组a[]={1,2,3}的全排列打印出来，不重复数组中的元素。</p> \n<p>&nbsp; &nbsp; 方法一：</p> \n<p></p> \n<pre code_snippet_id=\"347438\" snippet_file_name=\"blog_20140515_1_1354846\" name=\"code\" class=\"java\">package hello.ant;\n\npublic class AlogPL {\n	static void getAll(int array[],int index){\n		if(index==array.length){\n			for(int i=0;i&lt;array.length;i++){\n				System.out.print(array[i]+\" \");\n			}\n			System.out.println();\n		}else {\n			for(int i=index;i&lt;3;i++){\n				swap(array, i, index);\n				getAll(array, index+1);\n				swap(array, i, index);\n			}\n		}\n	}\n	static void swap(int a[],int i,int index){\n		int temp=a[i];\n		a[i]=a[index];\n		a[index]=temp;\n	}\n	public static void main(String[] args) {\n		int array[]={1,2,3};\n		getAll(array, 0);\n	}\n}\n</pre>\n<br> 方法二： \n<p></p> \n<p></p> \n<pre code_snippet_id=\"347438\" snippet_file_name=\"blog_20140515_2_7495361\" name=\"code\" class=\"java\">package hello.ant;\n\npublic class AlogPL4 {\n	public static void main(String[] args) {\n		int array[]={1,2,3};\n		boolean flag[]=new boolean[array.length];\n		int result[]=new int[array.length];\n		PL(array, result, flag, 0);\n	}\n	static void PL(int array[],int result[],boolean flag[],int index){\n		if(index==result.length){\n			for(int i=0;i&lt;result.length;i++){\n				System.out.print(result[i]);\n			}\n			System.out.println();\n		}else {\n			for(int i=0;i&lt;array.length;i++){\n				if(flag[i]){\n					continue;\n				}\n				result[index]=array[i];\n				flag[i]=true;\n				PL(array, result, flag, index+1);\n				flag[i]=false;\n			}\n		}\n	}\n}\n</pre>重复数组中的元素： \n<p></p> \n<p><br> </p> \n<pre code_snippet_id=\"347438\" snippet_file_name=\"blog_20140515_3_4540166\" name=\"code\" class=\"java\">package hello.ant;\n\npublic class AlogPL2 {\n	\n	static void getAll(int array[],int b[],int index){\n		if(index==b.length){\n			for(int i=0;i&lt;b.length;i++){\n				System.out.print(b[i]+\" \");\n			}\n			System.out.println();\n		}else {\n			for(int i=0;i&lt;2;i++){\n				b[index]=array[i];\n				getAll(array, b,index+1);\n			}\n		}\n	}\n	static void swap(int a[],int i,int index){\n		int temp=a[i];\n		a[i]=a[index];\n		a[index]=temp;\n	}\n	public static void main(String[] args) {\n		int array[]={1,2};\n		int b[]=new int[array.length];\n		getAll(array, b,0);\n	}\n}</pre> \n<p></p> \n<p><br> </p> \n<p>不重复元素，采用非递归的方式实现（按字典顺序）。</p> \n<p></p> \n<pre code_snippet_id=\"347438\" snippet_file_name=\"blog_20140515_4_157294\" name=\"code\" class=\"java\">package hello.ant;\n\nimport java.util.Arrays;\n\npublic class AlogPL3 {\n	//字典排列方式\n	public static void main(String[] args) {\n		int array[]={1,2,3,4};\n		Arrays.sort(array);\n		printArray(array);\n		while(true){\n			//从后往前找最先出现的逆序数对，取最小的值的下标\n			int i=array.length-2;\n			for(;i&gt;=0;i--){\n				if(array[i]&lt;array[i+1]){\n					break;\n				}\n				if(i==0){//此时数组已经是最大的数列了\n					printArray(array);\n					return;\n				}\n			}\n			//从后往前找最先出现的比下标为i的元素值大的元素的下标j;\n			int j=array.length-1;\n			for(;j&gt;=0;j--){\n				if(array[j]&gt;array[i]){\n					break;\n				}\n			}\n			swap(array,i,j);//交换,i,j\n			reverse(array,i+1,array.length-1);\n			printArray(array);\n		}\n		\n		\n	}\n	//翻转\n	static void reverse(int[] array, int i, int j) {\n		// TODO Auto-generated method stub\n//		if(i&gt;=j){\n//			return;\n//		}\n		while(i&lt;j){\n			swap(array, i++, j--);\n		}\n	}\n	static void swap(int[] array, int i, int j) {\n		int temp=array[i];\n		array[i]=array[j];\n		array[j]=temp;\n	}\n	//打印数组\n	static void printArray(int array[]){\n		for(int i=0;i&lt;array.length;i++){\n			System.out.print(array[i]);\n		}\n		System.out.println();\n	}\n}\n</pre>\n<br> 算法还是挺漫长的，不过也很有意思，写这篇文章，记录一下成长的历程。 \n<p></p> \n<p>本人参考过一下两篇博客。</p> \n<p><a target=\"_blank\" href=\"http://blog.csdn.net/hymanxq/article/details/24418135\">http://blog.csdn.net/hymanxq/article/details/24418135</a><br> </p> \n<a target=\"_blank\" href=\"http://blog.csdn.net/zmazon/article/details/8351611\">http://blog.csdn.net/zmazon/article/details/8351611</a> \n<p><br> </p> \n<p>看懂后均有自己实现，感觉算法的细节思路，有很多的技巧，真是博大精深。。我辈还需努力。。。</p>',NULL,NULL,'2014-05-15 17:14:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/25900073','算法'),
	(29,'html解析器——jericho-html-3.3解析table','<p><span style=\"font-size:18px\">原文部分内容来源于网上其他博客，不过由于时间长了，忘记参考的是谁的了，在此说声抱歉。。</span></p> \n<p><span style=\"font-size:18px\">先贴出一段html页面：</span></p> \n<p></p>\n<pre code_snippet_id=\"393127\" snippet_file_name=\"blog_20140615_1_2519809\" name=\"code\" class=\"html\">&lt;html&gt;\n&lt;head&gt;\n&lt;meta http-equiv=\"content-type\" content=\"text/html;charset=GBK\"&gt;\n&lt;title&gt;HTML Parser&lt;/title&gt;\n&lt;meta name=\"generator\" content=\"Namo WebEditor\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;table width=620 border=0 cellpadding=1 cellspacing=0 bgcolor=#0066cc&gt;\n	&lt;tr&gt;\n		&lt;td width=100%&gt;\n		&lt;table width=100% border=0 cellpadding=4 cellspacing=0 bgcolor=#D3E5FB&gt;\n			&lt;tr bgcolor=#D3E5FB&gt;\n				&lt;td width=20%&gt;&lt;font size=\"2\" face=\"Arial,Verdana\"&gt;&lt;b&gt;想学习\n				Name&lt;/b&gt;&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=13%&gt;&lt;font size=\"2\" face=\"Arial,Verdana\"&gt;&lt;b&gt;Result&lt;/b&gt;&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=8%&gt;&lt;font size=\"2\" face=\"Arial,Verdana\"&gt;&lt;b&gt;Time&lt;/b&gt;&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=59%&gt;&lt;font size=\"2\" face=\"Arial,Verdana\"&gt;&lt;b&gt;Synopsis&lt;/b&gt;&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n			&lt;/tr&gt;\n			&lt;tr bgcolor=#eeeeee&gt;\n				&lt;td width=20%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;&lt;b&gt;9&lt;/b&gt;\n				想学习&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=13%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;&lt;font\n					color=#ff0033&gt;+FAIL&lt;/font&gt; &lt;a\n					href=\"v4_wireless_802.1x_full/cdrouter_dhcp_20.txt\"&gt;想学习&lt;/a&gt;&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=8%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;12:31&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=59%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;想学习&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n			&lt;/tr&gt;\n			&lt;tr bgcolor=#ffffff&gt;\n				&lt;td width=20%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;&lt;b&gt;1&lt;/b&gt;\n				cdrouter_basic_1&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=13%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;Pass &lt;a\n					href=\"v4_wireless_802.1x_full/cdrouter_basic_1.txt\"&gt;想学习&lt;/a&gt;&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=8%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;00:00&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=59%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;想学习&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n			&lt;/tr&gt;\n		&lt;/table&gt;\n		&lt;/td&gt;\n	&lt;/tr&gt;\n&lt;/table&gt;\n&lt;/body&gt;\n&lt;/html&gt;</pre>\n<br> \n<span style=\"font-size:18px\">对于这个页面来说我想取出所有的td里面的文字内容，该怎么办呢，如果用正则表达式，我还真是难以写出正确的，来解析出我所要的结果。</span>\n<p></p> \n<p><span style=\"font-size:18px\">在网上搜索了一下jericho-html-3.3这个插件，用来解析table，的确很方便。</span></p> \n<p><span style=\"font-size:18px\">代码如下：</span></p> \n<p><span style=\"font-size:18px\"></span></p>\n<pre code_snippet_id=\"393127\" snippet_file_name=\"blog_20140615_2_1200816\" name=\"code\" class=\"java\">package com.xxx.hbuassys.test;\n\nimport java.net.URL;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport net.htmlparser.jericho.Element;\nimport net.htmlparser.jericho.HTMLElementName;\nimport net.htmlparser.jericho.Segment;\nimport net.htmlparser.jericho.Source;\n \npublic class HtmlParser\n{\n    public static void main(String[] args) throws Exception\n    {\n        String sourceUrlString=\"test.html\";\n        \n        if(sourceUrlString.indexOf(\':\') == -1)\n            sourceUrlString =\"file:\"+sourceUrlString;\n        Source source=new Source(new URL(sourceUrlString));\n        List Elements_TABLE=source.getAllElements(HTMLElementName.TABLE);\n        Elements_TABLE.remove(0);//由于table相互嵌套，我们需要的是第二个，所以删掉第一个\n        Iterator it_TABLE = Elements_TABLE.iterator();\n        while(it_TABLE.hasNext())\n        {\n            Element Element_TABLE = (Element)it_TABLE.next();\n//        	System.out.println(\"**\"+Element_TABLE.toString()+\"\\n**\");\n            Segment getContent_TABLE = (Segment)Element_TABLE.getContent();\n            List Elements_TR = getContent_TABLE.getAllElements(HTMLElementName.TR);\n            Iterator it_TR = Elements_TR.iterator();\n            while(it_TR.hasNext())\n            {\n                Element Element_TR = (Element)it_TR.next();\n                Segment getContent_TR = (Segment)Element_TR.getContent();\n                List Elements_FONT = getContent_TR.getAllElements(HTMLElementName.FONT);\n                Iterator it_FONT = Elements_FONT.iterator();\n                int i = 1;\n                while(it_FONT.hasNext())\n                {\n                    Element Element_FONT = (Element)it_FONT.next();\n                    Segment getContent_FONT = (Segment)Element_FONT.getContent();\n                    String a1 = getContent_FONT.toString();\n                    System.out.println(i + \" = \" + Element_FONT.getContent().getTextExtractor().toString());\n                    i++;\n                }\n                System.out.println();\n            }\n        }\n    }\n}\n</pre>结果：\n<p></p> \n<p><span style=\"font-size:18px\">1 = 想学习 Name<br> 2 = Result<br> 3 = Time<br> 4 = Synopsis<br> <br> <br> 1 = 9 想学习<br> 2 = +FAIL 想学习<br> 3 = +FAIL<br> 4 = 12:31<br> 5 = 想学习<br> <br> <br> 1 = 1 cdrouter_basic_1<br> 2 = Pass 想学习<br> 3 = 00:00<br> 4 = 想学习<br> <br> <br> 大致的思路就是，先取出所有的table标签，然后对需要的table进行解析，取出里面的tr,在从tr里面取出td这样就可以得到我们需要的内容了。</span></p> \n<p><span style=\"font-size:18px\">如果只说到这，那么就跟网上其他人讲的没有什么区别了。</span></p> \n<p><span style=\"font-size:18px\">因为项目的需要，使用此插件发现了一个问题：</span></p> \n<p><span style=\"font-size:18px\">如果html页面的编码是UTF-8的格式，那么解析出来的内容就会是乱码，如果直接对这些乱码编码，采用new String(str.getBytes(),\"GBK\");等之类的操作都不能解决问题，本人亲自测试过。</span></p> \n<p><span style=\"font-size:18px\">例如html页面变为：</span></p> \n<p><span style=\"font-size:18px\"></span></p>\n<pre code_snippet_id=\"393127\" snippet_file_name=\"blog_20140615_3_1309500\" name=\"code\" class=\"html\">&lt;html&gt;\n&lt;head&gt;\n&lt;meta http-equiv=\"content-type\" content=\"text/html;charset=UTF-8\"&gt;\n&lt;title&gt;HTML Parser&lt;/title&gt;\n&lt;meta name=\"generator\" content=\"Namo WebEditor\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;table width=620 border=0 cellpadding=1 cellspacing=0 bgcolor=#0066cc&gt;\n	&lt;tr&gt;\n		&lt;td width=100%&gt;\n		&lt;table width=100% border=0 cellpadding=4 cellspacing=0 bgcolor=#D3E5FB&gt;\n			&lt;tr bgcolor=#D3E5FB&gt;\n				&lt;td width=20%&gt;&lt;font size=\"2\" face=\"Arial,Verdana\"&gt;&lt;b&gt;想学习\n				Name&lt;/b&gt;&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=13%&gt;&lt;font size=\"2\" face=\"Arial,Verdana\"&gt;&lt;b&gt;Result&lt;/b&gt;&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=8%&gt;&lt;font size=\"2\" face=\"Arial,Verdana\"&gt;&lt;b&gt;Time&lt;/b&gt;&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=59%&gt;&lt;font size=\"2\" face=\"Arial,Verdana\"&gt;&lt;b&gt;Synopsis&lt;/b&gt;&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n			&lt;/tr&gt;\n			&lt;tr bgcolor=#eeeeee&gt;\n				&lt;td width=20%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;&lt;b&gt;9&lt;/b&gt;\n				想学习&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=13%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;&lt;font\n					color=#ff0033&gt;+FAIL&lt;/font&gt; &lt;a\n					href=\"v4_wireless_802.1x_full/cdrouter_dhcp_20.txt\"&gt;想学习&lt;/a&gt;&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=8%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;12:31&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=59%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;想学习&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n			&lt;/tr&gt;\n			&lt;tr bgcolor=#ffffff&gt;\n				&lt;td width=20%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;&lt;b&gt;1&lt;/b&gt;\n				cdrouter_basic_1&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=13%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;Pass &lt;a\n					href=\"v4_wireless_802.1x_full/cdrouter_basic_1.txt\"&gt;想学习&lt;/a&gt;&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=8%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;00:00&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n				&lt;td width=59%&gt;&lt;font size=\"1\" face=\"Arial,Verdana\"&gt;想学习&lt;/font&gt;&lt;br&gt;\n				&lt;/td&gt;\n			&lt;/tr&gt;\n		&lt;/table&gt;\n		&lt;/td&gt;\n	&lt;/tr&gt;\n&lt;/table&gt;\n&lt;/body&gt;\n&lt;/html&gt;</pre>\n<br> 得到的结果是：\n<p></p> \n<p><span style=\"font-size:18px\">1 = ???? Name<br> 2 = Result<br> 3 = Time<br> 4 = Synopsis<br> <br> <br> 1 = 9 ????<br> 2 = +FAIL ????<br> 3 = +FAIL<br> 4 = 12:31<br> 5 = ????<br> <br> <br> 1 = 1 cdrouter_basic_1<br> 2 = Pass ????<br> 3 = 00:00<br> 4 = ????<br> <br> <br> </span></p> \n<p><span style=\"font-size:18px\">采用的方法是：改变&lt;meta http-equiv=\"content-type\" content=\"text/html;charset=UTF-8\"&gt;变为：<span style=\"font-size:18px\">&lt;meta http-equiv=\"content-type\" content=\"text/html;charset=GBK\"&gt;</span></span></p> \n<p><span style=\"font-size:18px\">详细情况，参考代码如下：</span></p> \n<p><span style=\"font-size:18px\"></span></p>\n<pre code_snippet_id=\"393127\" snippet_file_name=\"blog_20140615_4_6642437\" name=\"code\" class=\"java\">package com.xxx.hbuassys.test;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileReader;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport net.htmlparser.jericho.Element;\nimport net.htmlparser.jericho.HTMLElementName;\nimport net.htmlparser.jericho.Segment;\nimport net.htmlparser.jericho.Source;\n \npublic class HtmlParser\n{\n    public static void main(String[] args) throws Exception\n    {\n    	BufferedReader reader=new BufferedReader(new InputStreamReader(new FileInputStream(new File(\"test.html\"))));\n//    	BufferedReader reader=new BufferedReader(new FileReader(new File(\"test.html\")));\n    	StringBuilder sbf=new StringBuilder();\n    	String str=null;\n    	while((str=reader.readLine())!=null){\n    		sbf.append(str).append(\"\\n\");\n    	}\n    	//解决中文乱码的方法\n    	String html=sbf.toString().replace(\"&lt;meta http-equiv=\\\"content-type\\\" content=\\\"text/html;charset=UTF-8\\\"&gt;\", \"&lt;meta http-equiv=\\\"content-type\\\" content=\\\"text/html;charset=GBK\\\"&gt;\");\n//    	System.out.println(html);\n        Source source=new Source(html);\n        List Elements_TABLE=source.getAllElements(HTMLElementName.TABLE);\n        Elements_TABLE.remove(0);//由于table相互嵌套，我们需要的是第二个，所以删掉第一个\n        Iterator it_TABLE = Elements_TABLE.iterator();\n        while(it_TABLE.hasNext())\n        {\n            Element Element_TABLE = (Element)it_TABLE.next();\n//        	System.out.println(\"**\"+Element_TABLE.toString()+\"\\n**\");\n            Segment getContent_TABLE = (Segment)Element_TABLE.getContent();\n            List Elements_TR = getContent_TABLE.getAllElements(HTMLElementName.TR);\n            Iterator it_TR = Elements_TR.iterator();\n            while(it_TR.hasNext())\n            {\n                Element Element_TR = (Element)it_TR.next();\n                Segment getContent_TR = (Segment)Element_TR.getContent();\n                List Elements_FONT = getContent_TR.getAllElements(HTMLElementName.FONT);\n                Iterator it_FONT = Elements_FONT.iterator();\n                int i = 1;\n                while(it_FONT.hasNext())\n                {\n                    Element Element_FONT = (Element)it_FONT.next();\n                    Segment getContent_FONT = (Segment)Element_FONT.getContent();\n                    String a1 = getContent_FONT.toString();\n                    System.out.println(i + \" = \" + Element_FONT.getContent().getTextExtractor().toString());\n                    i++;\n                }\n                System.out.println();\n            }\n        }\n    }\n}\n</pre>\n<br> 结果如下：\n<p></p> \n<p><span style=\"font-size:18px\">1 = 想学习 Name<br> 2 = Result<br> 3 = Time<br> 4 = Synopsis<br> <br> <br> 1 = 9 想学习<br> 2 = +FAIL 想学习<br> 3 = +FAIL<br> 4 = 12:31<br> 5 = 想学习<br> <br> <br> 1 = 1 cdrouter_basic_1<br> 2 = Pass 想学习<br> 3 = 00:00<br> 4 = 想学习<br> <br> <br> </span></p> \n<p><span style=\"font-size:18px\"><br> </span></p> \n<p><br> </p>',NULL,NULL,'2014-06-15 10:16:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/30969607','java插件'),
	(30,'android tv 实现全屏画竖线','<p><strong><span style=\"font-size:18px\">自定义view</span></strong></p> \n<p><strong><span style=\"font-size:18px\">采用canvas双缓冲的方式，可以减少绘制的时间，提升性能。</span></strong></p> \n<p><strong><span style=\"font-size:18px\">StaggeredView.java</span></strong></p> \n<p><strong><span style=\"font-size:18px\">源代码如下：</span></strong></p> \n<p></p>\n<pre name=\"code\" class=\"java\">package com.xxx.demo;\n\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.view.View;\nimport android.view.WindowManager;\npublic class StaggeredView extends View {\n    int width;\n    int height;\n    Paint p;\n    Bitmap bitmap = null;\n    Canvas x = null;\n\n    public StaggeredView(Context context) {\n        super(context);\n        WindowManager wm = (WindowManager) getContext().getSystemService(\n                Context.WINDOW_SERVICE);\n        width = wm.getDefaultDisplay().getWidth();\n        height = wm.getDefaultDisplay().getHeight();\n        p = new Paint();\n    }\n\n    private void initMyCanvas() {\n        p.setColor(Color.WHITE);// 设置绿色\n        bitmap = Bitmap.createBitmap(20, 20, Bitmap.Config.ARGB_8888);\n        // Create canvas.\n        x = new Canvas();\n        x.setBitmap(bitmap);\n        p.setStyle(Paint.Style.STROKE);\n        p.setAntiAlias(true);\n        for (int i = 0; i &lt;=20; i++) {\n            changeColor(i, p);\n            x.drawLine(i, 0, i, 20, p);// 画线\n        }\n    }\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        canvas.drawColor(Color.WHITE);\n        // 创建画笔\n        long startTime=System.currentTimeMillis();\n        initMyCanvas();\n        int bitWidth = bitmap.getWidth();\n        int bitHeight = bitmap.getHeight();\n        for (int i = 0; i &lt; height; i += bitHeight) {\n            for (int j = 0; j &lt; width; j += bitWidth) {\n//                changeColor(i,j,p);\n//                canvas.drawPoint(i, j, p);\n                canvas.drawBitmap(bitmap, j, i, p);\n            }\n        }\n        System.out.println(\"时间===\"+(System.currentTimeMillis()-startTime));\n    }\n    /**\n     * 改变画笔的颜色\n     *\n     * @param i\n     * @param p\n     */\n    private void changeColor(int i, Paint p) {\n        switch (i % 2) {\n            case 0:\n                p.setColor(Color.WHITE);\n                break;\n            case 1:\n                p.setColor(Color.BLACK);\n                break;\n        }\n    }\n}\n</pre>\n<p></p> \n<p><span style=\"font-size:18px\"><strong>首先先画出一个小的矩形区域，创建一个canvas画在BitMap上，之后使用系统的canavas复用前面的BitMap,可以提高处理的效率。</strong></span></p> \n<p><br> </p> MainActivity.java \n<p></p>\n<pre name=\"code\" class=\"java\">public class MainActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(new StaggeredView(this));\n    }\n}</pre>\n<strong><span style=\"font-size:18px\">打印的结果如下：<br> &nbsp;I/System.out: 时间===91</span></strong>\n<p></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\">方法二：</span></strong></p> \n<p><strong><span style=\"font-size:18px\">StaggeredView2.java</span></strong></p> \n<p><strong><span style=\"font-size:18px\">采用默认的方式，就是一个循环，画width个竖线。效率还是很低下的。。</span></strong></p> \n<p></p>\n<pre name=\"code\" class=\"java\">public class StaggeredView2 extends View {\n    int width;\n    int height;\n    Paint p;\n    Bitmap bitmap = null;\n    Canvas x = null;\n\n    public StaggeredView2(Context context) {\n        super(context);\n        WindowManager wm = (WindowManager) getContext().getSystemService(\n                Context.WINDOW_SERVICE);\n        width = wm.getDefaultDisplay().getWidth();\n        height = wm.getDefaultDisplay().getHeight();\n        p = new Paint();\n        initMyCanvas();\n    }\n\n    private void initMyCanvas() {\n        p.setColor(Color.WHITE);// 设置绿色\n        bitmap = Bitmap.createBitmap(20, 20, Bitmap.Config.ARGB_8888);\n        // Create canvas.\n        x = new Canvas();\n        x.setBitmap(bitmap);\n        p.setStyle(Paint.Style.STROKE);\n        p.setAntiAlias(true);\n        for (int i = 0; i &lt;= 30; i++) {\n            changeColor(i, p);\n            x.drawLine(i, 0, i, 30, p);// 画线\n        }\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        canvas.drawColor(Color.WHITE);\n        // 创建画笔\n        long startTime=System.currentTimeMillis();\n        for (int i = 0; i &lt; width; i++) {\n            changeColor(i, p);\n            canvas.drawLine(i,0, i, height - 1, p);\n        }\n        System.out.println(\"时间===\"+(System.currentTimeMillis()-startTime));\n    }\n\n    /**\n     * 改变画笔的颜色\n     *\n     * @param i\n     * @param p\n     */\n    private void changeColor(int i, Paint p) {\n        switch (i % 2) {\n            case 0:\n                p.setColor(Color.WHITE);\n                break;\n            case 1:\n                p.setColor(Color.BLACK);\n                break;\n        }\n    }\n}\n</pre>\n<strong><span style=\"font-size:18px\">结果为：</span></strong>\n<p></p> \n<p><strong><span style=\"font-size:18px\">I/System.out: 时间===277</span></strong></p> \n<p><strong><span style=\"font-size:18px\">相对前面的方式而言，效率是很低下的。。。</span></strong></p> \n<p><br> <br> </p> \n<p><br> <br> </p>',NULL,NULL,'2014-08-10 18:24:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/38471883','android tv'),
	(31,'android tv 实现颜色条滚动效果(第二种方式)','<p><span style=\"font-size:18px\"><strong>方法二显得比较笨重，算是蠢方法吧。。</strong></span></p> \n<p><strong><span style=\"font-size:18px\">最开始没有办法的情况下采用的一种方式。</span></strong></p> \n<p><strong><span style=\"font-size:18px\">采用的是</span></strong></p> \n<p><strong><span style=\"font-size:18px\">ColorView2 extends SurfaceView implements SurfaceHolder.Callback, Runnable方式<br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\">代码如下：</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><strong><span style=\"font-size:18px\">ColorView2.java</span></strong><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\"><strong><span style=\"font-size:18px\"></span></strong></span></strong></p>\n<pre code_snippet_id=\"447182\" snippet_file_name=\"blog_20140810_1_6564439\" name=\"code\" class=\"java\">/**\n * 色彩效果view1\n */\npublic class ColorView2 extends SurfaceView implements SurfaceHolder.Callback, Runnable {\n    int width;\n    int height;\n    Paint p;\n    int i = 0;\n    SurfaceHolder mSurfaceHolder = null;\n    int all = 256 * 5;\n    float strokeWidth = 0;\n    int exteraLength = 1;\n\n    public ColorView2(Context context) {\n        super(context);\n        WindowManager wm = (WindowManager) getContext().getSystemService(\n                Context.WINDOW_SERVICE);\n        width = wm.getDefaultDisplay().getWidth();\n        height = wm.getDefaultDisplay().getHeight();\n        System.out.println(\"width==\" + width);\n        System.out.println(\"height==\" + height);\n        p = new Paint();\n        if (all &gt;= width) {\n        } else {\n            exteraLength = (int) Math.ceil(1.0 * all / (width - all));\n        }\n        mSurfaceHolder = this.getHolder();\n        mSurfaceHolder.addCallback(this);\n        this.setFocusable(true);\n        this.setKeepScreenOn(true);\n        i = 0;\n    }\n\n    public ColorView2(Context context, AttributeSet attributeSet) {\n        super(context, attributeSet);\n        WindowManager wm = (WindowManager) getContext().getSystemService(\n                Context.WINDOW_SERVICE);\n        width = wm.getDefaultDisplay().getWidth();\n        height = wm.getDefaultDisplay().getHeight();\n        System.out.println(\"width==\" + width);\n        System.out.println(\"height==\" + height);\n        p = new Paint();\n        if (all &gt;= width) {\n        } else {\n            exteraLength = (int) Math.ceil(1.0 * all / (width - all));\n        }\n        mSurfaceHolder = this.getHolder();\n        mSurfaceHolder.addCallback(this);\n        this.setFocusable(true);\n        this.setKeepScreenOn(true);\n        i = 0;\n    }\n\n    //动态画图\n    void complexdraw(int current) {\n        Canvas canvas = mSurfaceHolder\n                .lockCanvas(new Rect(current, 0, current + exteraLength, height));// 关键:获取画布    new Rect(current, 0, current+exteraLength,height)\n        Log.i(\"Canvas:X:\", \"complexdraw\");\n        if (mSurfaceHolder == null || canvas == null) {\n            return;\n        }\n        //处理不同的分辨率，造成画图的差异性\n        if (exteraLength != 1) {\n            if (i % exteraLength == exteraLength - 1) {\n                System.out.println(\"exteraLength==\" + exteraLength);\n                System.out.println(\"current==\" + current);\n                canvas.drawLine(current + current / exteraLength, 0, current + current / exteraLength, height, p);\n                canvas.drawLine(current + current / exteraLength + 1, 0, current + current / exteraLength + 1, height, p);\n            } else {\n                System.out.println(\"exteraLength==1---------&gt;\" + exteraLength);\n                System.out.println(\"current==\" + current);\n                canvas.drawLine(current + current / exteraLength, 0, current + current / exteraLength, height, p);\n            }\n        } else {\n            canvas.drawLine(current, 0, current, height, p);\n        }\n        mSurfaceHolder.unlockCanvasAndPost(canvas);\n    }\n\n    @Override\n    public void surfaceCreated(SurfaceHolder surfaceHolder) {\n        new Thread(this).start();\n    }\n\n    @Override\n    public void surfaceChanged(SurfaceHolder surfaceHolder, int i, int i2, int i3) {\n\n    }\n\n    @Override\n    public void surfaceDestroyed(SurfaceHolder surfaceHolder) {\n        i = all;//屏幕宽度的最大值\n    }\n\n    @Override\n    public void run() {\n// 创建画笔\n//		红（R：255 G：0 B：0）\n//		橙（R：255 G：156 B：0）\n//		黄（R：255 G：255 B：0）\n//		绿（R：0 G：255 B：0）\n//		青（R： G：255 B：255）\n//		蓝（R：0 G：0 B：255）\n//		紫（R：255 G： B：255）\n        System.out.println(\"canvas\");\n        int all = 256 * 5;\n        float strokeWidth = (float) (width * 1.0 / all);\n        System.out.println(\"strokeWidth==\" + strokeWidth);\n        Log.i(\"Canvas:X:\", \"complexdraw\");\n        while (i &lt; all) {\n            if (i &lt;= 255) {\n                p.setColor(Color.rgb(255, i, 0));\n            } else if (i &gt;= 256 &amp;&amp; i &lt;= 511) {\n                p.setColor(Color.rgb(511 - i, 255, 0));\n            } else if (i &gt;= 512 &amp;&amp; i &lt;= 767) {\n                p.setColor(Color.rgb(0, 255, i - 512));\n            } else if (i &gt;= 768 &amp;&amp; i &lt;= 1023) {\n                p.setColor(Color.rgb(0, 1023 - i, 255));\n            } else if (i &gt;= 1024 &amp;&amp; i &lt;= 1279) {\n                p.setColor(Color.rgb(i - 1024, 0, 255));\n            }\n            complexdraw(i);\n            i++;\n        }\n    }\n}</pre>\n<br> MainActvity.java\n<p></p> \n<p><strong><span style=\"font-size:18px\"><strong><span style=\"font-size:18px\"></span></strong></span></strong></p>\n<pre code_snippet_id=\"447182\" snippet_file_name=\"blog_20140810_2_3118876\" name=\"code\" class=\"java\">public class MainActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(R.layout.activity_color2);\n    }\n}</pre>\n<p></p> \n<p><strong><span style=\"font-size:18px\"><strong><span style=\"font-size:18px\">activity_color2.xml</span></strong></span></strong></p> \n<p><strong><span style=\"font-size:18px\"><strong><span style=\"font-size:18px\"></span></strong></span></strong></p>\n<pre code_snippet_id=\"447182\" snippet_file_name=\"blog_20140810_3_8800477\" name=\"code\" class=\"html\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n\n&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n              android:orientation=\"vertical\"\n              android:layout_width=\"fill_parent\"\n              android:layout_height=\"fill_parent\"&gt;\n    &lt;com.xxx.demo.ColorView2\n            android:id=\"@+id/colorView\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"fill_parent\"\n            /&gt;\n&lt;/LinearLayout&gt;</pre>\n<br> \n<br> \n<p></p> \n<p><br> </p>',NULL,NULL,'2014-08-10 17:20:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/38471437','android tv'),
	(32,'android tv 实现颜色条滚动效果','<p><span style=\"font-size:18px\"><strong>直接贴代码：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>ColorView.java</strong></span></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>\n<pre name=\"code\" class=\"java\">package com.xxx.demo;\n\nimport android.content.Context;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.View;\nimport android.view.WindowManager;\n/**\n * 色彩效果view1\n */\npublic class ColorView extends View {\n    int width;\n    int height;\n    Paint p;\n    int i = 0;\n    int all = 256 * 5;//颜色值变化\n    int exteraLength = 1;\n    Context context = null;\n    int j = 0;\n    int mLength = 0;//每次重绘时j的增量值\n\n    public ColorView(Context context) {\n        super(context);\n        this.context = context;\n        WindowManager wm = (WindowManager) getContext().getSystemService(\n                Context.WINDOW_SERVICE);\n        width = wm.getDefaultDisplay().getWidth();\n        height = wm.getDefaultDisplay().getHeight();\n        //判断是否是标准的高度\n        System.out.println(\"width==\" + width);\n        System.out.println(\"height==\" + height);\n        p = new Paint();\n        if (all &gt;= width) {\n            mLength = 80;\n        } else {\n            mLength = 30;\n            exteraLength = (int) Math.ceil(1.0 * all / (width - all));\n        }\n        this.setFocusable(true);\n        this.setKeepScreenOn(true);\n        i = 0;\n    }\n    public ColorView(Context context, AttributeSet attributeSet) {\n        super(context, attributeSet);\n        this.context = context;\n        WindowManager wm = (WindowManager) getContext().getSystemService(\n                Context.WINDOW_SERVICE);\n        width = wm.getDefaultDisplay().getWidth();\n        height = wm.getDefaultDisplay().getHeight();\n        System.out.println(\"width==\" + width);\n        System.out.println(\"height==\" + height);\n        p = new Paint();\n        p.setAntiAlias(true);\n        p.setStyle(Paint.Style.FILL);\n        if (all &gt;= width) {\n            mLength = 80;\n        } else {\n            mLength = 30;\n            exteraLength = (int) Math.ceil(1.0 * all / (width - all));\n        }\n        this.setFocusable(true);\n        this.setKeepScreenOn(true);\n        i = 0;\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        if (j &gt; all) {\n            //结束的情况。还是需要绘制的，不然界面会变黑\n            myDraw(canvas);\n            System.out.println(\"end\");\n            return;\n        }\n        myDraw(canvas);\n        j+=mLength;//改变j的值\n        invalidate();//onDraw后，重新绘制view,主观上产生动画效果\n    }\n\n\n    public void myDraw(Canvas canvas) {\n// 创建画笔\n//		红（R：255 G：0 B：0）\n//		橙（R：255 G：156 B：0）\n//		黄（R：255 G：255 B：0）\n//		绿（R：0 G：255 B：0）\n//		青（R： G：255 B：255）\n//		蓝（R：0 G：0 B：255）\n//		紫（R：255 G： B：255）\n        System.out.println(\"canvas\");\n        Log.i(\"Canvas:X:\", \"complexdraw\");\n        i = 0;\n        while (i &lt;= j) {\n            if (i &lt;= 255) {\n                p.setColor(Color.rgb(255, i, 0));\n            } else if (i &gt;= 256 &amp;&amp; i &lt;= 511) {\n                p.setColor(Color.rgb(511 - i, 255, 0));\n            } else if (i &gt;= 512 &amp;&amp; i &lt;= 767) {\n                p.setColor(Color.rgb(0, 255, i - 512));\n            } else if (i &gt;= 768 &amp;&amp; i &lt;= 1023) {\n                p.setColor(Color.rgb(0, 1023 - i, 255));\n            } else if (i &gt;= 1024 &amp;&amp; i &lt;= 1279) {\n                p.setColor(Color.rgb(i - 1024, 0, 255));\n            }\n            //处理不同的分辨率，造成画图的差异性，均分颜色值，屏幕宽度1280，颜色值的范围也是1280刚刚好，如果是小米电视的，屏幕宽度为1920,多出来的，需要均分，下面便是处理方式\n            if (exteraLength != 1) {\n                if (i % exteraLength == exteraLength - 1) {\n                    System.out.println(\"exteraLength==\" + exteraLength);\n                    System.out.println(\"current==\" + i);\n                    canvas.drawLine(i + i / exteraLength, 0, i + i / exteraLength, height, p);//画线\n                    canvas.drawLine(i + i / exteraLength + 1, 0, i + i / exteraLength + 1, height, p);\n                } else {\n                    System.out.println(\"exteraLength==1---------&gt;\" + exteraLength);\n                    System.out.println(\"current==\" + i);\n                    canvas.drawLine(i + i / exteraLength, 0, i + i / exteraLength, height, p);\n                }\n            } else {\n                canvas.drawLine(i, 0, i, height, p);\n            }\n            i++;\n        }\n    }\n}</pre>\n<br> MainActivity.java\n<p></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>\n<pre name=\"code\" class=\"java\">public class MainActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(R.layout.activity_color);\n    }\n}</pre>\n<br> activity_color.xml\n<p></p> \n<p><span style=\"font-size:18px\"><strong></strong></span></p>\n<pre name=\"code\" class=\"html\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n\n&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n              android:orientation=\"vertical\"\n              android:layout_width=\"fill_parent\"\n              android:layout_height=\"fill_parent\"&gt;\n    &lt;com.xxx.demo.ColorView\n            android:id=\"@+id/colorView\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"fill_parent\"\n            /&gt;\n&lt;/LinearLayout&gt;</pre>\n<br> 在自定义view中的onDraw（）方法中，调用invalidate（）方法，可以实现类似于小球移动的效果。。\n<p></p>',NULL,NULL,'2014-08-10 17:04:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/38471303','android tv'),
	(33,'android studio 报编码 GBK 的不可映射字符问题','<p><strong><span style=\"font-size:18px\">解决办法：在build.gradle文件中添加：</span></strong></p> \n<p><strong><span style=\"font-size:18px\">buildscript {<br> &nbsp; &nbsp; repositories {<br> &nbsp; &nbsp; &nbsp; &nbsp; maven { url \'http://repo1.maven.org/maven2\' }<br> &nbsp; &nbsp; }<br> &nbsp; &nbsp; dependencies {<br> &nbsp; &nbsp; &nbsp; &nbsp; classpath \'com.android.tools.build:gradle:0.4\'<br> &nbsp; &nbsp; }<br> }<br> apply plugin: \'android\'<br> <br> <br> dependencies {<br> &nbsp; &nbsp; compile files(\'libs/android-support-v4.jar\')<br> &nbsp; &nbsp; compile files(\'libs/umeng-analytics-v5.2.4.jar\')<br> }<br> <br> <br> android {<br> &nbsp; &nbsp; compileSdkVersion 17<br> &nbsp; &nbsp; buildToolsVersion \"17.0.0\"<br> <br> <br> &nbsp; &nbsp; defaultConfig {<br> &nbsp; &nbsp; &nbsp; &nbsp; minSdkVersion 7<br> &nbsp; &nbsp; &nbsp; &nbsp; targetSdkVersion 16<br> &nbsp; &nbsp; }<br> &nbsp; &nbsp; signingConfigs {<br> &nbsp; &nbsp; &nbsp; &nbsp; myConfig {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //...<br> &nbsp; &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; }<br> &nbsp; &nbsp; buildTypes {<br> &nbsp; &nbsp; &nbsp; &nbsp; release {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; signingConfig signingConfigs.myConfig<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; runProguard true<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proguardFile \'proguard-project.txt\'<br> &nbsp; &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; }<br> }<br> <span style=\"color:#ff0000\">tasks.withType(Compile) {<br> &nbsp; &nbsp; options.encoding = \"UTF-8\"<br> }</span><br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\">加上红色部分的代码就可以解决编码问题</span></strong></p> \n<p><br> </p> \n<p><br> </p>',NULL,NULL,'2014-07-24 14:05:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/38083631','android tv'),
	(34,'自定义view中在指定的矩形区域中放入一张图片','<p><strong><span style=\"font-size:18px\">如何在自定义view中，在指定的矩形区域中放入一张图片，让其刚好填充这个矩形区域，办法只能是对图片进行放大或者是缩小。</span></strong></p> \n<p><strong><span style=\"font-size:18px\"></span></strong></p>\n<pre name=\"code\" class=\"java\">Bitmap bitmap = BitmapFactory.decodeResource(getContext().getResources(), R.drawable.wenzi);//根据原来///的资源，得到bitmap\n        int bmpWidth = bitmap.getWidth();\n        int bmpHeight = bitmap.getHeight();\n        //矩形区域的大小，为正方形\n        int sideLength = height / 4;//矩形区域的大小，项目中使用的是正方形\n         /* 设置图片缩小比例 */\n        double scale = 0;\n//        //图片小于矩形区域,需要放大\n//        if(bmpWidth&lt;=sideLength){\n//        }else{\n//            //图片大于矩形区域，需要缩小\n//        }\n        /* 计算出缩小后的长宽 */\n        /* 产生Resize后的Bitmap对象 */\n        Matrix matrix = new Matrix();\n//       计算缩放率，新尺寸除原始尺寸\n        float scaleWidth = ((float) sideLength) / bmpWidth;\n        float scaleHeight = ((float) sideLength) / bmpHeight;\n        matrix.postScale(scaleWidth, scaleHeight);//设置缩放率，\n        Bitmap resizeBmp = Bitmap.createBitmap(bitmap, 0, 0, bmpWidth, bmpHeight,\n                matrix, true);//根据原图片和缩放大小，生成一张新的图片,这样图片的大小刚好与矩形区域是一致的</pre>\n<br> \n<br> \n<p></p>',NULL,NULL,'2014-07-23 10:18:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/38059275','android tv'),
	(35,'android canvas.drawBitmap的理解','<p><strong><span style=\"font-size:18px\">public void drawBitmap(android.graphics.Bitmap bitmap, float left, float top, android.graphics.Paint paint)</span></strong></p> \n<p><strong><span style=\"font-size:18px\">这个方法left,top指的是bitmap放置的左上方的坐标。是相对于屏幕整体来说的坐标位置。</span></strong></p> \n<p><span style=\"font-size:18px\"><strong>//以下部分转自<a target=\"_blank\" href=\"http://blog.csdn.net/zgf1991/article/details/7315281\">http://blog.csdn.net/zgf1991/article/details/7315281</a></strong></span></p> \n<p><strong><span style=\"font-size:18px\">public static void drawImage(Canvas canvas, Bitmap blt, int x, int y, int w, int h, int bx, int by) &nbsp;<br> &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //x,y表示绘画的起点， &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; Rect src = new Rect();// 图片 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; Rect dst = new Rect();// 屏幕 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; //src 这个是表示绘画图片的大小 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; src.left = bx; &nbsp; //0,0 &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; src.top = by; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; src.right = bx + w;// mBitDestTop.getWidth();,这个是桌面图的宽度， &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; src.bottom = by + h;//mBitDestTop.getHeight()/2;// 这个是桌面图的高度的一半 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; // 下面的 dst 是表示 绘画这个图片的位置 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; dst.left = x; &nbsp; //miDTX,//这个是可以改变的，也就是绘图的起点X位置 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; dst.top = y; &nbsp; &nbsp;//mBitQQ.getHeight();//这个是QQ图片的高度。 也就相当于 桌面图片绘画起点的Y坐标 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; dst.right = x + w; &nbsp;//miDTX + mBitDestTop.getWidth();// 表示需绘画的图片的右上角 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; dst.bottom = y + h; // mBitQQ.getHeight() + mBitDestTop.getHeight();//表示需绘画的图片的右下角 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; canvas.drawBitmap(blt, src, dst, null);//这个方法 &nbsp;第一个参数是图片，第二个参数是 绘画该图片需显示多少。也就是说你想绘画该图片的某一些地方，而不是全部图片，第三个参数表示该图片绘画的位置 &nbsp;<br> </span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"font-size:18px\"><strong>&nbsp;canvas.drawBitmap(blt, src, dst, null);</strong></span><br> </span></strong></p> \n<p><span style=\"font-weight:bold\"><span style=\"font-size:18px\"><span style=\"font-size:18px\"><strong>一般情况下来说，src这个矩形区域可以设置为(0,0,bmp.getWidth(),bmp.getHeight());一般就这样设置就可以了，当初在项目中设置的src,dst都是完全一样的，导致四个<span style=\"font-size:18px\"><strong>drawBitmap只显示了一个，根据上文的理解，就明白了。</strong></span></strong></span></span></span></p> \n<p><strong><span style=\"font-size:18px\"><br> </span></strong></p>',NULL,NULL,'2014-07-23 10:03:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/38058659','android tv'),
	(36,'android tv开发碰到的坑儿----第一篇','<p><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>记录时间为2014年7月21，这些问题发生于7.5到7.20之间</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>问题1：</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>gridview焦点问题，用gridview主要是想实现9宫格的布局风格，但是电视应用上会出现问题，没有办法填充整个屏幕，之后采用的是layout-weight权重分配的方式，解决的问题，还有onitemClick{}获取焦点的问题，暂时先记录一下问题，留待以后仔细探讨。</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>问题2：</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>用surfaceview实现画图效果，画的是动态可以随时改变的图形，（当然view也可以），implement callback runnable ,对于其原理还不是了解，现在只能仿着例子来写。</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>问题3：</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>图片效果，imageView中的android:scaleType属性的作用，对于这个属性的各个值需要了解其区别在哪</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>问题4:</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>自定义view实现的一些效果，好好体会一下，android canvas的处理过程，并贴出自己所做的一些简单的效果</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>问题5：</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>自定义view的竖排字体的显示，对齐问题，主要是由字体造成的，换成微软雅黑看起来就没有问题了，相对来说没有弯曲。</span></strong></p> \n<p><strong><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>问题6：<span style=\"white-space:pre\"> </span></span></strong></p> \n<p><span style=\"font-weight:bold; white-space:pre\"></span><span style=\"font-size:18px\"><strong>色彩滑动效果，想要实现色彩谱图的效果，并且还要有滑动，滚动的效果，目前做出来的只是简单的，并不是设计人员需要的，以后完善</strong></span></p> \n<p><span style=\"font-size:18px\"><strong><span style=\"white-space:pre\"></span>问题7：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong><span style=\"white-space:pre\"></span>自定义view在xml文件中的显示，加载xml的原理，机制，需要理解android是怎么处理view的显示的，内部做了哪些事情</strong></span></p> \n<p><span style=\"font-size:18px\"><strong><span style=\"white-space:pre\"></span>问题8：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong><span style=\"white-space:pre\"></span>view的生命周期，处理过程（跟7类似）</strong></span></p> \n<p><span style=\"font-size:18px\"><strong><span style=\"white-space:pre\"></span>问题9：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong><span style=\"white-space:pre\"></span>按键key的处理流程，tv开发，主要都是键盘事件，需要好好理解一下，系统的处理过程，还有就是view的监听，activity,焦点的问题，都需要理清楚</strong></span></p> \n<p><span style=\"font-size:18px\"><strong><span style=\"white-space:pre\"></span>问题10：</strong></span></p> \n<p><span style=\"font-size:18px\"><strong><span style=\"white-space:pre\"></span>动画效果，和前面说的某一点比较像，一遍画线，一遍移动它，做显示，这个效果一直做不出来，伤不起啊</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>问题11：handle.post方法，以前没有深入理解，现在需要抽出时间，仔细去体会他的处理过程，跟普通的子线程，传递消息的区别</strong></span></p> \n<p><span style=\"font-size:18px\"><strong>先留下这么多的坑，有时间来填。。。</strong></span></p> \n<p><span style=\"white-space:pre\"></span></p>',NULL,NULL,'2014-07-21 20:37:00',NULL,NULL,NULL,NULL,'http://blog.csdn.net/xxx823952375/article/details/38023479','android tv');

/*!40000 ALTER TABLE `tb_csdn_article` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table tb_csdn_category
# ------------------------------------------------------------

DROP TABLE IF EXISTS `tb_csdn_category`;

CREATE TABLE `tb_csdn_category` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `url` varchar(256) DEFAULT NULL COMMENT 'csdn上的来源地址',
  `categoryname` varchar(40) DEFAULT NULL COMMENT '名称',
  `count` int(11) DEFAULT NULL COMMENT '统计的数量',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `tb_csdn_category` WRITE;
/*!40000 ALTER TABLE `tb_csdn_category` DISABLE KEYS */;

INSERT INTO `tb_csdn_category` (`id`, `url`, `categoryname`, `count`)
VALUES
	(1,'http://blog.csdn.net/xxx823952375/article/category/1731575','java基础',0),
	(2,'http://blog.csdn.net/xxx823952375/article/category/1731577','ssh常见问题',1),
	(3,'http://blog.csdn.net/xxx823952375/article/category/1731579','php',2),
	(4,'http://blog.csdn.net/xxx823952375/article/category/1734663','职业生涯',0),
	(5,'http://blog.csdn.net/xxx823952375/article/category/1828377','感悟',2),
	(6,'http://blog.csdn.net/xxx823952375/article/category/1828643','杂项',1),
	(7,'http://blog.csdn.net/xxx823952375/article/category/2147989','android',7),
	(8,'http://blog.csdn.net/xxx823952375/article/category/2267359','算法',15),
	(9,'http://blog.csdn.net/xxx823952375/article/category/2334553','java插件',1),
	(10,'http://blog.csdn.net/xxx823952375/article/category/2412277','android tv',7);

/*!40000 ALTER TABLE `tb_csdn_category` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table tb_timeline
# ------------------------------------------------------------

DROP TABLE IF EXISTS `tb_timeline`;

CREATE TABLE `tb_timeline` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `timestr` int(11) DEFAULT NULL COMMENT '时间范围，标志一个月',
  `descr` varchar(30) DEFAULT '' COMMENT '时间的中文描述',
  `articlecount` int(11) DEFAULT NULL COMMENT '统计文章的篇数',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='文章信息表';

LOCK TABLES `tb_timeline` WRITE;
/*!40000 ALTER TABLE `tb_timeline` DISABLE KEYS */;

INSERT INTO `tb_timeline` (`id`, `timestr`, `descr`, `articlecount`)
VALUES
	(1,201312,'2013年12月',3),
	(2,201403,'2014年03月',2),
	(3,201404,'2014年04月',2),
	(4,201405,'2014年05月',15),
	(5,201406,'2014年06月',1),
	(6,201407,'2014年07月',7),
	(7,201408,'2014年08月',6),
	(8,201506,'2015年06月',8);

/*!40000 ALTER TABLE `tb_timeline` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table tb_timeline_l
# ------------------------------------------------------------

DROP TABLE IF EXISTS `tb_timeline_l`;

CREATE TABLE `tb_timeline_l` (
  `id` int(11) NOT NULL COMMENT '主键',
  `timestr` int(11) DEFAULT NULL COMMENT '时间范围，标志一个月',
  `descr` varchar(30) DEFAULT '' COMMENT '时间的中文描述',
  `articlecount` int(11) DEFAULT NULL COMMENT '统计文章的篇数'
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='文章信息表';




/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
